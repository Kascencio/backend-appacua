
/**
 * Client
**/

import * as runtime from '@prisma/client/runtime/library.js';
import $Types = runtime.Types // general types
import $Public = runtime.Types.Public
import $Utils = runtime.Types.Utils
import $Extensions = runtime.Types.Extensions
import $Result = runtime.Types.Result

export type PrismaPromise<T> = $Public.PrismaPromise<T>


/**
 * Model Organizacion
 * 
 */
export type Organizacion = $Result.DefaultSelection<Prisma.$OrganizacionPayload>
/**
 * Model OrganizacionSucursal
 * 
 */
export type OrganizacionSucursal = $Result.DefaultSelection<Prisma.$OrganizacionSucursalPayload>
/**
 * Model Instalacion
 * 
 */
export type Instalacion = $Result.DefaultSelection<Prisma.$InstalacionPayload>
/**
 * Model CatalogoSensor
 * 
 */
export type CatalogoSensor = $Result.DefaultSelection<Prisma.$CatalogoSensorPayload>
/**
 * Model SensorInstalado
 * 
 */
export type SensorInstalado = $Result.DefaultSelection<Prisma.$SensorInstaladoPayload>
/**
 * Model Lectura
 * 
 */
export type Lectura = $Result.DefaultSelection<Prisma.$LecturaPayload>
/**
 * Model ResumenLecturaHoraria
 * 
 */
export type ResumenLecturaHoraria = $Result.DefaultSelection<Prisma.$ResumenLecturaHorariaPayload>
/**
 * Model Promedio15min
 * 
 */
export type Promedio15min = $Result.DefaultSelection<Prisma.$Promedio15minPayload>
/**
 * Model Estado
 * 
 */
export type Estado = $Result.DefaultSelection<Prisma.$EstadoPayload>
/**
 * Model Municipio
 * 
 */
export type Municipio = $Result.DefaultSelection<Prisma.$MunicipioPayload>
/**
 * Model CodigoPostal
 * 
 */
export type CodigoPostal = $Result.DefaultSelection<Prisma.$CodigoPostalPayload>
/**
 * Model Colonia
 * 
 */
export type Colonia = $Result.DefaultSelection<Prisma.$ColoniaPayload>
/**
 * Model Usuario
 * 
 */
export type Usuario = $Result.DefaultSelection<Prisma.$UsuarioPayload>
/**
 * Model TipoRol
 * 
 */
export type TipoRol = $Result.DefaultSelection<Prisma.$TipoRolPayload>
/**
 * Model Alerta
 * 
 */
export type Alerta = $Result.DefaultSelection<Prisma.$AlertaPayload>
/**
 * Model Parametro
 * 
 */
export type Parametro = $Result.DefaultSelection<Prisma.$ParametroPayload>
/**
 * Model CatalogoEspecie
 * 
 */
export type CatalogoEspecie = $Result.DefaultSelection<Prisma.$CatalogoEspeciePayload>
/**
 * Model EspecieInstalada
 * 
 */
export type EspecieInstalada = $Result.DefaultSelection<Prisma.$EspecieInstaladaPayload>
/**
 * Model EspecieTracking
 * 
 */
export type EspecieTracking = $Result.DefaultSelection<Prisma.$EspecieTrackingPayload>
/**
 * Model EspecieParametro
 * 
 */
export type EspecieParametro = $Result.DefaultSelection<Prisma.$EspecieParametroPayload>
/**
 * Model Proceso
 * 
 */
export type Proceso = $Result.DefaultSelection<Prisma.$ProcesoPayload>

/**
 * Enums
 */
export namespace $Enums {
  export const TipoMedida: {
  temperatura: 'temperatura',
  ph: 'ph',
  oxigeno_disuelto: 'oxigeno_disuelto',
  conductividad: 'conductividad',
  turbidez: 'turbidez',
  salinidad: 'salinidad',
  otro: 'otro'
};

export type TipoMedida = (typeof TipoMedida)[keyof typeof TipoMedida]


export const NivelAlerta: {
  info: 'info',
  warning: 'warning',
  critical: 'critical'
};

export type NivelAlerta = (typeof NivelAlerta)[keyof typeof NivelAlerta]

}

export type TipoMedida = $Enums.TipoMedida

export const TipoMedida: typeof $Enums.TipoMedida

export type NivelAlerta = $Enums.NivelAlerta

export const NivelAlerta: typeof $Enums.NivelAlerta

/**
 * ##  Prisma Client ʲˢ
 * 
 * Type-safe database client for TypeScript & Node.js
 * @example
 * ```
 * const prisma = new PrismaClient()
 * // Fetch zero or more Organizacions
 * const organizacions = await prisma.organizacion.findMany()
 * ```
 *
 * 
 * Read more in our [docs](https://www.prisma.io/docs/reference/tools-and-interfaces/prisma-client).
 */
export class PrismaClient<
  ClientOptions extends Prisma.PrismaClientOptions = Prisma.PrismaClientOptions,
  U = 'log' extends keyof ClientOptions ? ClientOptions['log'] extends Array<Prisma.LogLevel | Prisma.LogDefinition> ? Prisma.GetEvents<ClientOptions['log']> : never : never,
  ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs
> {
  [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['other'] }

    /**
   * ##  Prisma Client ʲˢ
   * 
   * Type-safe database client for TypeScript & Node.js
   * @example
   * ```
   * const prisma = new PrismaClient()
   * // Fetch zero or more Organizacions
   * const organizacions = await prisma.organizacion.findMany()
   * ```
   *
   * 
   * Read more in our [docs](https://www.prisma.io/docs/reference/tools-and-interfaces/prisma-client).
   */

  constructor(optionsArg ?: Prisma.Subset<ClientOptions, Prisma.PrismaClientOptions>);
  $on<V extends U>(eventType: V, callback: (event: V extends 'query' ? Prisma.QueryEvent : Prisma.LogEvent) => void): void;

  /**
   * Connect with the database
   */
  $connect(): $Utils.JsPromise<void>;

  /**
   * Disconnect from the database
   */
  $disconnect(): $Utils.JsPromise<void>;

  /**
   * Add a middleware
   * @deprecated since 4.16.0. For new code, prefer client extensions instead.
   * @see https://pris.ly/d/extensions
   */
  $use(cb: Prisma.Middleware): void

/**
   * Executes a prepared raw query and returns the number of affected rows.
   * @example
   * ```
   * const result = await prisma.$executeRaw`UPDATE User SET cool = ${true} WHERE email = ${'user@email.com'};`
   * ```
   * 
   * Read more in our [docs](https://www.prisma.io/docs/reference/tools-and-interfaces/prisma-client/raw-database-access).
   */
  $executeRaw<T = unknown>(query: TemplateStringsArray | Prisma.Sql, ...values: any[]): Prisma.PrismaPromise<number>;

  /**
   * Executes a raw query and returns the number of affected rows.
   * Susceptible to SQL injections, see documentation.
   * @example
   * ```
   * const result = await prisma.$executeRawUnsafe('UPDATE User SET cool = $1 WHERE email = $2 ;', true, 'user@email.com')
   * ```
   * 
   * Read more in our [docs](https://www.prisma.io/docs/reference/tools-and-interfaces/prisma-client/raw-database-access).
   */
  $executeRawUnsafe<T = unknown>(query: string, ...values: any[]): Prisma.PrismaPromise<number>;

  /**
   * Performs a prepared raw query and returns the `SELECT` data.
   * @example
   * ```
   * const result = await prisma.$queryRaw`SELECT * FROM User WHERE id = ${1} OR email = ${'user@email.com'};`
   * ```
   * 
   * Read more in our [docs](https://www.prisma.io/docs/reference/tools-and-interfaces/prisma-client/raw-database-access).
   */
  $queryRaw<T = unknown>(query: TemplateStringsArray | Prisma.Sql, ...values: any[]): Prisma.PrismaPromise<T>;

  /**
   * Performs a raw query and returns the `SELECT` data.
   * Susceptible to SQL injections, see documentation.
   * @example
   * ```
   * const result = await prisma.$queryRawUnsafe('SELECT * FROM User WHERE id = $1 OR email = $2;', 1, 'user@email.com')
   * ```
   * 
   * Read more in our [docs](https://www.prisma.io/docs/reference/tools-and-interfaces/prisma-client/raw-database-access).
   */
  $queryRawUnsafe<T = unknown>(query: string, ...values: any[]): Prisma.PrismaPromise<T>;


  /**
   * Allows the running of a sequence of read/write operations that are guaranteed to either succeed or fail as a whole.
   * @example
   * ```
   * const [george, bob, alice] = await prisma.$transaction([
   *   prisma.user.create({ data: { name: 'George' } }),
   *   prisma.user.create({ data: { name: 'Bob' } }),
   *   prisma.user.create({ data: { name: 'Alice' } }),
   * ])
   * ```
   * 
   * Read more in our [docs](https://www.prisma.io/docs/concepts/components/prisma-client/transactions).
   */
  $transaction<P extends Prisma.PrismaPromise<any>[]>(arg: [...P], options?: { isolationLevel?: Prisma.TransactionIsolationLevel }): $Utils.JsPromise<runtime.Types.Utils.UnwrapTuple<P>>

  $transaction<R>(fn: (prisma: Omit<PrismaClient, runtime.ITXClientDenyList>) => $Utils.JsPromise<R>, options?: { maxWait?: number, timeout?: number, isolationLevel?: Prisma.TransactionIsolationLevel }): $Utils.JsPromise<R>


  $extends: $Extensions.ExtendsHook<"extends", Prisma.TypeMapCb, ExtArgs>

      /**
   * `prisma.organizacion`: Exposes CRUD operations for the **Organizacion** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Organizacions
    * const organizacions = await prisma.organizacion.findMany()
    * ```
    */
  get organizacion(): Prisma.OrganizacionDelegate<ExtArgs>;

  /**
   * `prisma.organizacionSucursal`: Exposes CRUD operations for the **OrganizacionSucursal** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more OrganizacionSucursals
    * const organizacionSucursals = await prisma.organizacionSucursal.findMany()
    * ```
    */
  get organizacionSucursal(): Prisma.OrganizacionSucursalDelegate<ExtArgs>;

  /**
   * `prisma.instalacion`: Exposes CRUD operations for the **Instalacion** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Instalacions
    * const instalacions = await prisma.instalacion.findMany()
    * ```
    */
  get instalacion(): Prisma.InstalacionDelegate<ExtArgs>;

  /**
   * `prisma.catalogoSensor`: Exposes CRUD operations for the **CatalogoSensor** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more CatalogoSensors
    * const catalogoSensors = await prisma.catalogoSensor.findMany()
    * ```
    */
  get catalogoSensor(): Prisma.CatalogoSensorDelegate<ExtArgs>;

  /**
   * `prisma.sensorInstalado`: Exposes CRUD operations for the **SensorInstalado** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more SensorInstalados
    * const sensorInstalados = await prisma.sensorInstalado.findMany()
    * ```
    */
  get sensorInstalado(): Prisma.SensorInstaladoDelegate<ExtArgs>;

  /**
   * `prisma.lectura`: Exposes CRUD operations for the **Lectura** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Lecturas
    * const lecturas = await prisma.lectura.findMany()
    * ```
    */
  get lectura(): Prisma.LecturaDelegate<ExtArgs>;

  /**
   * `prisma.resumenLecturaHoraria`: Exposes CRUD operations for the **ResumenLecturaHoraria** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more ResumenLecturaHorarias
    * const resumenLecturaHorarias = await prisma.resumenLecturaHoraria.findMany()
    * ```
    */
  get resumenLecturaHoraria(): Prisma.ResumenLecturaHorariaDelegate<ExtArgs>;

  /**
   * `prisma.promedio15min`: Exposes CRUD operations for the **Promedio15min** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Promedio15mins
    * const promedio15mins = await prisma.promedio15min.findMany()
    * ```
    */
  get promedio15min(): Prisma.Promedio15minDelegate<ExtArgs>;

  /**
   * `prisma.estado`: Exposes CRUD operations for the **Estado** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Estados
    * const estados = await prisma.estado.findMany()
    * ```
    */
  get estado(): Prisma.EstadoDelegate<ExtArgs>;

  /**
   * `prisma.municipio`: Exposes CRUD operations for the **Municipio** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Municipios
    * const municipios = await prisma.municipio.findMany()
    * ```
    */
  get municipio(): Prisma.MunicipioDelegate<ExtArgs>;

  /**
   * `prisma.codigoPostal`: Exposes CRUD operations for the **CodigoPostal** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more CodigoPostals
    * const codigoPostals = await prisma.codigoPostal.findMany()
    * ```
    */
  get codigoPostal(): Prisma.CodigoPostalDelegate<ExtArgs>;

  /**
   * `prisma.colonia`: Exposes CRUD operations for the **Colonia** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Colonias
    * const colonias = await prisma.colonia.findMany()
    * ```
    */
  get colonia(): Prisma.ColoniaDelegate<ExtArgs>;

  /**
   * `prisma.usuario`: Exposes CRUD operations for the **Usuario** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Usuarios
    * const usuarios = await prisma.usuario.findMany()
    * ```
    */
  get usuario(): Prisma.UsuarioDelegate<ExtArgs>;

  /**
   * `prisma.tipoRol`: Exposes CRUD operations for the **TipoRol** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more TipoRols
    * const tipoRols = await prisma.tipoRol.findMany()
    * ```
    */
  get tipoRol(): Prisma.TipoRolDelegate<ExtArgs>;

  /**
   * `prisma.alerta`: Exposes CRUD operations for the **Alerta** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Alertas
    * const alertas = await prisma.alerta.findMany()
    * ```
    */
  get alerta(): Prisma.AlertaDelegate<ExtArgs>;

  /**
   * `prisma.parametro`: Exposes CRUD operations for the **Parametro** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Parametros
    * const parametros = await prisma.parametro.findMany()
    * ```
    */
  get parametro(): Prisma.ParametroDelegate<ExtArgs>;

  /**
   * `prisma.catalogoEspecie`: Exposes CRUD operations for the **CatalogoEspecie** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more CatalogoEspecies
    * const catalogoEspecies = await prisma.catalogoEspecie.findMany()
    * ```
    */
  get catalogoEspecie(): Prisma.CatalogoEspecieDelegate<ExtArgs>;

  /**
   * `prisma.especieInstalada`: Exposes CRUD operations for the **EspecieInstalada** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more EspecieInstaladas
    * const especieInstaladas = await prisma.especieInstalada.findMany()
    * ```
    */
  get especieInstalada(): Prisma.EspecieInstaladaDelegate<ExtArgs>;

  /**
   * `prisma.especieTracking`: Exposes CRUD operations for the **EspecieTracking** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more EspecieTrackings
    * const especieTrackings = await prisma.especieTracking.findMany()
    * ```
    */
  get especieTracking(): Prisma.EspecieTrackingDelegate<ExtArgs>;

  /**
   * `prisma.especieParametro`: Exposes CRUD operations for the **EspecieParametro** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more EspecieParametros
    * const especieParametros = await prisma.especieParametro.findMany()
    * ```
    */
  get especieParametro(): Prisma.EspecieParametroDelegate<ExtArgs>;

  /**
   * `prisma.proceso`: Exposes CRUD operations for the **Proceso** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Procesos
    * const procesos = await prisma.proceso.findMany()
    * ```
    */
  get proceso(): Prisma.ProcesoDelegate<ExtArgs>;
}

export namespace Prisma {
  export import DMMF = runtime.DMMF

  export type PrismaPromise<T> = $Public.PrismaPromise<T>

  /**
   * Validator
   */
  export import validator = runtime.Public.validator

  /**
   * Prisma Errors
   */
  export import PrismaClientKnownRequestError = runtime.PrismaClientKnownRequestError
  export import PrismaClientUnknownRequestError = runtime.PrismaClientUnknownRequestError
  export import PrismaClientRustPanicError = runtime.PrismaClientRustPanicError
  export import PrismaClientInitializationError = runtime.PrismaClientInitializationError
  export import PrismaClientValidationError = runtime.PrismaClientValidationError
  export import NotFoundError = runtime.NotFoundError

  /**
   * Re-export of sql-template-tag
   */
  export import sql = runtime.sqltag
  export import empty = runtime.empty
  export import join = runtime.join
  export import raw = runtime.raw
  export import Sql = runtime.Sql



  /**
   * Decimal.js
   */
  export import Decimal = runtime.Decimal

  export type DecimalJsLike = runtime.DecimalJsLike

  /**
   * Metrics 
   */
  export type Metrics = runtime.Metrics
  export type Metric<T> = runtime.Metric<T>
  export type MetricHistogram = runtime.MetricHistogram
  export type MetricHistogramBucket = runtime.MetricHistogramBucket

  /**
  * Extensions
  */
  export import Extension = $Extensions.UserArgs
  export import getExtensionContext = runtime.Extensions.getExtensionContext
  export import Args = $Public.Args
  export import Payload = $Public.Payload
  export import Result = $Public.Result
  export import Exact = $Public.Exact

  /**
   * Prisma Client JS version: 5.22.0
   * Query Engine version: 605197351a3c8bdd595af2d2a9bc3025bca48ea2
   */
  export type PrismaVersion = {
    client: string
  }

  export const prismaVersion: PrismaVersion 

  /**
   * Utility Types
   */


  export import JsonObject = runtime.JsonObject
  export import JsonArray = runtime.JsonArray
  export import JsonValue = runtime.JsonValue
  export import InputJsonObject = runtime.InputJsonObject
  export import InputJsonArray = runtime.InputJsonArray
  export import InputJsonValue = runtime.InputJsonValue

  /**
   * Types of the values used to represent different kinds of `null` values when working with JSON fields.
   * 
   * @see https://www.prisma.io/docs/concepts/components/prisma-client/working-with-fields/working-with-json-fields#filtering-on-a-json-field
   */
  namespace NullTypes {
    /**
    * Type of `Prisma.DbNull`.
    * 
    * You cannot use other instances of this class. Please use the `Prisma.DbNull` value.
    * 
    * @see https://www.prisma.io/docs/concepts/components/prisma-client/working-with-fields/working-with-json-fields#filtering-on-a-json-field
    */
    class DbNull {
      private DbNull: never
      private constructor()
    }

    /**
    * Type of `Prisma.JsonNull`.
    * 
    * You cannot use other instances of this class. Please use the `Prisma.JsonNull` value.
    * 
    * @see https://www.prisma.io/docs/concepts/components/prisma-client/working-with-fields/working-with-json-fields#filtering-on-a-json-field
    */
    class JsonNull {
      private JsonNull: never
      private constructor()
    }

    /**
    * Type of `Prisma.AnyNull`.
    * 
    * You cannot use other instances of this class. Please use the `Prisma.AnyNull` value.
    * 
    * @see https://www.prisma.io/docs/concepts/components/prisma-client/working-with-fields/working-with-json-fields#filtering-on-a-json-field
    */
    class AnyNull {
      private AnyNull: never
      private constructor()
    }
  }

  /**
   * Helper for filtering JSON entries that have `null` on the database (empty on the db)
   * 
   * @see https://www.prisma.io/docs/concepts/components/prisma-client/working-with-fields/working-with-json-fields#filtering-on-a-json-field
   */
  export const DbNull: NullTypes.DbNull

  /**
   * Helper for filtering JSON entries that have JSON `null` values (not empty on the db)
   * 
   * @see https://www.prisma.io/docs/concepts/components/prisma-client/working-with-fields/working-with-json-fields#filtering-on-a-json-field
   */
  export const JsonNull: NullTypes.JsonNull

  /**
   * Helper for filtering JSON entries that are `Prisma.DbNull` or `Prisma.JsonNull`
   * 
   * @see https://www.prisma.io/docs/concepts/components/prisma-client/working-with-fields/working-with-json-fields#filtering-on-a-json-field
   */
  export const AnyNull: NullTypes.AnyNull

  type SelectAndInclude = {
    select: any
    include: any
  }

  type SelectAndOmit = {
    select: any
    omit: any
  }

  /**
   * Get the type of the value, that the Promise holds.
   */
  export type PromiseType<T extends PromiseLike<any>> = T extends PromiseLike<infer U> ? U : T;

  /**
   * Get the return type of a function which returns a Promise.
   */
  export type PromiseReturnType<T extends (...args: any) => $Utils.JsPromise<any>> = PromiseType<ReturnType<T>>

  /**
   * From T, pick a set of properties whose keys are in the union K
   */
  type Prisma__Pick<T, K extends keyof T> = {
      [P in K]: T[P];
  };


  export type Enumerable<T> = T | Array<T>;

  export type RequiredKeys<T> = {
    [K in keyof T]-?: {} extends Prisma__Pick<T, K> ? never : K
  }[keyof T]

  export type TruthyKeys<T> = keyof {
    [K in keyof T as T[K] extends false | undefined | null ? never : K]: K
  }

  export type TrueKeys<T> = TruthyKeys<Prisma__Pick<T, RequiredKeys<T>>>

  /**
   * Subset
   * @desc From `T` pick properties that exist in `U`. Simple version of Intersection
   */
  export type Subset<T, U> = {
    [key in keyof T]: key extends keyof U ? T[key] : never;
  };

  /**
   * SelectSubset
   * @desc From `T` pick properties that exist in `U`. Simple version of Intersection.
   * Additionally, it validates, if both select and include are present. If the case, it errors.
   */
  export type SelectSubset<T, U> = {
    [key in keyof T]: key extends keyof U ? T[key] : never
  } &
    (T extends SelectAndInclude
      ? 'Please either choose `select` or `include`.'
      : T extends SelectAndOmit
        ? 'Please either choose `select` or `omit`.'
        : {})

  /**
   * Subset + Intersection
   * @desc From `T` pick properties that exist in `U` and intersect `K`
   */
  export type SubsetIntersection<T, U, K> = {
    [key in keyof T]: key extends keyof U ? T[key] : never
  } &
    K

  type Without<T, U> = { [P in Exclude<keyof T, keyof U>]?: never };

  /**
   * XOR is needed to have a real mutually exclusive union type
   * https://stackoverflow.com/questions/42123407/does-typescript-support-mutually-exclusive-types
   */
  type XOR<T, U> =
    T extends object ?
    U extends object ?
      (Without<T, U> & U) | (Without<U, T> & T)
    : U : T


  /**
   * Is T a Record?
   */
  type IsObject<T extends any> = T extends Array<any>
  ? False
  : T extends Date
  ? False
  : T extends Uint8Array
  ? False
  : T extends BigInt
  ? False
  : T extends object
  ? True
  : False


  /**
   * If it's T[], return T
   */
  export type UnEnumerate<T extends unknown> = T extends Array<infer U> ? U : T

  /**
   * From ts-toolbelt
   */

  type __Either<O extends object, K extends Key> = Omit<O, K> &
    {
      // Merge all but K
      [P in K]: Prisma__Pick<O, P & keyof O> // With K possibilities
    }[K]

  type EitherStrict<O extends object, K extends Key> = Strict<__Either<O, K>>

  type EitherLoose<O extends object, K extends Key> = ComputeRaw<__Either<O, K>>

  type _Either<
    O extends object,
    K extends Key,
    strict extends Boolean
  > = {
    1: EitherStrict<O, K>
    0: EitherLoose<O, K>
  }[strict]

  type Either<
    O extends object,
    K extends Key,
    strict extends Boolean = 1
  > = O extends unknown ? _Either<O, K, strict> : never

  export type Union = any

  type PatchUndefined<O extends object, O1 extends object> = {
    [K in keyof O]: O[K] extends undefined ? At<O1, K> : O[K]
  } & {}

  /** Helper Types for "Merge" **/
  export type IntersectOf<U extends Union> = (
    U extends unknown ? (k: U) => void : never
  ) extends (k: infer I) => void
    ? I
    : never

  export type Overwrite<O extends object, O1 extends object> = {
      [K in keyof O]: K extends keyof O1 ? O1[K] : O[K];
  } & {};

  type _Merge<U extends object> = IntersectOf<Overwrite<U, {
      [K in keyof U]-?: At<U, K>;
  }>>;

  type Key = string | number | symbol;
  type AtBasic<O extends object, K extends Key> = K extends keyof O ? O[K] : never;
  type AtStrict<O extends object, K extends Key> = O[K & keyof O];
  type AtLoose<O extends object, K extends Key> = O extends unknown ? AtStrict<O, K> : never;
  export type At<O extends object, K extends Key, strict extends Boolean = 1> = {
      1: AtStrict<O, K>;
      0: AtLoose<O, K>;
  }[strict];

  export type ComputeRaw<A extends any> = A extends Function ? A : {
    [K in keyof A]: A[K];
  } & {};

  export type OptionalFlat<O> = {
    [K in keyof O]?: O[K];
  } & {};

  type _Record<K extends keyof any, T> = {
    [P in K]: T;
  };

  // cause typescript not to expand types and preserve names
  type NoExpand<T> = T extends unknown ? T : never;

  // this type assumes the passed object is entirely optional
  type AtLeast<O extends object, K extends string> = NoExpand<
    O extends unknown
    ? | (K extends keyof O ? { [P in K]: O[P] } & O : O)
      | {[P in keyof O as P extends K ? K : never]-?: O[P]} & O
    : never>;

  type _Strict<U, _U = U> = U extends unknown ? U & OptionalFlat<_Record<Exclude<Keys<_U>, keyof U>, never>> : never;

  export type Strict<U extends object> = ComputeRaw<_Strict<U>>;
  /** End Helper Types for "Merge" **/

  export type Merge<U extends object> = ComputeRaw<_Merge<Strict<U>>>;

  /**
  A [[Boolean]]
  */
  export type Boolean = True | False

  // /**
  // 1
  // */
  export type True = 1

  /**
  0
  */
  export type False = 0

  export type Not<B extends Boolean> = {
    0: 1
    1: 0
  }[B]

  export type Extends<A1 extends any, A2 extends any> = [A1] extends [never]
    ? 0 // anything `never` is false
    : A1 extends A2
    ? 1
    : 0

  export type Has<U extends Union, U1 extends Union> = Not<
    Extends<Exclude<U1, U>, U1>
  >

  export type Or<B1 extends Boolean, B2 extends Boolean> = {
    0: {
      0: 0
      1: 1
    }
    1: {
      0: 1
      1: 1
    }
  }[B1][B2]

  export type Keys<U extends Union> = U extends unknown ? keyof U : never

  type Cast<A, B> = A extends B ? A : B;

  export const type: unique symbol;



  /**
   * Used by group by
   */

  export type GetScalarType<T, O> = O extends object ? {
    [P in keyof T]: P extends keyof O
      ? O[P]
      : never
  } : never

  type FieldPaths<
    T,
    U = Omit<T, '_avg' | '_sum' | '_count' | '_min' | '_max'>
  > = IsObject<T> extends True ? U : T

  type GetHavingFields<T> = {
    [K in keyof T]: Or<
      Or<Extends<'OR', K>, Extends<'AND', K>>,
      Extends<'NOT', K>
    > extends True
      ? // infer is only needed to not hit TS limit
        // based on the brilliant idea of Pierre-Antoine Mills
        // https://github.com/microsoft/TypeScript/issues/30188#issuecomment-478938437
        T[K] extends infer TK
        ? GetHavingFields<UnEnumerate<TK> extends object ? Merge<UnEnumerate<TK>> : never>
        : never
      : {} extends FieldPaths<T[K]>
      ? never
      : K
  }[keyof T]

  /**
   * Convert tuple to union
   */
  type _TupleToUnion<T> = T extends (infer E)[] ? E : never
  type TupleToUnion<K extends readonly any[]> = _TupleToUnion<K>
  type MaybeTupleToUnion<T> = T extends any[] ? TupleToUnion<T> : T

  /**
   * Like `Pick`, but additionally can also accept an array of keys
   */
  type PickEnumerable<T, K extends Enumerable<keyof T> | keyof T> = Prisma__Pick<T, MaybeTupleToUnion<K>>

  /**
   * Exclude all keys with underscores
   */
  type ExcludeUnderscoreKeys<T extends string> = T extends `_${string}` ? never : T


  export type FieldRef<Model, FieldType> = runtime.FieldRef<Model, FieldType>

  type FieldRefInputType<Model, FieldType> = Model extends never ? never : FieldRef<Model, FieldType>


  export const ModelName: {
    Organizacion: 'Organizacion',
    OrganizacionSucursal: 'OrganizacionSucursal',
    Instalacion: 'Instalacion',
    CatalogoSensor: 'CatalogoSensor',
    SensorInstalado: 'SensorInstalado',
    Lectura: 'Lectura',
    ResumenLecturaHoraria: 'ResumenLecturaHoraria',
    Promedio15min: 'Promedio15min',
    Estado: 'Estado',
    Municipio: 'Municipio',
    CodigoPostal: 'CodigoPostal',
    Colonia: 'Colonia',
    Usuario: 'Usuario',
    TipoRol: 'TipoRol',
    Alerta: 'Alerta',
    Parametro: 'Parametro',
    CatalogoEspecie: 'CatalogoEspecie',
    EspecieInstalada: 'EspecieInstalada',
    EspecieTracking: 'EspecieTracking',
    EspecieParametro: 'EspecieParametro',
    Proceso: 'Proceso'
  };

  export type ModelName = (typeof ModelName)[keyof typeof ModelName]


  export type Datasources = {
    db?: Datasource
  }

  interface TypeMapCb extends $Utils.Fn<{extArgs: $Extensions.InternalArgs, clientOptions: PrismaClientOptions }, $Utils.Record<string, any>> {
    returns: Prisma.TypeMap<this['params']['extArgs'], this['params']['clientOptions']>
  }

  export type TypeMap<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, ClientOptions = {}> = {
    meta: {
      modelProps: "organizacion" | "organizacionSucursal" | "instalacion" | "catalogoSensor" | "sensorInstalado" | "lectura" | "resumenLecturaHoraria" | "promedio15min" | "estado" | "municipio" | "codigoPostal" | "colonia" | "usuario" | "tipoRol" | "alerta" | "parametro" | "catalogoEspecie" | "especieInstalada" | "especieTracking" | "especieParametro" | "proceso"
      txIsolationLevel: Prisma.TransactionIsolationLevel
    }
    model: {
      Organizacion: {
        payload: Prisma.$OrganizacionPayload<ExtArgs>
        fields: Prisma.OrganizacionFieldRefs
        operations: {
          findUnique: {
            args: Prisma.OrganizacionFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$OrganizacionPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.OrganizacionFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$OrganizacionPayload>
          }
          findFirst: {
            args: Prisma.OrganizacionFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$OrganizacionPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.OrganizacionFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$OrganizacionPayload>
          }
          findMany: {
            args: Prisma.OrganizacionFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$OrganizacionPayload>[]
          }
          create: {
            args: Prisma.OrganizacionCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$OrganizacionPayload>
          }
          createMany: {
            args: Prisma.OrganizacionCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          delete: {
            args: Prisma.OrganizacionDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$OrganizacionPayload>
          }
          update: {
            args: Prisma.OrganizacionUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$OrganizacionPayload>
          }
          deleteMany: {
            args: Prisma.OrganizacionDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.OrganizacionUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          upsert: {
            args: Prisma.OrganizacionUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$OrganizacionPayload>
          }
          aggregate: {
            args: Prisma.OrganizacionAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateOrganizacion>
          }
          groupBy: {
            args: Prisma.OrganizacionGroupByArgs<ExtArgs>
            result: $Utils.Optional<OrganizacionGroupByOutputType>[]
          }
          count: {
            args: Prisma.OrganizacionCountArgs<ExtArgs>
            result: $Utils.Optional<OrganizacionCountAggregateOutputType> | number
          }
        }
      }
      OrganizacionSucursal: {
        payload: Prisma.$OrganizacionSucursalPayload<ExtArgs>
        fields: Prisma.OrganizacionSucursalFieldRefs
        operations: {
          findUnique: {
            args: Prisma.OrganizacionSucursalFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$OrganizacionSucursalPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.OrganizacionSucursalFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$OrganizacionSucursalPayload>
          }
          findFirst: {
            args: Prisma.OrganizacionSucursalFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$OrganizacionSucursalPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.OrganizacionSucursalFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$OrganizacionSucursalPayload>
          }
          findMany: {
            args: Prisma.OrganizacionSucursalFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$OrganizacionSucursalPayload>[]
          }
          create: {
            args: Prisma.OrganizacionSucursalCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$OrganizacionSucursalPayload>
          }
          createMany: {
            args: Prisma.OrganizacionSucursalCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          delete: {
            args: Prisma.OrganizacionSucursalDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$OrganizacionSucursalPayload>
          }
          update: {
            args: Prisma.OrganizacionSucursalUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$OrganizacionSucursalPayload>
          }
          deleteMany: {
            args: Prisma.OrganizacionSucursalDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.OrganizacionSucursalUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          upsert: {
            args: Prisma.OrganizacionSucursalUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$OrganizacionSucursalPayload>
          }
          aggregate: {
            args: Prisma.OrganizacionSucursalAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateOrganizacionSucursal>
          }
          groupBy: {
            args: Prisma.OrganizacionSucursalGroupByArgs<ExtArgs>
            result: $Utils.Optional<OrganizacionSucursalGroupByOutputType>[]
          }
          count: {
            args: Prisma.OrganizacionSucursalCountArgs<ExtArgs>
            result: $Utils.Optional<OrganizacionSucursalCountAggregateOutputType> | number
          }
        }
      }
      Instalacion: {
        payload: Prisma.$InstalacionPayload<ExtArgs>
        fields: Prisma.InstalacionFieldRefs
        operations: {
          findUnique: {
            args: Prisma.InstalacionFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$InstalacionPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.InstalacionFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$InstalacionPayload>
          }
          findFirst: {
            args: Prisma.InstalacionFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$InstalacionPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.InstalacionFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$InstalacionPayload>
          }
          findMany: {
            args: Prisma.InstalacionFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$InstalacionPayload>[]
          }
          create: {
            args: Prisma.InstalacionCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$InstalacionPayload>
          }
          createMany: {
            args: Prisma.InstalacionCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          delete: {
            args: Prisma.InstalacionDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$InstalacionPayload>
          }
          update: {
            args: Prisma.InstalacionUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$InstalacionPayload>
          }
          deleteMany: {
            args: Prisma.InstalacionDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.InstalacionUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          upsert: {
            args: Prisma.InstalacionUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$InstalacionPayload>
          }
          aggregate: {
            args: Prisma.InstalacionAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateInstalacion>
          }
          groupBy: {
            args: Prisma.InstalacionGroupByArgs<ExtArgs>
            result: $Utils.Optional<InstalacionGroupByOutputType>[]
          }
          count: {
            args: Prisma.InstalacionCountArgs<ExtArgs>
            result: $Utils.Optional<InstalacionCountAggregateOutputType> | number
          }
        }
      }
      CatalogoSensor: {
        payload: Prisma.$CatalogoSensorPayload<ExtArgs>
        fields: Prisma.CatalogoSensorFieldRefs
        operations: {
          findUnique: {
            args: Prisma.CatalogoSensorFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CatalogoSensorPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.CatalogoSensorFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CatalogoSensorPayload>
          }
          findFirst: {
            args: Prisma.CatalogoSensorFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CatalogoSensorPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.CatalogoSensorFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CatalogoSensorPayload>
          }
          findMany: {
            args: Prisma.CatalogoSensorFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CatalogoSensorPayload>[]
          }
          create: {
            args: Prisma.CatalogoSensorCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CatalogoSensorPayload>
          }
          createMany: {
            args: Prisma.CatalogoSensorCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          delete: {
            args: Prisma.CatalogoSensorDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CatalogoSensorPayload>
          }
          update: {
            args: Prisma.CatalogoSensorUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CatalogoSensorPayload>
          }
          deleteMany: {
            args: Prisma.CatalogoSensorDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.CatalogoSensorUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          upsert: {
            args: Prisma.CatalogoSensorUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CatalogoSensorPayload>
          }
          aggregate: {
            args: Prisma.CatalogoSensorAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateCatalogoSensor>
          }
          groupBy: {
            args: Prisma.CatalogoSensorGroupByArgs<ExtArgs>
            result: $Utils.Optional<CatalogoSensorGroupByOutputType>[]
          }
          count: {
            args: Prisma.CatalogoSensorCountArgs<ExtArgs>
            result: $Utils.Optional<CatalogoSensorCountAggregateOutputType> | number
          }
        }
      }
      SensorInstalado: {
        payload: Prisma.$SensorInstaladoPayload<ExtArgs>
        fields: Prisma.SensorInstaladoFieldRefs
        operations: {
          findUnique: {
            args: Prisma.SensorInstaladoFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SensorInstaladoPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.SensorInstaladoFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SensorInstaladoPayload>
          }
          findFirst: {
            args: Prisma.SensorInstaladoFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SensorInstaladoPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.SensorInstaladoFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SensorInstaladoPayload>
          }
          findMany: {
            args: Prisma.SensorInstaladoFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SensorInstaladoPayload>[]
          }
          create: {
            args: Prisma.SensorInstaladoCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SensorInstaladoPayload>
          }
          createMany: {
            args: Prisma.SensorInstaladoCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          delete: {
            args: Prisma.SensorInstaladoDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SensorInstaladoPayload>
          }
          update: {
            args: Prisma.SensorInstaladoUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SensorInstaladoPayload>
          }
          deleteMany: {
            args: Prisma.SensorInstaladoDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.SensorInstaladoUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          upsert: {
            args: Prisma.SensorInstaladoUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SensorInstaladoPayload>
          }
          aggregate: {
            args: Prisma.SensorInstaladoAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateSensorInstalado>
          }
          groupBy: {
            args: Prisma.SensorInstaladoGroupByArgs<ExtArgs>
            result: $Utils.Optional<SensorInstaladoGroupByOutputType>[]
          }
          count: {
            args: Prisma.SensorInstaladoCountArgs<ExtArgs>
            result: $Utils.Optional<SensorInstaladoCountAggregateOutputType> | number
          }
        }
      }
      Lectura: {
        payload: Prisma.$LecturaPayload<ExtArgs>
        fields: Prisma.LecturaFieldRefs
        operations: {
          findUnique: {
            args: Prisma.LecturaFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$LecturaPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.LecturaFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$LecturaPayload>
          }
          findFirst: {
            args: Prisma.LecturaFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$LecturaPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.LecturaFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$LecturaPayload>
          }
          findMany: {
            args: Prisma.LecturaFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$LecturaPayload>[]
          }
          create: {
            args: Prisma.LecturaCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$LecturaPayload>
          }
          createMany: {
            args: Prisma.LecturaCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          delete: {
            args: Prisma.LecturaDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$LecturaPayload>
          }
          update: {
            args: Prisma.LecturaUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$LecturaPayload>
          }
          deleteMany: {
            args: Prisma.LecturaDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.LecturaUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          upsert: {
            args: Prisma.LecturaUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$LecturaPayload>
          }
          aggregate: {
            args: Prisma.LecturaAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateLectura>
          }
          groupBy: {
            args: Prisma.LecturaGroupByArgs<ExtArgs>
            result: $Utils.Optional<LecturaGroupByOutputType>[]
          }
          count: {
            args: Prisma.LecturaCountArgs<ExtArgs>
            result: $Utils.Optional<LecturaCountAggregateOutputType> | number
          }
        }
      }
      ResumenLecturaHoraria: {
        payload: Prisma.$ResumenLecturaHorariaPayload<ExtArgs>
        fields: Prisma.ResumenLecturaHorariaFieldRefs
        operations: {
          findUnique: {
            args: Prisma.ResumenLecturaHorariaFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ResumenLecturaHorariaPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.ResumenLecturaHorariaFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ResumenLecturaHorariaPayload>
          }
          findFirst: {
            args: Prisma.ResumenLecturaHorariaFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ResumenLecturaHorariaPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.ResumenLecturaHorariaFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ResumenLecturaHorariaPayload>
          }
          findMany: {
            args: Prisma.ResumenLecturaHorariaFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ResumenLecturaHorariaPayload>[]
          }
          create: {
            args: Prisma.ResumenLecturaHorariaCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ResumenLecturaHorariaPayload>
          }
          createMany: {
            args: Prisma.ResumenLecturaHorariaCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          delete: {
            args: Prisma.ResumenLecturaHorariaDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ResumenLecturaHorariaPayload>
          }
          update: {
            args: Prisma.ResumenLecturaHorariaUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ResumenLecturaHorariaPayload>
          }
          deleteMany: {
            args: Prisma.ResumenLecturaHorariaDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.ResumenLecturaHorariaUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          upsert: {
            args: Prisma.ResumenLecturaHorariaUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ResumenLecturaHorariaPayload>
          }
          aggregate: {
            args: Prisma.ResumenLecturaHorariaAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateResumenLecturaHoraria>
          }
          groupBy: {
            args: Prisma.ResumenLecturaHorariaGroupByArgs<ExtArgs>
            result: $Utils.Optional<ResumenLecturaHorariaGroupByOutputType>[]
          }
          count: {
            args: Prisma.ResumenLecturaHorariaCountArgs<ExtArgs>
            result: $Utils.Optional<ResumenLecturaHorariaCountAggregateOutputType> | number
          }
        }
      }
      Promedio15min: {
        payload: Prisma.$Promedio15minPayload<ExtArgs>
        fields: Prisma.Promedio15minFieldRefs
        operations: {
          findUnique: {
            args: Prisma.Promedio15minFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$Promedio15minPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.Promedio15minFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$Promedio15minPayload>
          }
          findFirst: {
            args: Prisma.Promedio15minFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$Promedio15minPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.Promedio15minFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$Promedio15minPayload>
          }
          findMany: {
            args: Prisma.Promedio15minFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$Promedio15minPayload>[]
          }
          create: {
            args: Prisma.Promedio15minCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$Promedio15minPayload>
          }
          createMany: {
            args: Prisma.Promedio15minCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          delete: {
            args: Prisma.Promedio15minDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$Promedio15minPayload>
          }
          update: {
            args: Prisma.Promedio15minUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$Promedio15minPayload>
          }
          deleteMany: {
            args: Prisma.Promedio15minDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.Promedio15minUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          upsert: {
            args: Prisma.Promedio15minUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$Promedio15minPayload>
          }
          aggregate: {
            args: Prisma.Promedio15minAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregatePromedio15min>
          }
          groupBy: {
            args: Prisma.Promedio15minGroupByArgs<ExtArgs>
            result: $Utils.Optional<Promedio15minGroupByOutputType>[]
          }
          count: {
            args: Prisma.Promedio15minCountArgs<ExtArgs>
            result: $Utils.Optional<Promedio15minCountAggregateOutputType> | number
          }
        }
      }
      Estado: {
        payload: Prisma.$EstadoPayload<ExtArgs>
        fields: Prisma.EstadoFieldRefs
        operations: {
          findUnique: {
            args: Prisma.EstadoFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$EstadoPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.EstadoFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$EstadoPayload>
          }
          findFirst: {
            args: Prisma.EstadoFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$EstadoPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.EstadoFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$EstadoPayload>
          }
          findMany: {
            args: Prisma.EstadoFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$EstadoPayload>[]
          }
          create: {
            args: Prisma.EstadoCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$EstadoPayload>
          }
          createMany: {
            args: Prisma.EstadoCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          delete: {
            args: Prisma.EstadoDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$EstadoPayload>
          }
          update: {
            args: Prisma.EstadoUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$EstadoPayload>
          }
          deleteMany: {
            args: Prisma.EstadoDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.EstadoUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          upsert: {
            args: Prisma.EstadoUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$EstadoPayload>
          }
          aggregate: {
            args: Prisma.EstadoAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateEstado>
          }
          groupBy: {
            args: Prisma.EstadoGroupByArgs<ExtArgs>
            result: $Utils.Optional<EstadoGroupByOutputType>[]
          }
          count: {
            args: Prisma.EstadoCountArgs<ExtArgs>
            result: $Utils.Optional<EstadoCountAggregateOutputType> | number
          }
        }
      }
      Municipio: {
        payload: Prisma.$MunicipioPayload<ExtArgs>
        fields: Prisma.MunicipioFieldRefs
        operations: {
          findUnique: {
            args: Prisma.MunicipioFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$MunicipioPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.MunicipioFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$MunicipioPayload>
          }
          findFirst: {
            args: Prisma.MunicipioFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$MunicipioPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.MunicipioFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$MunicipioPayload>
          }
          findMany: {
            args: Prisma.MunicipioFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$MunicipioPayload>[]
          }
          create: {
            args: Prisma.MunicipioCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$MunicipioPayload>
          }
          createMany: {
            args: Prisma.MunicipioCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          delete: {
            args: Prisma.MunicipioDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$MunicipioPayload>
          }
          update: {
            args: Prisma.MunicipioUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$MunicipioPayload>
          }
          deleteMany: {
            args: Prisma.MunicipioDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.MunicipioUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          upsert: {
            args: Prisma.MunicipioUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$MunicipioPayload>
          }
          aggregate: {
            args: Prisma.MunicipioAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateMunicipio>
          }
          groupBy: {
            args: Prisma.MunicipioGroupByArgs<ExtArgs>
            result: $Utils.Optional<MunicipioGroupByOutputType>[]
          }
          count: {
            args: Prisma.MunicipioCountArgs<ExtArgs>
            result: $Utils.Optional<MunicipioCountAggregateOutputType> | number
          }
        }
      }
      CodigoPostal: {
        payload: Prisma.$CodigoPostalPayload<ExtArgs>
        fields: Prisma.CodigoPostalFieldRefs
        operations: {
          findUnique: {
            args: Prisma.CodigoPostalFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CodigoPostalPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.CodigoPostalFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CodigoPostalPayload>
          }
          findFirst: {
            args: Prisma.CodigoPostalFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CodigoPostalPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.CodigoPostalFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CodigoPostalPayload>
          }
          findMany: {
            args: Prisma.CodigoPostalFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CodigoPostalPayload>[]
          }
          create: {
            args: Prisma.CodigoPostalCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CodigoPostalPayload>
          }
          createMany: {
            args: Prisma.CodigoPostalCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          delete: {
            args: Prisma.CodigoPostalDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CodigoPostalPayload>
          }
          update: {
            args: Prisma.CodigoPostalUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CodigoPostalPayload>
          }
          deleteMany: {
            args: Prisma.CodigoPostalDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.CodigoPostalUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          upsert: {
            args: Prisma.CodigoPostalUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CodigoPostalPayload>
          }
          aggregate: {
            args: Prisma.CodigoPostalAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateCodigoPostal>
          }
          groupBy: {
            args: Prisma.CodigoPostalGroupByArgs<ExtArgs>
            result: $Utils.Optional<CodigoPostalGroupByOutputType>[]
          }
          count: {
            args: Prisma.CodigoPostalCountArgs<ExtArgs>
            result: $Utils.Optional<CodigoPostalCountAggregateOutputType> | number
          }
        }
      }
      Colonia: {
        payload: Prisma.$ColoniaPayload<ExtArgs>
        fields: Prisma.ColoniaFieldRefs
        operations: {
          findUnique: {
            args: Prisma.ColoniaFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ColoniaPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.ColoniaFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ColoniaPayload>
          }
          findFirst: {
            args: Prisma.ColoniaFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ColoniaPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.ColoniaFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ColoniaPayload>
          }
          findMany: {
            args: Prisma.ColoniaFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ColoniaPayload>[]
          }
          create: {
            args: Prisma.ColoniaCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ColoniaPayload>
          }
          createMany: {
            args: Prisma.ColoniaCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          delete: {
            args: Prisma.ColoniaDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ColoniaPayload>
          }
          update: {
            args: Prisma.ColoniaUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ColoniaPayload>
          }
          deleteMany: {
            args: Prisma.ColoniaDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.ColoniaUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          upsert: {
            args: Prisma.ColoniaUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ColoniaPayload>
          }
          aggregate: {
            args: Prisma.ColoniaAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateColonia>
          }
          groupBy: {
            args: Prisma.ColoniaGroupByArgs<ExtArgs>
            result: $Utils.Optional<ColoniaGroupByOutputType>[]
          }
          count: {
            args: Prisma.ColoniaCountArgs<ExtArgs>
            result: $Utils.Optional<ColoniaCountAggregateOutputType> | number
          }
        }
      }
      Usuario: {
        payload: Prisma.$UsuarioPayload<ExtArgs>
        fields: Prisma.UsuarioFieldRefs
        operations: {
          findUnique: {
            args: Prisma.UsuarioFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UsuarioPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.UsuarioFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UsuarioPayload>
          }
          findFirst: {
            args: Prisma.UsuarioFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UsuarioPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.UsuarioFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UsuarioPayload>
          }
          findMany: {
            args: Prisma.UsuarioFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UsuarioPayload>[]
          }
          create: {
            args: Prisma.UsuarioCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UsuarioPayload>
          }
          createMany: {
            args: Prisma.UsuarioCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          delete: {
            args: Prisma.UsuarioDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UsuarioPayload>
          }
          update: {
            args: Prisma.UsuarioUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UsuarioPayload>
          }
          deleteMany: {
            args: Prisma.UsuarioDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.UsuarioUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          upsert: {
            args: Prisma.UsuarioUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UsuarioPayload>
          }
          aggregate: {
            args: Prisma.UsuarioAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateUsuario>
          }
          groupBy: {
            args: Prisma.UsuarioGroupByArgs<ExtArgs>
            result: $Utils.Optional<UsuarioGroupByOutputType>[]
          }
          count: {
            args: Prisma.UsuarioCountArgs<ExtArgs>
            result: $Utils.Optional<UsuarioCountAggregateOutputType> | number
          }
        }
      }
      TipoRol: {
        payload: Prisma.$TipoRolPayload<ExtArgs>
        fields: Prisma.TipoRolFieldRefs
        operations: {
          findUnique: {
            args: Prisma.TipoRolFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$TipoRolPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.TipoRolFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$TipoRolPayload>
          }
          findFirst: {
            args: Prisma.TipoRolFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$TipoRolPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.TipoRolFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$TipoRolPayload>
          }
          findMany: {
            args: Prisma.TipoRolFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$TipoRolPayload>[]
          }
          create: {
            args: Prisma.TipoRolCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$TipoRolPayload>
          }
          createMany: {
            args: Prisma.TipoRolCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          delete: {
            args: Prisma.TipoRolDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$TipoRolPayload>
          }
          update: {
            args: Prisma.TipoRolUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$TipoRolPayload>
          }
          deleteMany: {
            args: Prisma.TipoRolDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.TipoRolUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          upsert: {
            args: Prisma.TipoRolUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$TipoRolPayload>
          }
          aggregate: {
            args: Prisma.TipoRolAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateTipoRol>
          }
          groupBy: {
            args: Prisma.TipoRolGroupByArgs<ExtArgs>
            result: $Utils.Optional<TipoRolGroupByOutputType>[]
          }
          count: {
            args: Prisma.TipoRolCountArgs<ExtArgs>
            result: $Utils.Optional<TipoRolCountAggregateOutputType> | number
          }
        }
      }
      Alerta: {
        payload: Prisma.$AlertaPayload<ExtArgs>
        fields: Prisma.AlertaFieldRefs
        operations: {
          findUnique: {
            args: Prisma.AlertaFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AlertaPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.AlertaFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AlertaPayload>
          }
          findFirst: {
            args: Prisma.AlertaFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AlertaPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.AlertaFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AlertaPayload>
          }
          findMany: {
            args: Prisma.AlertaFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AlertaPayload>[]
          }
          create: {
            args: Prisma.AlertaCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AlertaPayload>
          }
          createMany: {
            args: Prisma.AlertaCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          delete: {
            args: Prisma.AlertaDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AlertaPayload>
          }
          update: {
            args: Prisma.AlertaUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AlertaPayload>
          }
          deleteMany: {
            args: Prisma.AlertaDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.AlertaUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          upsert: {
            args: Prisma.AlertaUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AlertaPayload>
          }
          aggregate: {
            args: Prisma.AlertaAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateAlerta>
          }
          groupBy: {
            args: Prisma.AlertaGroupByArgs<ExtArgs>
            result: $Utils.Optional<AlertaGroupByOutputType>[]
          }
          count: {
            args: Prisma.AlertaCountArgs<ExtArgs>
            result: $Utils.Optional<AlertaCountAggregateOutputType> | number
          }
        }
      }
      Parametro: {
        payload: Prisma.$ParametroPayload<ExtArgs>
        fields: Prisma.ParametroFieldRefs
        operations: {
          findUnique: {
            args: Prisma.ParametroFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ParametroPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.ParametroFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ParametroPayload>
          }
          findFirst: {
            args: Prisma.ParametroFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ParametroPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.ParametroFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ParametroPayload>
          }
          findMany: {
            args: Prisma.ParametroFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ParametroPayload>[]
          }
          create: {
            args: Prisma.ParametroCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ParametroPayload>
          }
          createMany: {
            args: Prisma.ParametroCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          delete: {
            args: Prisma.ParametroDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ParametroPayload>
          }
          update: {
            args: Prisma.ParametroUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ParametroPayload>
          }
          deleteMany: {
            args: Prisma.ParametroDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.ParametroUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          upsert: {
            args: Prisma.ParametroUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ParametroPayload>
          }
          aggregate: {
            args: Prisma.ParametroAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateParametro>
          }
          groupBy: {
            args: Prisma.ParametroGroupByArgs<ExtArgs>
            result: $Utils.Optional<ParametroGroupByOutputType>[]
          }
          count: {
            args: Prisma.ParametroCountArgs<ExtArgs>
            result: $Utils.Optional<ParametroCountAggregateOutputType> | number
          }
        }
      }
      CatalogoEspecie: {
        payload: Prisma.$CatalogoEspeciePayload<ExtArgs>
        fields: Prisma.CatalogoEspecieFieldRefs
        operations: {
          findUnique: {
            args: Prisma.CatalogoEspecieFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CatalogoEspeciePayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.CatalogoEspecieFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CatalogoEspeciePayload>
          }
          findFirst: {
            args: Prisma.CatalogoEspecieFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CatalogoEspeciePayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.CatalogoEspecieFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CatalogoEspeciePayload>
          }
          findMany: {
            args: Prisma.CatalogoEspecieFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CatalogoEspeciePayload>[]
          }
          create: {
            args: Prisma.CatalogoEspecieCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CatalogoEspeciePayload>
          }
          createMany: {
            args: Prisma.CatalogoEspecieCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          delete: {
            args: Prisma.CatalogoEspecieDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CatalogoEspeciePayload>
          }
          update: {
            args: Prisma.CatalogoEspecieUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CatalogoEspeciePayload>
          }
          deleteMany: {
            args: Prisma.CatalogoEspecieDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.CatalogoEspecieUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          upsert: {
            args: Prisma.CatalogoEspecieUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CatalogoEspeciePayload>
          }
          aggregate: {
            args: Prisma.CatalogoEspecieAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateCatalogoEspecie>
          }
          groupBy: {
            args: Prisma.CatalogoEspecieGroupByArgs<ExtArgs>
            result: $Utils.Optional<CatalogoEspecieGroupByOutputType>[]
          }
          count: {
            args: Prisma.CatalogoEspecieCountArgs<ExtArgs>
            result: $Utils.Optional<CatalogoEspecieCountAggregateOutputType> | number
          }
        }
      }
      EspecieInstalada: {
        payload: Prisma.$EspecieInstaladaPayload<ExtArgs>
        fields: Prisma.EspecieInstaladaFieldRefs
        operations: {
          findUnique: {
            args: Prisma.EspecieInstaladaFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$EspecieInstaladaPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.EspecieInstaladaFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$EspecieInstaladaPayload>
          }
          findFirst: {
            args: Prisma.EspecieInstaladaFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$EspecieInstaladaPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.EspecieInstaladaFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$EspecieInstaladaPayload>
          }
          findMany: {
            args: Prisma.EspecieInstaladaFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$EspecieInstaladaPayload>[]
          }
          create: {
            args: Prisma.EspecieInstaladaCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$EspecieInstaladaPayload>
          }
          createMany: {
            args: Prisma.EspecieInstaladaCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          delete: {
            args: Prisma.EspecieInstaladaDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$EspecieInstaladaPayload>
          }
          update: {
            args: Prisma.EspecieInstaladaUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$EspecieInstaladaPayload>
          }
          deleteMany: {
            args: Prisma.EspecieInstaladaDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.EspecieInstaladaUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          upsert: {
            args: Prisma.EspecieInstaladaUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$EspecieInstaladaPayload>
          }
          aggregate: {
            args: Prisma.EspecieInstaladaAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateEspecieInstalada>
          }
          groupBy: {
            args: Prisma.EspecieInstaladaGroupByArgs<ExtArgs>
            result: $Utils.Optional<EspecieInstaladaGroupByOutputType>[]
          }
          count: {
            args: Prisma.EspecieInstaladaCountArgs<ExtArgs>
            result: $Utils.Optional<EspecieInstaladaCountAggregateOutputType> | number
          }
        }
      }
      EspecieTracking: {
        payload: Prisma.$EspecieTrackingPayload<ExtArgs>
        fields: Prisma.EspecieTrackingFieldRefs
        operations: {
          findUnique: {
            args: Prisma.EspecieTrackingFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$EspecieTrackingPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.EspecieTrackingFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$EspecieTrackingPayload>
          }
          findFirst: {
            args: Prisma.EspecieTrackingFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$EspecieTrackingPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.EspecieTrackingFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$EspecieTrackingPayload>
          }
          findMany: {
            args: Prisma.EspecieTrackingFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$EspecieTrackingPayload>[]
          }
          create: {
            args: Prisma.EspecieTrackingCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$EspecieTrackingPayload>
          }
          createMany: {
            args: Prisma.EspecieTrackingCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          delete: {
            args: Prisma.EspecieTrackingDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$EspecieTrackingPayload>
          }
          update: {
            args: Prisma.EspecieTrackingUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$EspecieTrackingPayload>
          }
          deleteMany: {
            args: Prisma.EspecieTrackingDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.EspecieTrackingUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          upsert: {
            args: Prisma.EspecieTrackingUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$EspecieTrackingPayload>
          }
          aggregate: {
            args: Prisma.EspecieTrackingAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateEspecieTracking>
          }
          groupBy: {
            args: Prisma.EspecieTrackingGroupByArgs<ExtArgs>
            result: $Utils.Optional<EspecieTrackingGroupByOutputType>[]
          }
          count: {
            args: Prisma.EspecieTrackingCountArgs<ExtArgs>
            result: $Utils.Optional<EspecieTrackingCountAggregateOutputType> | number
          }
        }
      }
      EspecieParametro: {
        payload: Prisma.$EspecieParametroPayload<ExtArgs>
        fields: Prisma.EspecieParametroFieldRefs
        operations: {
          findUnique: {
            args: Prisma.EspecieParametroFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$EspecieParametroPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.EspecieParametroFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$EspecieParametroPayload>
          }
          findFirst: {
            args: Prisma.EspecieParametroFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$EspecieParametroPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.EspecieParametroFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$EspecieParametroPayload>
          }
          findMany: {
            args: Prisma.EspecieParametroFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$EspecieParametroPayload>[]
          }
          create: {
            args: Prisma.EspecieParametroCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$EspecieParametroPayload>
          }
          createMany: {
            args: Prisma.EspecieParametroCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          delete: {
            args: Prisma.EspecieParametroDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$EspecieParametroPayload>
          }
          update: {
            args: Prisma.EspecieParametroUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$EspecieParametroPayload>
          }
          deleteMany: {
            args: Prisma.EspecieParametroDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.EspecieParametroUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          upsert: {
            args: Prisma.EspecieParametroUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$EspecieParametroPayload>
          }
          aggregate: {
            args: Prisma.EspecieParametroAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateEspecieParametro>
          }
          groupBy: {
            args: Prisma.EspecieParametroGroupByArgs<ExtArgs>
            result: $Utils.Optional<EspecieParametroGroupByOutputType>[]
          }
          count: {
            args: Prisma.EspecieParametroCountArgs<ExtArgs>
            result: $Utils.Optional<EspecieParametroCountAggregateOutputType> | number
          }
        }
      }
      Proceso: {
        payload: Prisma.$ProcesoPayload<ExtArgs>
        fields: Prisma.ProcesoFieldRefs
        operations: {
          findUnique: {
            args: Prisma.ProcesoFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ProcesoPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.ProcesoFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ProcesoPayload>
          }
          findFirst: {
            args: Prisma.ProcesoFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ProcesoPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.ProcesoFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ProcesoPayload>
          }
          findMany: {
            args: Prisma.ProcesoFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ProcesoPayload>[]
          }
          create: {
            args: Prisma.ProcesoCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ProcesoPayload>
          }
          createMany: {
            args: Prisma.ProcesoCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          delete: {
            args: Prisma.ProcesoDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ProcesoPayload>
          }
          update: {
            args: Prisma.ProcesoUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ProcesoPayload>
          }
          deleteMany: {
            args: Prisma.ProcesoDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.ProcesoUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          upsert: {
            args: Prisma.ProcesoUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ProcesoPayload>
          }
          aggregate: {
            args: Prisma.ProcesoAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateProceso>
          }
          groupBy: {
            args: Prisma.ProcesoGroupByArgs<ExtArgs>
            result: $Utils.Optional<ProcesoGroupByOutputType>[]
          }
          count: {
            args: Prisma.ProcesoCountArgs<ExtArgs>
            result: $Utils.Optional<ProcesoCountAggregateOutputType> | number
          }
        }
      }
    }
  } & {
    other: {
      payload: any
      operations: {
        $executeRaw: {
          args: [query: TemplateStringsArray | Prisma.Sql, ...values: any[]],
          result: any
        }
        $executeRawUnsafe: {
          args: [query: string, ...values: any[]],
          result: any
        }
        $queryRaw: {
          args: [query: TemplateStringsArray | Prisma.Sql, ...values: any[]],
          result: any
        }
        $queryRawUnsafe: {
          args: [query: string, ...values: any[]],
          result: any
        }
      }
    }
  }
  export const defineExtension: $Extensions.ExtendsHook<"define", Prisma.TypeMapCb, $Extensions.DefaultArgs>
  export type DefaultPrismaClient = PrismaClient
  export type ErrorFormat = 'pretty' | 'colorless' | 'minimal'
  export interface PrismaClientOptions {
    /**
     * Overwrites the datasource url from your schema.prisma file
     */
    datasources?: Datasources
    /**
     * Overwrites the datasource url from your schema.prisma file
     */
    datasourceUrl?: string
    /**
     * @default "colorless"
     */
    errorFormat?: ErrorFormat
    /**
     * @example
     * ```
     * // Defaults to stdout
     * log: ['query', 'info', 'warn', 'error']
     * 
     * // Emit as events
     * log: [
     *   { emit: 'stdout', level: 'query' },
     *   { emit: 'stdout', level: 'info' },
     *   { emit: 'stdout', level: 'warn' }
     *   { emit: 'stdout', level: 'error' }
     * ]
     * ```
     * Read more in our [docs](https://www.prisma.io/docs/reference/tools-and-interfaces/prisma-client/logging#the-log-option).
     */
    log?: (LogLevel | LogDefinition)[]
    /**
     * The default values for transactionOptions
     * maxWait ?= 2000
     * timeout ?= 5000
     */
    transactionOptions?: {
      maxWait?: number
      timeout?: number
      isolationLevel?: Prisma.TransactionIsolationLevel
    }
  }


  /* Types for Logging */
  export type LogLevel = 'info' | 'query' | 'warn' | 'error'
  export type LogDefinition = {
    level: LogLevel
    emit: 'stdout' | 'event'
  }

  export type GetLogType<T extends LogLevel | LogDefinition> = T extends LogDefinition ? T['emit'] extends 'event' ? T['level'] : never : never
  export type GetEvents<T extends any> = T extends Array<LogLevel | LogDefinition> ?
    GetLogType<T[0]> | GetLogType<T[1]> | GetLogType<T[2]> | GetLogType<T[3]>
    : never

  export type QueryEvent = {
    timestamp: Date
    query: string
    params: string
    duration: number
    target: string
  }

  export type LogEvent = {
    timestamp: Date
    message: string
    target: string
  }
  /* End Types for Logging */


  export type PrismaAction =
    | 'findUnique'
    | 'findUniqueOrThrow'
    | 'findMany'
    | 'findFirst'
    | 'findFirstOrThrow'
    | 'create'
    | 'createMany'
    | 'createManyAndReturn'
    | 'update'
    | 'updateMany'
    | 'upsert'
    | 'delete'
    | 'deleteMany'
    | 'executeRaw'
    | 'queryRaw'
    | 'aggregate'
    | 'count'
    | 'runCommandRaw'
    | 'findRaw'
    | 'groupBy'

  /**
   * These options are being passed into the middleware as "params"
   */
  export type MiddlewareParams = {
    model?: ModelName
    action: PrismaAction
    args: any
    dataPath: string[]
    runInTransaction: boolean
  }

  /**
   * The `T` type makes sure, that the `return proceed` is not forgotten in the middleware implementation
   */
  export type Middleware<T = any> = (
    params: MiddlewareParams,
    next: (params: MiddlewareParams) => $Utils.JsPromise<T>,
  ) => $Utils.JsPromise<T>

  // tested in getLogLevel.test.ts
  export function getLogLevel(log: Array<LogLevel | LogDefinition>): LogLevel | undefined;

  /**
   * `PrismaClient` proxy available in interactive transactions.
   */
  export type TransactionClient = Omit<Prisma.DefaultPrismaClient, runtime.ITXClientDenyList>

  export type Datasource = {
    url?: string
  }

  /**
   * Count Types
   */


  /**
   * Count Type OrganizacionCountOutputType
   */

  export type OrganizacionCountOutputType = {
    sucursales: number
  }

  export type OrganizacionCountOutputTypeSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    sucursales?: boolean | OrganizacionCountOutputTypeCountSucursalesArgs
  }

  // Custom InputTypes
  /**
   * OrganizacionCountOutputType without action
   */
  export type OrganizacionCountOutputTypeDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the OrganizacionCountOutputType
     */
    select?: OrganizacionCountOutputTypeSelect<ExtArgs> | null
  }

  /**
   * OrganizacionCountOutputType without action
   */
  export type OrganizacionCountOutputTypeCountSucursalesArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: OrganizacionSucursalWhereInput
  }


  /**
   * Count Type OrganizacionSucursalCountOutputType
   */

  export type OrganizacionSucursalCountOutputType = {
    instalaciones: number
  }

  export type OrganizacionSucursalCountOutputTypeSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    instalaciones?: boolean | OrganizacionSucursalCountOutputTypeCountInstalacionesArgs
  }

  // Custom InputTypes
  /**
   * OrganizacionSucursalCountOutputType without action
   */
  export type OrganizacionSucursalCountOutputTypeDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the OrganizacionSucursalCountOutputType
     */
    select?: OrganizacionSucursalCountOutputTypeSelect<ExtArgs> | null
  }

  /**
   * OrganizacionSucursalCountOutputType without action
   */
  export type OrganizacionSucursalCountOutputTypeCountInstalacionesArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: InstalacionWhereInput
  }


  /**
   * Count Type InstalacionCountOutputType
   */

  export type InstalacionCountOutputType = {
    sensores: number
  }

  export type InstalacionCountOutputTypeSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    sensores?: boolean | InstalacionCountOutputTypeCountSensoresArgs
  }

  // Custom InputTypes
  /**
   * InstalacionCountOutputType without action
   */
  export type InstalacionCountOutputTypeDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the InstalacionCountOutputType
     */
    select?: InstalacionCountOutputTypeSelect<ExtArgs> | null
  }

  /**
   * InstalacionCountOutputType without action
   */
  export type InstalacionCountOutputTypeCountSensoresArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: SensorInstaladoWhereInput
  }


  /**
   * Count Type CatalogoSensorCountOutputType
   */

  export type CatalogoSensorCountOutputType = {
    sensoresInstalados: number
  }

  export type CatalogoSensorCountOutputTypeSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    sensoresInstalados?: boolean | CatalogoSensorCountOutputTypeCountSensoresInstaladosArgs
  }

  // Custom InputTypes
  /**
   * CatalogoSensorCountOutputType without action
   */
  export type CatalogoSensorCountOutputTypeDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the CatalogoSensorCountOutputType
     */
    select?: CatalogoSensorCountOutputTypeSelect<ExtArgs> | null
  }

  /**
   * CatalogoSensorCountOutputType without action
   */
  export type CatalogoSensorCountOutputTypeCountSensoresInstaladosArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: SensorInstaladoWhereInput
  }


  /**
   * Count Type SensorInstaladoCountOutputType
   */

  export type SensorInstaladoCountOutputType = {
    lecturas: number
  }

  export type SensorInstaladoCountOutputTypeSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    lecturas?: boolean | SensorInstaladoCountOutputTypeCountLecturasArgs
  }

  // Custom InputTypes
  /**
   * SensorInstaladoCountOutputType without action
   */
  export type SensorInstaladoCountOutputTypeDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the SensorInstaladoCountOutputType
     */
    select?: SensorInstaladoCountOutputTypeSelect<ExtArgs> | null
  }

  /**
   * SensorInstaladoCountOutputType without action
   */
  export type SensorInstaladoCountOutputTypeCountLecturasArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: LecturaWhereInput
  }


  /**
   * Count Type EstadoCountOutputType
   */

  export type EstadoCountOutputType = {
    municipios: number
  }

  export type EstadoCountOutputTypeSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    municipios?: boolean | EstadoCountOutputTypeCountMunicipiosArgs
  }

  // Custom InputTypes
  /**
   * EstadoCountOutputType without action
   */
  export type EstadoCountOutputTypeDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the EstadoCountOutputType
     */
    select?: EstadoCountOutputTypeSelect<ExtArgs> | null
  }

  /**
   * EstadoCountOutputType without action
   */
  export type EstadoCountOutputTypeCountMunicipiosArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: MunicipioWhereInput
  }


  /**
   * Count Type MunicipioCountOutputType
   */

  export type MunicipioCountOutputType = {
    codigosPostales: number
  }

  export type MunicipioCountOutputTypeSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    codigosPostales?: boolean | MunicipioCountOutputTypeCountCodigosPostalesArgs
  }

  // Custom InputTypes
  /**
   * MunicipioCountOutputType without action
   */
  export type MunicipioCountOutputTypeDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the MunicipioCountOutputType
     */
    select?: MunicipioCountOutputTypeSelect<ExtArgs> | null
  }

  /**
   * MunicipioCountOutputType without action
   */
  export type MunicipioCountOutputTypeCountCodigosPostalesArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: CodigoPostalWhereInput
  }


  /**
   * Count Type CodigoPostalCountOutputType
   */

  export type CodigoPostalCountOutputType = {
    colonias: number
  }

  export type CodigoPostalCountOutputTypeSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    colonias?: boolean | CodigoPostalCountOutputTypeCountColoniasArgs
  }

  // Custom InputTypes
  /**
   * CodigoPostalCountOutputType without action
   */
  export type CodigoPostalCountOutputTypeDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the CodigoPostalCountOutputType
     */
    select?: CodigoPostalCountOutputTypeSelect<ExtArgs> | null
  }

  /**
   * CodigoPostalCountOutputType without action
   */
  export type CodigoPostalCountOutputTypeCountColoniasArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: ColoniaWhereInput
  }


  /**
   * Count Type TipoRolCountOutputType
   */

  export type TipoRolCountOutputType = {
    usuarios: number
  }

  export type TipoRolCountOutputTypeSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    usuarios?: boolean | TipoRolCountOutputTypeCountUsuariosArgs
  }

  // Custom InputTypes
  /**
   * TipoRolCountOutputType without action
   */
  export type TipoRolCountOutputTypeDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the TipoRolCountOutputType
     */
    select?: TipoRolCountOutputTypeSelect<ExtArgs> | null
  }

  /**
   * TipoRolCountOutputType without action
   */
  export type TipoRolCountOutputTypeCountUsuariosArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: UsuarioWhereInput
  }


  /**
   * Count Type ParametroCountOutputType
   */

  export type ParametroCountOutputType = {
    especieParametros: number
  }

  export type ParametroCountOutputTypeSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    especieParametros?: boolean | ParametroCountOutputTypeCountEspecieParametrosArgs
  }

  // Custom InputTypes
  /**
   * ParametroCountOutputType without action
   */
  export type ParametroCountOutputTypeDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ParametroCountOutputType
     */
    select?: ParametroCountOutputTypeSelect<ExtArgs> | null
  }

  /**
   * ParametroCountOutputType without action
   */
  export type ParametroCountOutputTypeCountEspecieParametrosArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: EspecieParametroWhereInput
  }


  /**
   * Count Type CatalogoEspecieCountOutputType
   */

  export type CatalogoEspecieCountOutputType = {
    especiesInstaladas: number
  }

  export type CatalogoEspecieCountOutputTypeSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    especiesInstaladas?: boolean | CatalogoEspecieCountOutputTypeCountEspeciesInstaladasArgs
  }

  // Custom InputTypes
  /**
   * CatalogoEspecieCountOutputType without action
   */
  export type CatalogoEspecieCountOutputTypeDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the CatalogoEspecieCountOutputType
     */
    select?: CatalogoEspecieCountOutputTypeSelect<ExtArgs> | null
  }

  /**
   * CatalogoEspecieCountOutputType without action
   */
  export type CatalogoEspecieCountOutputTypeCountEspeciesInstaladasArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: EspecieInstaladaWhereInput
  }


  /**
   * Count Type EspecieInstaladaCountOutputType
   */

  export type EspecieInstaladaCountOutputType = {
    trackings: number
  }

  export type EspecieInstaladaCountOutputTypeSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    trackings?: boolean | EspecieInstaladaCountOutputTypeCountTrackingsArgs
  }

  // Custom InputTypes
  /**
   * EspecieInstaladaCountOutputType without action
   */
  export type EspecieInstaladaCountOutputTypeDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the EspecieInstaladaCountOutputType
     */
    select?: EspecieInstaladaCountOutputTypeSelect<ExtArgs> | null
  }

  /**
   * EspecieInstaladaCountOutputType without action
   */
  export type EspecieInstaladaCountOutputTypeCountTrackingsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: EspecieTrackingWhereInput
  }


  /**
   * Models
   */

  /**
   * Model Organizacion
   */

  export type AggregateOrganizacion = {
    _count: OrganizacionCountAggregateOutputType | null
    _avg: OrganizacionAvgAggregateOutputType | null
    _sum: OrganizacionSumAggregateOutputType | null
    _min: OrganizacionMinAggregateOutputType | null
    _max: OrganizacionMaxAggregateOutputType | null
  }

  export type OrganizacionAvgAggregateOutputType = {
    id_organizacion: number | null
  }

  export type OrganizacionSumAggregateOutputType = {
    id_organizacion: number | null
  }

  export type OrganizacionMinAggregateOutputType = {
    id_organizacion: number | null
    nombre: string | null
    estado: string | null
    fecha_creacion: Date | null
  }

  export type OrganizacionMaxAggregateOutputType = {
    id_organizacion: number | null
    nombre: string | null
    estado: string | null
    fecha_creacion: Date | null
  }

  export type OrganizacionCountAggregateOutputType = {
    id_organizacion: number
    nombre: number
    estado: number
    fecha_creacion: number
    _all: number
  }


  export type OrganizacionAvgAggregateInputType = {
    id_organizacion?: true
  }

  export type OrganizacionSumAggregateInputType = {
    id_organizacion?: true
  }

  export type OrganizacionMinAggregateInputType = {
    id_organizacion?: true
    nombre?: true
    estado?: true
    fecha_creacion?: true
  }

  export type OrganizacionMaxAggregateInputType = {
    id_organizacion?: true
    nombre?: true
    estado?: true
    fecha_creacion?: true
  }

  export type OrganizacionCountAggregateInputType = {
    id_organizacion?: true
    nombre?: true
    estado?: true
    fecha_creacion?: true
    _all?: true
  }

  export type OrganizacionAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Organizacion to aggregate.
     */
    where?: OrganizacionWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Organizacions to fetch.
     */
    orderBy?: OrganizacionOrderByWithRelationInput | OrganizacionOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: OrganizacionWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Organizacions from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Organizacions.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned Organizacions
    **/
    _count?: true | OrganizacionCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: OrganizacionAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: OrganizacionSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: OrganizacionMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: OrganizacionMaxAggregateInputType
  }

  export type GetOrganizacionAggregateType<T extends OrganizacionAggregateArgs> = {
        [P in keyof T & keyof AggregateOrganizacion]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateOrganizacion[P]>
      : GetScalarType<T[P], AggregateOrganizacion[P]>
  }




  export type OrganizacionGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: OrganizacionWhereInput
    orderBy?: OrganizacionOrderByWithAggregationInput | OrganizacionOrderByWithAggregationInput[]
    by: OrganizacionScalarFieldEnum[] | OrganizacionScalarFieldEnum
    having?: OrganizacionScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: OrganizacionCountAggregateInputType | true
    _avg?: OrganizacionAvgAggregateInputType
    _sum?: OrganizacionSumAggregateInputType
    _min?: OrganizacionMinAggregateInputType
    _max?: OrganizacionMaxAggregateInputType
  }

  export type OrganizacionGroupByOutputType = {
    id_organizacion: number
    nombre: string
    estado: string
    fecha_creacion: Date
    _count: OrganizacionCountAggregateOutputType | null
    _avg: OrganizacionAvgAggregateOutputType | null
    _sum: OrganizacionSumAggregateOutputType | null
    _min: OrganizacionMinAggregateOutputType | null
    _max: OrganizacionMaxAggregateOutputType | null
  }

  type GetOrganizacionGroupByPayload<T extends OrganizacionGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<OrganizacionGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof OrganizacionGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], OrganizacionGroupByOutputType[P]>
            : GetScalarType<T[P], OrganizacionGroupByOutputType[P]>
        }
      >
    >


  export type OrganizacionSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id_organizacion?: boolean
    nombre?: boolean
    estado?: boolean
    fecha_creacion?: boolean
    sucursales?: boolean | Organizacion$sucursalesArgs<ExtArgs>
    _count?: boolean | OrganizacionCountOutputTypeDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["organizacion"]>


  export type OrganizacionSelectScalar = {
    id_organizacion?: boolean
    nombre?: boolean
    estado?: boolean
    fecha_creacion?: boolean
  }

  export type OrganizacionInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    sucursales?: boolean | Organizacion$sucursalesArgs<ExtArgs>
    _count?: boolean | OrganizacionCountOutputTypeDefaultArgs<ExtArgs>
  }

  export type $OrganizacionPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "Organizacion"
    objects: {
      sucursales: Prisma.$OrganizacionSucursalPayload<ExtArgs>[]
    }
    scalars: $Extensions.GetPayloadResult<{
      id_organizacion: number
      nombre: string
      estado: string
      fecha_creacion: Date
    }, ExtArgs["result"]["organizacion"]>
    composites: {}
  }

  type OrganizacionGetPayload<S extends boolean | null | undefined | OrganizacionDefaultArgs> = $Result.GetResult<Prisma.$OrganizacionPayload, S>

  type OrganizacionCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = 
    Omit<OrganizacionFindManyArgs, 'select' | 'include' | 'distinct'> & {
      select?: OrganizacionCountAggregateInputType | true
    }

  export interface OrganizacionDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['Organizacion'], meta: { name: 'Organizacion' } }
    /**
     * Find zero or one Organizacion that matches the filter.
     * @param {OrganizacionFindUniqueArgs} args - Arguments to find a Organizacion
     * @example
     * // Get one Organizacion
     * const organizacion = await prisma.organizacion.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends OrganizacionFindUniqueArgs>(args: SelectSubset<T, OrganizacionFindUniqueArgs<ExtArgs>>): Prisma__OrganizacionClient<$Result.GetResult<Prisma.$OrganizacionPayload<ExtArgs>, T, "findUnique"> | null, null, ExtArgs>

    /**
     * Find one Organizacion that matches the filter or throw an error with `error.code='P2025'` 
     * if no matches were found.
     * @param {OrganizacionFindUniqueOrThrowArgs} args - Arguments to find a Organizacion
     * @example
     * // Get one Organizacion
     * const organizacion = await prisma.organizacion.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends OrganizacionFindUniqueOrThrowArgs>(args: SelectSubset<T, OrganizacionFindUniqueOrThrowArgs<ExtArgs>>): Prisma__OrganizacionClient<$Result.GetResult<Prisma.$OrganizacionPayload<ExtArgs>, T, "findUniqueOrThrow">, never, ExtArgs>

    /**
     * Find the first Organizacion that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {OrganizacionFindFirstArgs} args - Arguments to find a Organizacion
     * @example
     * // Get one Organizacion
     * const organizacion = await prisma.organizacion.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends OrganizacionFindFirstArgs>(args?: SelectSubset<T, OrganizacionFindFirstArgs<ExtArgs>>): Prisma__OrganizacionClient<$Result.GetResult<Prisma.$OrganizacionPayload<ExtArgs>, T, "findFirst"> | null, null, ExtArgs>

    /**
     * Find the first Organizacion that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {OrganizacionFindFirstOrThrowArgs} args - Arguments to find a Organizacion
     * @example
     * // Get one Organizacion
     * const organizacion = await prisma.organizacion.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends OrganizacionFindFirstOrThrowArgs>(args?: SelectSubset<T, OrganizacionFindFirstOrThrowArgs<ExtArgs>>): Prisma__OrganizacionClient<$Result.GetResult<Prisma.$OrganizacionPayload<ExtArgs>, T, "findFirstOrThrow">, never, ExtArgs>

    /**
     * Find zero or more Organizacions that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {OrganizacionFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Organizacions
     * const organizacions = await prisma.organizacion.findMany()
     * 
     * // Get first 10 Organizacions
     * const organizacions = await prisma.organizacion.findMany({ take: 10 })
     * 
     * // Only select the `id_organizacion`
     * const organizacionWithId_organizacionOnly = await prisma.organizacion.findMany({ select: { id_organizacion: true } })
     * 
     */
    findMany<T extends OrganizacionFindManyArgs>(args?: SelectSubset<T, OrganizacionFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$OrganizacionPayload<ExtArgs>, T, "findMany">>

    /**
     * Create a Organizacion.
     * @param {OrganizacionCreateArgs} args - Arguments to create a Organizacion.
     * @example
     * // Create one Organizacion
     * const Organizacion = await prisma.organizacion.create({
     *   data: {
     *     // ... data to create a Organizacion
     *   }
     * })
     * 
     */
    create<T extends OrganizacionCreateArgs>(args: SelectSubset<T, OrganizacionCreateArgs<ExtArgs>>): Prisma__OrganizacionClient<$Result.GetResult<Prisma.$OrganizacionPayload<ExtArgs>, T, "create">, never, ExtArgs>

    /**
     * Create many Organizacions.
     * @param {OrganizacionCreateManyArgs} args - Arguments to create many Organizacions.
     * @example
     * // Create many Organizacions
     * const organizacion = await prisma.organizacion.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends OrganizacionCreateManyArgs>(args?: SelectSubset<T, OrganizacionCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Delete a Organizacion.
     * @param {OrganizacionDeleteArgs} args - Arguments to delete one Organizacion.
     * @example
     * // Delete one Organizacion
     * const Organizacion = await prisma.organizacion.delete({
     *   where: {
     *     // ... filter to delete one Organizacion
     *   }
     * })
     * 
     */
    delete<T extends OrganizacionDeleteArgs>(args: SelectSubset<T, OrganizacionDeleteArgs<ExtArgs>>): Prisma__OrganizacionClient<$Result.GetResult<Prisma.$OrganizacionPayload<ExtArgs>, T, "delete">, never, ExtArgs>

    /**
     * Update one Organizacion.
     * @param {OrganizacionUpdateArgs} args - Arguments to update one Organizacion.
     * @example
     * // Update one Organizacion
     * const organizacion = await prisma.organizacion.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends OrganizacionUpdateArgs>(args: SelectSubset<T, OrganizacionUpdateArgs<ExtArgs>>): Prisma__OrganizacionClient<$Result.GetResult<Prisma.$OrganizacionPayload<ExtArgs>, T, "update">, never, ExtArgs>

    /**
     * Delete zero or more Organizacions.
     * @param {OrganizacionDeleteManyArgs} args - Arguments to filter Organizacions to delete.
     * @example
     * // Delete a few Organizacions
     * const { count } = await prisma.organizacion.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends OrganizacionDeleteManyArgs>(args?: SelectSubset<T, OrganizacionDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Organizacions.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {OrganizacionUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Organizacions
     * const organizacion = await prisma.organizacion.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends OrganizacionUpdateManyArgs>(args: SelectSubset<T, OrganizacionUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one Organizacion.
     * @param {OrganizacionUpsertArgs} args - Arguments to update or create a Organizacion.
     * @example
     * // Update or create a Organizacion
     * const organizacion = await prisma.organizacion.upsert({
     *   create: {
     *     // ... data to create a Organizacion
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Organizacion we want to update
     *   }
     * })
     */
    upsert<T extends OrganizacionUpsertArgs>(args: SelectSubset<T, OrganizacionUpsertArgs<ExtArgs>>): Prisma__OrganizacionClient<$Result.GetResult<Prisma.$OrganizacionPayload<ExtArgs>, T, "upsert">, never, ExtArgs>


    /**
     * Count the number of Organizacions.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {OrganizacionCountArgs} args - Arguments to filter Organizacions to count.
     * @example
     * // Count the number of Organizacions
     * const count = await prisma.organizacion.count({
     *   where: {
     *     // ... the filter for the Organizacions we want to count
     *   }
     * })
    **/
    count<T extends OrganizacionCountArgs>(
      args?: Subset<T, OrganizacionCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], OrganizacionCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Organizacion.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {OrganizacionAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends OrganizacionAggregateArgs>(args: Subset<T, OrganizacionAggregateArgs>): Prisma.PrismaPromise<GetOrganizacionAggregateType<T>>

    /**
     * Group by Organizacion.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {OrganizacionGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends OrganizacionGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: OrganizacionGroupByArgs['orderBy'] }
        : { orderBy?: OrganizacionGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, OrganizacionGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetOrganizacionGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the Organizacion model
   */
  readonly fields: OrganizacionFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for Organizacion.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__OrganizacionClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    sucursales<T extends Organizacion$sucursalesArgs<ExtArgs> = {}>(args?: Subset<T, Organizacion$sucursalesArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$OrganizacionSucursalPayload<ExtArgs>, T, "findMany"> | Null>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the Organizacion model
   */ 
  interface OrganizacionFieldRefs {
    readonly id_organizacion: FieldRef<"Organizacion", 'Int'>
    readonly nombre: FieldRef<"Organizacion", 'String'>
    readonly estado: FieldRef<"Organizacion", 'String'>
    readonly fecha_creacion: FieldRef<"Organizacion", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * Organizacion findUnique
   */
  export type OrganizacionFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Organizacion
     */
    select?: OrganizacionSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: OrganizacionInclude<ExtArgs> | null
    /**
     * Filter, which Organizacion to fetch.
     */
    where: OrganizacionWhereUniqueInput
  }

  /**
   * Organizacion findUniqueOrThrow
   */
  export type OrganizacionFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Organizacion
     */
    select?: OrganizacionSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: OrganizacionInclude<ExtArgs> | null
    /**
     * Filter, which Organizacion to fetch.
     */
    where: OrganizacionWhereUniqueInput
  }

  /**
   * Organizacion findFirst
   */
  export type OrganizacionFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Organizacion
     */
    select?: OrganizacionSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: OrganizacionInclude<ExtArgs> | null
    /**
     * Filter, which Organizacion to fetch.
     */
    where?: OrganizacionWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Organizacions to fetch.
     */
    orderBy?: OrganizacionOrderByWithRelationInput | OrganizacionOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Organizacions.
     */
    cursor?: OrganizacionWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Organizacions from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Organizacions.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Organizacions.
     */
    distinct?: OrganizacionScalarFieldEnum | OrganizacionScalarFieldEnum[]
  }

  /**
   * Organizacion findFirstOrThrow
   */
  export type OrganizacionFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Organizacion
     */
    select?: OrganizacionSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: OrganizacionInclude<ExtArgs> | null
    /**
     * Filter, which Organizacion to fetch.
     */
    where?: OrganizacionWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Organizacions to fetch.
     */
    orderBy?: OrganizacionOrderByWithRelationInput | OrganizacionOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Organizacions.
     */
    cursor?: OrganizacionWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Organizacions from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Organizacions.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Organizacions.
     */
    distinct?: OrganizacionScalarFieldEnum | OrganizacionScalarFieldEnum[]
  }

  /**
   * Organizacion findMany
   */
  export type OrganizacionFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Organizacion
     */
    select?: OrganizacionSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: OrganizacionInclude<ExtArgs> | null
    /**
     * Filter, which Organizacions to fetch.
     */
    where?: OrganizacionWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Organizacions to fetch.
     */
    orderBy?: OrganizacionOrderByWithRelationInput | OrganizacionOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing Organizacions.
     */
    cursor?: OrganizacionWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Organizacions from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Organizacions.
     */
    skip?: number
    distinct?: OrganizacionScalarFieldEnum | OrganizacionScalarFieldEnum[]
  }

  /**
   * Organizacion create
   */
  export type OrganizacionCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Organizacion
     */
    select?: OrganizacionSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: OrganizacionInclude<ExtArgs> | null
    /**
     * The data needed to create a Organizacion.
     */
    data: XOR<OrganizacionCreateInput, OrganizacionUncheckedCreateInput>
  }

  /**
   * Organizacion createMany
   */
  export type OrganizacionCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many Organizacions.
     */
    data: OrganizacionCreateManyInput | OrganizacionCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * Organizacion update
   */
  export type OrganizacionUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Organizacion
     */
    select?: OrganizacionSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: OrganizacionInclude<ExtArgs> | null
    /**
     * The data needed to update a Organizacion.
     */
    data: XOR<OrganizacionUpdateInput, OrganizacionUncheckedUpdateInput>
    /**
     * Choose, which Organizacion to update.
     */
    where: OrganizacionWhereUniqueInput
  }

  /**
   * Organizacion updateMany
   */
  export type OrganizacionUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update Organizacions.
     */
    data: XOR<OrganizacionUpdateManyMutationInput, OrganizacionUncheckedUpdateManyInput>
    /**
     * Filter which Organizacions to update
     */
    where?: OrganizacionWhereInput
  }

  /**
   * Organizacion upsert
   */
  export type OrganizacionUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Organizacion
     */
    select?: OrganizacionSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: OrganizacionInclude<ExtArgs> | null
    /**
     * The filter to search for the Organizacion to update in case it exists.
     */
    where: OrganizacionWhereUniqueInput
    /**
     * In case the Organizacion found by the `where` argument doesn't exist, create a new Organizacion with this data.
     */
    create: XOR<OrganizacionCreateInput, OrganizacionUncheckedCreateInput>
    /**
     * In case the Organizacion was found with the provided `where` argument, update it with this data.
     */
    update: XOR<OrganizacionUpdateInput, OrganizacionUncheckedUpdateInput>
  }

  /**
   * Organizacion delete
   */
  export type OrganizacionDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Organizacion
     */
    select?: OrganizacionSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: OrganizacionInclude<ExtArgs> | null
    /**
     * Filter which Organizacion to delete.
     */
    where: OrganizacionWhereUniqueInput
  }

  /**
   * Organizacion deleteMany
   */
  export type OrganizacionDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Organizacions to delete
     */
    where?: OrganizacionWhereInput
  }

  /**
   * Organizacion.sucursales
   */
  export type Organizacion$sucursalesArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the OrganizacionSucursal
     */
    select?: OrganizacionSucursalSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: OrganizacionSucursalInclude<ExtArgs> | null
    where?: OrganizacionSucursalWhereInput
    orderBy?: OrganizacionSucursalOrderByWithRelationInput | OrganizacionSucursalOrderByWithRelationInput[]
    cursor?: OrganizacionSucursalWhereUniqueInput
    take?: number
    skip?: number
    distinct?: OrganizacionSucursalScalarFieldEnum | OrganizacionSucursalScalarFieldEnum[]
  }

  /**
   * Organizacion without action
   */
  export type OrganizacionDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Organizacion
     */
    select?: OrganizacionSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: OrganizacionInclude<ExtArgs> | null
  }


  /**
   * Model OrganizacionSucursal
   */

  export type AggregateOrganizacionSucursal = {
    _count: OrganizacionSucursalCountAggregateOutputType | null
    _avg: OrganizacionSucursalAvgAggregateOutputType | null
    _sum: OrganizacionSucursalSumAggregateOutputType | null
    _min: OrganizacionSucursalMinAggregateOutputType | null
    _max: OrganizacionSucursalMaxAggregateOutputType | null
  }

  export type OrganizacionSucursalAvgAggregateOutputType = {
    id_organizacion_sucursal: number | null
    id_organizacion: number | null
  }

  export type OrganizacionSucursalSumAggregateOutputType = {
    id_organizacion_sucursal: number | null
    id_organizacion: number | null
  }

  export type OrganizacionSucursalMinAggregateOutputType = {
    id_organizacion_sucursal: number | null
    id_organizacion: number | null
    nombre_sucursal: string | null
    estado: string | null
    fecha_creacion: Date | null
  }

  export type OrganizacionSucursalMaxAggregateOutputType = {
    id_organizacion_sucursal: number | null
    id_organizacion: number | null
    nombre_sucursal: string | null
    estado: string | null
    fecha_creacion: Date | null
  }

  export type OrganizacionSucursalCountAggregateOutputType = {
    id_organizacion_sucursal: number
    id_organizacion: number
    nombre_sucursal: number
    estado: number
    fecha_creacion: number
    _all: number
  }


  export type OrganizacionSucursalAvgAggregateInputType = {
    id_organizacion_sucursal?: true
    id_organizacion?: true
  }

  export type OrganizacionSucursalSumAggregateInputType = {
    id_organizacion_sucursal?: true
    id_organizacion?: true
  }

  export type OrganizacionSucursalMinAggregateInputType = {
    id_organizacion_sucursal?: true
    id_organizacion?: true
    nombre_sucursal?: true
    estado?: true
    fecha_creacion?: true
  }

  export type OrganizacionSucursalMaxAggregateInputType = {
    id_organizacion_sucursal?: true
    id_organizacion?: true
    nombre_sucursal?: true
    estado?: true
    fecha_creacion?: true
  }

  export type OrganizacionSucursalCountAggregateInputType = {
    id_organizacion_sucursal?: true
    id_organizacion?: true
    nombre_sucursal?: true
    estado?: true
    fecha_creacion?: true
    _all?: true
  }

  export type OrganizacionSucursalAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which OrganizacionSucursal to aggregate.
     */
    where?: OrganizacionSucursalWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of OrganizacionSucursals to fetch.
     */
    orderBy?: OrganizacionSucursalOrderByWithRelationInput | OrganizacionSucursalOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: OrganizacionSucursalWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` OrganizacionSucursals from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` OrganizacionSucursals.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned OrganizacionSucursals
    **/
    _count?: true | OrganizacionSucursalCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: OrganizacionSucursalAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: OrganizacionSucursalSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: OrganizacionSucursalMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: OrganizacionSucursalMaxAggregateInputType
  }

  export type GetOrganizacionSucursalAggregateType<T extends OrganizacionSucursalAggregateArgs> = {
        [P in keyof T & keyof AggregateOrganizacionSucursal]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateOrganizacionSucursal[P]>
      : GetScalarType<T[P], AggregateOrganizacionSucursal[P]>
  }




  export type OrganizacionSucursalGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: OrganizacionSucursalWhereInput
    orderBy?: OrganizacionSucursalOrderByWithAggregationInput | OrganizacionSucursalOrderByWithAggregationInput[]
    by: OrganizacionSucursalScalarFieldEnum[] | OrganizacionSucursalScalarFieldEnum
    having?: OrganizacionSucursalScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: OrganizacionSucursalCountAggregateInputType | true
    _avg?: OrganizacionSucursalAvgAggregateInputType
    _sum?: OrganizacionSucursalSumAggregateInputType
    _min?: OrganizacionSucursalMinAggregateInputType
    _max?: OrganizacionSucursalMaxAggregateInputType
  }

  export type OrganizacionSucursalGroupByOutputType = {
    id_organizacion_sucursal: number
    id_organizacion: number
    nombre_sucursal: string
    estado: string
    fecha_creacion: Date
    _count: OrganizacionSucursalCountAggregateOutputType | null
    _avg: OrganizacionSucursalAvgAggregateOutputType | null
    _sum: OrganizacionSucursalSumAggregateOutputType | null
    _min: OrganizacionSucursalMinAggregateOutputType | null
    _max: OrganizacionSucursalMaxAggregateOutputType | null
  }

  type GetOrganizacionSucursalGroupByPayload<T extends OrganizacionSucursalGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<OrganizacionSucursalGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof OrganizacionSucursalGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], OrganizacionSucursalGroupByOutputType[P]>
            : GetScalarType<T[P], OrganizacionSucursalGroupByOutputType[P]>
        }
      >
    >


  export type OrganizacionSucursalSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id_organizacion_sucursal?: boolean
    id_organizacion?: boolean
    nombre_sucursal?: boolean
    estado?: boolean
    fecha_creacion?: boolean
    organizacion?: boolean | OrganizacionDefaultArgs<ExtArgs>
    instalaciones?: boolean | OrganizacionSucursal$instalacionesArgs<ExtArgs>
    _count?: boolean | OrganizacionSucursalCountOutputTypeDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["organizacionSucursal"]>


  export type OrganizacionSucursalSelectScalar = {
    id_organizacion_sucursal?: boolean
    id_organizacion?: boolean
    nombre_sucursal?: boolean
    estado?: boolean
    fecha_creacion?: boolean
  }

  export type OrganizacionSucursalInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    organizacion?: boolean | OrganizacionDefaultArgs<ExtArgs>
    instalaciones?: boolean | OrganizacionSucursal$instalacionesArgs<ExtArgs>
    _count?: boolean | OrganizacionSucursalCountOutputTypeDefaultArgs<ExtArgs>
  }

  export type $OrganizacionSucursalPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "OrganizacionSucursal"
    objects: {
      organizacion: Prisma.$OrganizacionPayload<ExtArgs>
      instalaciones: Prisma.$InstalacionPayload<ExtArgs>[]
    }
    scalars: $Extensions.GetPayloadResult<{
      id_organizacion_sucursal: number
      id_organizacion: number
      nombre_sucursal: string
      estado: string
      fecha_creacion: Date
    }, ExtArgs["result"]["organizacionSucursal"]>
    composites: {}
  }

  type OrganizacionSucursalGetPayload<S extends boolean | null | undefined | OrganizacionSucursalDefaultArgs> = $Result.GetResult<Prisma.$OrganizacionSucursalPayload, S>

  type OrganizacionSucursalCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = 
    Omit<OrganizacionSucursalFindManyArgs, 'select' | 'include' | 'distinct'> & {
      select?: OrganizacionSucursalCountAggregateInputType | true
    }

  export interface OrganizacionSucursalDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['OrganizacionSucursal'], meta: { name: 'OrganizacionSucursal' } }
    /**
     * Find zero or one OrganizacionSucursal that matches the filter.
     * @param {OrganizacionSucursalFindUniqueArgs} args - Arguments to find a OrganizacionSucursal
     * @example
     * // Get one OrganizacionSucursal
     * const organizacionSucursal = await prisma.organizacionSucursal.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends OrganizacionSucursalFindUniqueArgs>(args: SelectSubset<T, OrganizacionSucursalFindUniqueArgs<ExtArgs>>): Prisma__OrganizacionSucursalClient<$Result.GetResult<Prisma.$OrganizacionSucursalPayload<ExtArgs>, T, "findUnique"> | null, null, ExtArgs>

    /**
     * Find one OrganizacionSucursal that matches the filter or throw an error with `error.code='P2025'` 
     * if no matches were found.
     * @param {OrganizacionSucursalFindUniqueOrThrowArgs} args - Arguments to find a OrganizacionSucursal
     * @example
     * // Get one OrganizacionSucursal
     * const organizacionSucursal = await prisma.organizacionSucursal.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends OrganizacionSucursalFindUniqueOrThrowArgs>(args: SelectSubset<T, OrganizacionSucursalFindUniqueOrThrowArgs<ExtArgs>>): Prisma__OrganizacionSucursalClient<$Result.GetResult<Prisma.$OrganizacionSucursalPayload<ExtArgs>, T, "findUniqueOrThrow">, never, ExtArgs>

    /**
     * Find the first OrganizacionSucursal that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {OrganizacionSucursalFindFirstArgs} args - Arguments to find a OrganizacionSucursal
     * @example
     * // Get one OrganizacionSucursal
     * const organizacionSucursal = await prisma.organizacionSucursal.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends OrganizacionSucursalFindFirstArgs>(args?: SelectSubset<T, OrganizacionSucursalFindFirstArgs<ExtArgs>>): Prisma__OrganizacionSucursalClient<$Result.GetResult<Prisma.$OrganizacionSucursalPayload<ExtArgs>, T, "findFirst"> | null, null, ExtArgs>

    /**
     * Find the first OrganizacionSucursal that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {OrganizacionSucursalFindFirstOrThrowArgs} args - Arguments to find a OrganizacionSucursal
     * @example
     * // Get one OrganizacionSucursal
     * const organizacionSucursal = await prisma.organizacionSucursal.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends OrganizacionSucursalFindFirstOrThrowArgs>(args?: SelectSubset<T, OrganizacionSucursalFindFirstOrThrowArgs<ExtArgs>>): Prisma__OrganizacionSucursalClient<$Result.GetResult<Prisma.$OrganizacionSucursalPayload<ExtArgs>, T, "findFirstOrThrow">, never, ExtArgs>

    /**
     * Find zero or more OrganizacionSucursals that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {OrganizacionSucursalFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all OrganizacionSucursals
     * const organizacionSucursals = await prisma.organizacionSucursal.findMany()
     * 
     * // Get first 10 OrganizacionSucursals
     * const organizacionSucursals = await prisma.organizacionSucursal.findMany({ take: 10 })
     * 
     * // Only select the `id_organizacion_sucursal`
     * const organizacionSucursalWithId_organizacion_sucursalOnly = await prisma.organizacionSucursal.findMany({ select: { id_organizacion_sucursal: true } })
     * 
     */
    findMany<T extends OrganizacionSucursalFindManyArgs>(args?: SelectSubset<T, OrganizacionSucursalFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$OrganizacionSucursalPayload<ExtArgs>, T, "findMany">>

    /**
     * Create a OrganizacionSucursal.
     * @param {OrganizacionSucursalCreateArgs} args - Arguments to create a OrganizacionSucursal.
     * @example
     * // Create one OrganizacionSucursal
     * const OrganizacionSucursal = await prisma.organizacionSucursal.create({
     *   data: {
     *     // ... data to create a OrganizacionSucursal
     *   }
     * })
     * 
     */
    create<T extends OrganizacionSucursalCreateArgs>(args: SelectSubset<T, OrganizacionSucursalCreateArgs<ExtArgs>>): Prisma__OrganizacionSucursalClient<$Result.GetResult<Prisma.$OrganizacionSucursalPayload<ExtArgs>, T, "create">, never, ExtArgs>

    /**
     * Create many OrganizacionSucursals.
     * @param {OrganizacionSucursalCreateManyArgs} args - Arguments to create many OrganizacionSucursals.
     * @example
     * // Create many OrganizacionSucursals
     * const organizacionSucursal = await prisma.organizacionSucursal.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends OrganizacionSucursalCreateManyArgs>(args?: SelectSubset<T, OrganizacionSucursalCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Delete a OrganizacionSucursal.
     * @param {OrganizacionSucursalDeleteArgs} args - Arguments to delete one OrganizacionSucursal.
     * @example
     * // Delete one OrganizacionSucursal
     * const OrganizacionSucursal = await prisma.organizacionSucursal.delete({
     *   where: {
     *     // ... filter to delete one OrganizacionSucursal
     *   }
     * })
     * 
     */
    delete<T extends OrganizacionSucursalDeleteArgs>(args: SelectSubset<T, OrganizacionSucursalDeleteArgs<ExtArgs>>): Prisma__OrganizacionSucursalClient<$Result.GetResult<Prisma.$OrganizacionSucursalPayload<ExtArgs>, T, "delete">, never, ExtArgs>

    /**
     * Update one OrganizacionSucursal.
     * @param {OrganizacionSucursalUpdateArgs} args - Arguments to update one OrganizacionSucursal.
     * @example
     * // Update one OrganizacionSucursal
     * const organizacionSucursal = await prisma.organizacionSucursal.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends OrganizacionSucursalUpdateArgs>(args: SelectSubset<T, OrganizacionSucursalUpdateArgs<ExtArgs>>): Prisma__OrganizacionSucursalClient<$Result.GetResult<Prisma.$OrganizacionSucursalPayload<ExtArgs>, T, "update">, never, ExtArgs>

    /**
     * Delete zero or more OrganizacionSucursals.
     * @param {OrganizacionSucursalDeleteManyArgs} args - Arguments to filter OrganizacionSucursals to delete.
     * @example
     * // Delete a few OrganizacionSucursals
     * const { count } = await prisma.organizacionSucursal.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends OrganizacionSucursalDeleteManyArgs>(args?: SelectSubset<T, OrganizacionSucursalDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more OrganizacionSucursals.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {OrganizacionSucursalUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many OrganizacionSucursals
     * const organizacionSucursal = await prisma.organizacionSucursal.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends OrganizacionSucursalUpdateManyArgs>(args: SelectSubset<T, OrganizacionSucursalUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one OrganizacionSucursal.
     * @param {OrganizacionSucursalUpsertArgs} args - Arguments to update or create a OrganizacionSucursal.
     * @example
     * // Update or create a OrganizacionSucursal
     * const organizacionSucursal = await prisma.organizacionSucursal.upsert({
     *   create: {
     *     // ... data to create a OrganizacionSucursal
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the OrganizacionSucursal we want to update
     *   }
     * })
     */
    upsert<T extends OrganizacionSucursalUpsertArgs>(args: SelectSubset<T, OrganizacionSucursalUpsertArgs<ExtArgs>>): Prisma__OrganizacionSucursalClient<$Result.GetResult<Prisma.$OrganizacionSucursalPayload<ExtArgs>, T, "upsert">, never, ExtArgs>


    /**
     * Count the number of OrganizacionSucursals.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {OrganizacionSucursalCountArgs} args - Arguments to filter OrganizacionSucursals to count.
     * @example
     * // Count the number of OrganizacionSucursals
     * const count = await prisma.organizacionSucursal.count({
     *   where: {
     *     // ... the filter for the OrganizacionSucursals we want to count
     *   }
     * })
    **/
    count<T extends OrganizacionSucursalCountArgs>(
      args?: Subset<T, OrganizacionSucursalCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], OrganizacionSucursalCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a OrganizacionSucursal.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {OrganizacionSucursalAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends OrganizacionSucursalAggregateArgs>(args: Subset<T, OrganizacionSucursalAggregateArgs>): Prisma.PrismaPromise<GetOrganizacionSucursalAggregateType<T>>

    /**
     * Group by OrganizacionSucursal.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {OrganizacionSucursalGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends OrganizacionSucursalGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: OrganizacionSucursalGroupByArgs['orderBy'] }
        : { orderBy?: OrganizacionSucursalGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, OrganizacionSucursalGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetOrganizacionSucursalGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the OrganizacionSucursal model
   */
  readonly fields: OrganizacionSucursalFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for OrganizacionSucursal.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__OrganizacionSucursalClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    organizacion<T extends OrganizacionDefaultArgs<ExtArgs> = {}>(args?: Subset<T, OrganizacionDefaultArgs<ExtArgs>>): Prisma__OrganizacionClient<$Result.GetResult<Prisma.$OrganizacionPayload<ExtArgs>, T, "findUniqueOrThrow"> | Null, Null, ExtArgs>
    instalaciones<T extends OrganizacionSucursal$instalacionesArgs<ExtArgs> = {}>(args?: Subset<T, OrganizacionSucursal$instalacionesArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$InstalacionPayload<ExtArgs>, T, "findMany"> | Null>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the OrganizacionSucursal model
   */ 
  interface OrganizacionSucursalFieldRefs {
    readonly id_organizacion_sucursal: FieldRef<"OrganizacionSucursal", 'Int'>
    readonly id_organizacion: FieldRef<"OrganizacionSucursal", 'Int'>
    readonly nombre_sucursal: FieldRef<"OrganizacionSucursal", 'String'>
    readonly estado: FieldRef<"OrganizacionSucursal", 'String'>
    readonly fecha_creacion: FieldRef<"OrganizacionSucursal", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * OrganizacionSucursal findUnique
   */
  export type OrganizacionSucursalFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the OrganizacionSucursal
     */
    select?: OrganizacionSucursalSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: OrganizacionSucursalInclude<ExtArgs> | null
    /**
     * Filter, which OrganizacionSucursal to fetch.
     */
    where: OrganizacionSucursalWhereUniqueInput
  }

  /**
   * OrganizacionSucursal findUniqueOrThrow
   */
  export type OrganizacionSucursalFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the OrganizacionSucursal
     */
    select?: OrganizacionSucursalSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: OrganizacionSucursalInclude<ExtArgs> | null
    /**
     * Filter, which OrganizacionSucursal to fetch.
     */
    where: OrganizacionSucursalWhereUniqueInput
  }

  /**
   * OrganizacionSucursal findFirst
   */
  export type OrganizacionSucursalFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the OrganizacionSucursal
     */
    select?: OrganizacionSucursalSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: OrganizacionSucursalInclude<ExtArgs> | null
    /**
     * Filter, which OrganizacionSucursal to fetch.
     */
    where?: OrganizacionSucursalWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of OrganizacionSucursals to fetch.
     */
    orderBy?: OrganizacionSucursalOrderByWithRelationInput | OrganizacionSucursalOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for OrganizacionSucursals.
     */
    cursor?: OrganizacionSucursalWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` OrganizacionSucursals from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` OrganizacionSucursals.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of OrganizacionSucursals.
     */
    distinct?: OrganizacionSucursalScalarFieldEnum | OrganizacionSucursalScalarFieldEnum[]
  }

  /**
   * OrganizacionSucursal findFirstOrThrow
   */
  export type OrganizacionSucursalFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the OrganizacionSucursal
     */
    select?: OrganizacionSucursalSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: OrganizacionSucursalInclude<ExtArgs> | null
    /**
     * Filter, which OrganizacionSucursal to fetch.
     */
    where?: OrganizacionSucursalWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of OrganizacionSucursals to fetch.
     */
    orderBy?: OrganizacionSucursalOrderByWithRelationInput | OrganizacionSucursalOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for OrganizacionSucursals.
     */
    cursor?: OrganizacionSucursalWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` OrganizacionSucursals from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` OrganizacionSucursals.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of OrganizacionSucursals.
     */
    distinct?: OrganizacionSucursalScalarFieldEnum | OrganizacionSucursalScalarFieldEnum[]
  }

  /**
   * OrganizacionSucursal findMany
   */
  export type OrganizacionSucursalFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the OrganizacionSucursal
     */
    select?: OrganizacionSucursalSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: OrganizacionSucursalInclude<ExtArgs> | null
    /**
     * Filter, which OrganizacionSucursals to fetch.
     */
    where?: OrganizacionSucursalWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of OrganizacionSucursals to fetch.
     */
    orderBy?: OrganizacionSucursalOrderByWithRelationInput | OrganizacionSucursalOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing OrganizacionSucursals.
     */
    cursor?: OrganizacionSucursalWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` OrganizacionSucursals from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` OrganizacionSucursals.
     */
    skip?: number
    distinct?: OrganizacionSucursalScalarFieldEnum | OrganizacionSucursalScalarFieldEnum[]
  }

  /**
   * OrganizacionSucursal create
   */
  export type OrganizacionSucursalCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the OrganizacionSucursal
     */
    select?: OrganizacionSucursalSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: OrganizacionSucursalInclude<ExtArgs> | null
    /**
     * The data needed to create a OrganizacionSucursal.
     */
    data: XOR<OrganizacionSucursalCreateInput, OrganizacionSucursalUncheckedCreateInput>
  }

  /**
   * OrganizacionSucursal createMany
   */
  export type OrganizacionSucursalCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many OrganizacionSucursals.
     */
    data: OrganizacionSucursalCreateManyInput | OrganizacionSucursalCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * OrganizacionSucursal update
   */
  export type OrganizacionSucursalUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the OrganizacionSucursal
     */
    select?: OrganizacionSucursalSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: OrganizacionSucursalInclude<ExtArgs> | null
    /**
     * The data needed to update a OrganizacionSucursal.
     */
    data: XOR<OrganizacionSucursalUpdateInput, OrganizacionSucursalUncheckedUpdateInput>
    /**
     * Choose, which OrganizacionSucursal to update.
     */
    where: OrganizacionSucursalWhereUniqueInput
  }

  /**
   * OrganizacionSucursal updateMany
   */
  export type OrganizacionSucursalUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update OrganizacionSucursals.
     */
    data: XOR<OrganizacionSucursalUpdateManyMutationInput, OrganizacionSucursalUncheckedUpdateManyInput>
    /**
     * Filter which OrganizacionSucursals to update
     */
    where?: OrganizacionSucursalWhereInput
  }

  /**
   * OrganizacionSucursal upsert
   */
  export type OrganizacionSucursalUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the OrganizacionSucursal
     */
    select?: OrganizacionSucursalSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: OrganizacionSucursalInclude<ExtArgs> | null
    /**
     * The filter to search for the OrganizacionSucursal to update in case it exists.
     */
    where: OrganizacionSucursalWhereUniqueInput
    /**
     * In case the OrganizacionSucursal found by the `where` argument doesn't exist, create a new OrganizacionSucursal with this data.
     */
    create: XOR<OrganizacionSucursalCreateInput, OrganizacionSucursalUncheckedCreateInput>
    /**
     * In case the OrganizacionSucursal was found with the provided `where` argument, update it with this data.
     */
    update: XOR<OrganizacionSucursalUpdateInput, OrganizacionSucursalUncheckedUpdateInput>
  }

  /**
   * OrganizacionSucursal delete
   */
  export type OrganizacionSucursalDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the OrganizacionSucursal
     */
    select?: OrganizacionSucursalSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: OrganizacionSucursalInclude<ExtArgs> | null
    /**
     * Filter which OrganizacionSucursal to delete.
     */
    where: OrganizacionSucursalWhereUniqueInput
  }

  /**
   * OrganizacionSucursal deleteMany
   */
  export type OrganizacionSucursalDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which OrganizacionSucursals to delete
     */
    where?: OrganizacionSucursalWhereInput
  }

  /**
   * OrganizacionSucursal.instalaciones
   */
  export type OrganizacionSucursal$instalacionesArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Instalacion
     */
    select?: InstalacionSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: InstalacionInclude<ExtArgs> | null
    where?: InstalacionWhereInput
    orderBy?: InstalacionOrderByWithRelationInput | InstalacionOrderByWithRelationInput[]
    cursor?: InstalacionWhereUniqueInput
    take?: number
    skip?: number
    distinct?: InstalacionScalarFieldEnum | InstalacionScalarFieldEnum[]
  }

  /**
   * OrganizacionSucursal without action
   */
  export type OrganizacionSucursalDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the OrganizacionSucursal
     */
    select?: OrganizacionSucursalSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: OrganizacionSucursalInclude<ExtArgs> | null
  }


  /**
   * Model Instalacion
   */

  export type AggregateInstalacion = {
    _count: InstalacionCountAggregateOutputType | null
    _avg: InstalacionAvgAggregateOutputType | null
    _sum: InstalacionSumAggregateOutputType | null
    _min: InstalacionMinAggregateOutputType | null
    _max: InstalacionMaxAggregateOutputType | null
  }

  export type InstalacionAvgAggregateOutputType = {
    id_instalacion: number | null
    id_organizacion_sucursal: number | null
  }

  export type InstalacionSumAggregateOutputType = {
    id_instalacion: number | null
    id_organizacion_sucursal: number | null
  }

  export type InstalacionMinAggregateOutputType = {
    id_instalacion: number | null
    id_organizacion_sucursal: number | null
    nombre_instalacion: string | null
    fecha_creacion: Date | null
  }

  export type InstalacionMaxAggregateOutputType = {
    id_instalacion: number | null
    id_organizacion_sucursal: number | null
    nombre_instalacion: string | null
    fecha_creacion: Date | null
  }

  export type InstalacionCountAggregateOutputType = {
    id_instalacion: number
    id_organizacion_sucursal: number
    nombre_instalacion: number
    fecha_creacion: number
    _all: number
  }


  export type InstalacionAvgAggregateInputType = {
    id_instalacion?: true
    id_organizacion_sucursal?: true
  }

  export type InstalacionSumAggregateInputType = {
    id_instalacion?: true
    id_organizacion_sucursal?: true
  }

  export type InstalacionMinAggregateInputType = {
    id_instalacion?: true
    id_organizacion_sucursal?: true
    nombre_instalacion?: true
    fecha_creacion?: true
  }

  export type InstalacionMaxAggregateInputType = {
    id_instalacion?: true
    id_organizacion_sucursal?: true
    nombre_instalacion?: true
    fecha_creacion?: true
  }

  export type InstalacionCountAggregateInputType = {
    id_instalacion?: true
    id_organizacion_sucursal?: true
    nombre_instalacion?: true
    fecha_creacion?: true
    _all?: true
  }

  export type InstalacionAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Instalacion to aggregate.
     */
    where?: InstalacionWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Instalacions to fetch.
     */
    orderBy?: InstalacionOrderByWithRelationInput | InstalacionOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: InstalacionWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Instalacions from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Instalacions.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned Instalacions
    **/
    _count?: true | InstalacionCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: InstalacionAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: InstalacionSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: InstalacionMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: InstalacionMaxAggregateInputType
  }

  export type GetInstalacionAggregateType<T extends InstalacionAggregateArgs> = {
        [P in keyof T & keyof AggregateInstalacion]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateInstalacion[P]>
      : GetScalarType<T[P], AggregateInstalacion[P]>
  }




  export type InstalacionGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: InstalacionWhereInput
    orderBy?: InstalacionOrderByWithAggregationInput | InstalacionOrderByWithAggregationInput[]
    by: InstalacionScalarFieldEnum[] | InstalacionScalarFieldEnum
    having?: InstalacionScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: InstalacionCountAggregateInputType | true
    _avg?: InstalacionAvgAggregateInputType
    _sum?: InstalacionSumAggregateInputType
    _min?: InstalacionMinAggregateInputType
    _max?: InstalacionMaxAggregateInputType
  }

  export type InstalacionGroupByOutputType = {
    id_instalacion: number
    id_organizacion_sucursal: number
    nombre_instalacion: string
    fecha_creacion: Date
    _count: InstalacionCountAggregateOutputType | null
    _avg: InstalacionAvgAggregateOutputType | null
    _sum: InstalacionSumAggregateOutputType | null
    _min: InstalacionMinAggregateOutputType | null
    _max: InstalacionMaxAggregateOutputType | null
  }

  type GetInstalacionGroupByPayload<T extends InstalacionGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<InstalacionGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof InstalacionGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], InstalacionGroupByOutputType[P]>
            : GetScalarType<T[P], InstalacionGroupByOutputType[P]>
        }
      >
    >


  export type InstalacionSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id_instalacion?: boolean
    id_organizacion_sucursal?: boolean
    nombre_instalacion?: boolean
    fecha_creacion?: boolean
    sucursal?: boolean | OrganizacionSucursalDefaultArgs<ExtArgs>
    sensores?: boolean | Instalacion$sensoresArgs<ExtArgs>
    _count?: boolean | InstalacionCountOutputTypeDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["instalacion"]>


  export type InstalacionSelectScalar = {
    id_instalacion?: boolean
    id_organizacion_sucursal?: boolean
    nombre_instalacion?: boolean
    fecha_creacion?: boolean
  }

  export type InstalacionInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    sucursal?: boolean | OrganizacionSucursalDefaultArgs<ExtArgs>
    sensores?: boolean | Instalacion$sensoresArgs<ExtArgs>
    _count?: boolean | InstalacionCountOutputTypeDefaultArgs<ExtArgs>
  }

  export type $InstalacionPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "Instalacion"
    objects: {
      sucursal: Prisma.$OrganizacionSucursalPayload<ExtArgs>
      sensores: Prisma.$SensorInstaladoPayload<ExtArgs>[]
    }
    scalars: $Extensions.GetPayloadResult<{
      id_instalacion: number
      id_organizacion_sucursal: number
      nombre_instalacion: string
      fecha_creacion: Date
    }, ExtArgs["result"]["instalacion"]>
    composites: {}
  }

  type InstalacionGetPayload<S extends boolean | null | undefined | InstalacionDefaultArgs> = $Result.GetResult<Prisma.$InstalacionPayload, S>

  type InstalacionCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = 
    Omit<InstalacionFindManyArgs, 'select' | 'include' | 'distinct'> & {
      select?: InstalacionCountAggregateInputType | true
    }

  export interface InstalacionDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['Instalacion'], meta: { name: 'Instalacion' } }
    /**
     * Find zero or one Instalacion that matches the filter.
     * @param {InstalacionFindUniqueArgs} args - Arguments to find a Instalacion
     * @example
     * // Get one Instalacion
     * const instalacion = await prisma.instalacion.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends InstalacionFindUniqueArgs>(args: SelectSubset<T, InstalacionFindUniqueArgs<ExtArgs>>): Prisma__InstalacionClient<$Result.GetResult<Prisma.$InstalacionPayload<ExtArgs>, T, "findUnique"> | null, null, ExtArgs>

    /**
     * Find one Instalacion that matches the filter or throw an error with `error.code='P2025'` 
     * if no matches were found.
     * @param {InstalacionFindUniqueOrThrowArgs} args - Arguments to find a Instalacion
     * @example
     * // Get one Instalacion
     * const instalacion = await prisma.instalacion.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends InstalacionFindUniqueOrThrowArgs>(args: SelectSubset<T, InstalacionFindUniqueOrThrowArgs<ExtArgs>>): Prisma__InstalacionClient<$Result.GetResult<Prisma.$InstalacionPayload<ExtArgs>, T, "findUniqueOrThrow">, never, ExtArgs>

    /**
     * Find the first Instalacion that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {InstalacionFindFirstArgs} args - Arguments to find a Instalacion
     * @example
     * // Get one Instalacion
     * const instalacion = await prisma.instalacion.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends InstalacionFindFirstArgs>(args?: SelectSubset<T, InstalacionFindFirstArgs<ExtArgs>>): Prisma__InstalacionClient<$Result.GetResult<Prisma.$InstalacionPayload<ExtArgs>, T, "findFirst"> | null, null, ExtArgs>

    /**
     * Find the first Instalacion that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {InstalacionFindFirstOrThrowArgs} args - Arguments to find a Instalacion
     * @example
     * // Get one Instalacion
     * const instalacion = await prisma.instalacion.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends InstalacionFindFirstOrThrowArgs>(args?: SelectSubset<T, InstalacionFindFirstOrThrowArgs<ExtArgs>>): Prisma__InstalacionClient<$Result.GetResult<Prisma.$InstalacionPayload<ExtArgs>, T, "findFirstOrThrow">, never, ExtArgs>

    /**
     * Find zero or more Instalacions that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {InstalacionFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Instalacions
     * const instalacions = await prisma.instalacion.findMany()
     * 
     * // Get first 10 Instalacions
     * const instalacions = await prisma.instalacion.findMany({ take: 10 })
     * 
     * // Only select the `id_instalacion`
     * const instalacionWithId_instalacionOnly = await prisma.instalacion.findMany({ select: { id_instalacion: true } })
     * 
     */
    findMany<T extends InstalacionFindManyArgs>(args?: SelectSubset<T, InstalacionFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$InstalacionPayload<ExtArgs>, T, "findMany">>

    /**
     * Create a Instalacion.
     * @param {InstalacionCreateArgs} args - Arguments to create a Instalacion.
     * @example
     * // Create one Instalacion
     * const Instalacion = await prisma.instalacion.create({
     *   data: {
     *     // ... data to create a Instalacion
     *   }
     * })
     * 
     */
    create<T extends InstalacionCreateArgs>(args: SelectSubset<T, InstalacionCreateArgs<ExtArgs>>): Prisma__InstalacionClient<$Result.GetResult<Prisma.$InstalacionPayload<ExtArgs>, T, "create">, never, ExtArgs>

    /**
     * Create many Instalacions.
     * @param {InstalacionCreateManyArgs} args - Arguments to create many Instalacions.
     * @example
     * // Create many Instalacions
     * const instalacion = await prisma.instalacion.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends InstalacionCreateManyArgs>(args?: SelectSubset<T, InstalacionCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Delete a Instalacion.
     * @param {InstalacionDeleteArgs} args - Arguments to delete one Instalacion.
     * @example
     * // Delete one Instalacion
     * const Instalacion = await prisma.instalacion.delete({
     *   where: {
     *     // ... filter to delete one Instalacion
     *   }
     * })
     * 
     */
    delete<T extends InstalacionDeleteArgs>(args: SelectSubset<T, InstalacionDeleteArgs<ExtArgs>>): Prisma__InstalacionClient<$Result.GetResult<Prisma.$InstalacionPayload<ExtArgs>, T, "delete">, never, ExtArgs>

    /**
     * Update one Instalacion.
     * @param {InstalacionUpdateArgs} args - Arguments to update one Instalacion.
     * @example
     * // Update one Instalacion
     * const instalacion = await prisma.instalacion.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends InstalacionUpdateArgs>(args: SelectSubset<T, InstalacionUpdateArgs<ExtArgs>>): Prisma__InstalacionClient<$Result.GetResult<Prisma.$InstalacionPayload<ExtArgs>, T, "update">, never, ExtArgs>

    /**
     * Delete zero or more Instalacions.
     * @param {InstalacionDeleteManyArgs} args - Arguments to filter Instalacions to delete.
     * @example
     * // Delete a few Instalacions
     * const { count } = await prisma.instalacion.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends InstalacionDeleteManyArgs>(args?: SelectSubset<T, InstalacionDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Instalacions.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {InstalacionUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Instalacions
     * const instalacion = await prisma.instalacion.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends InstalacionUpdateManyArgs>(args: SelectSubset<T, InstalacionUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one Instalacion.
     * @param {InstalacionUpsertArgs} args - Arguments to update or create a Instalacion.
     * @example
     * // Update or create a Instalacion
     * const instalacion = await prisma.instalacion.upsert({
     *   create: {
     *     // ... data to create a Instalacion
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Instalacion we want to update
     *   }
     * })
     */
    upsert<T extends InstalacionUpsertArgs>(args: SelectSubset<T, InstalacionUpsertArgs<ExtArgs>>): Prisma__InstalacionClient<$Result.GetResult<Prisma.$InstalacionPayload<ExtArgs>, T, "upsert">, never, ExtArgs>


    /**
     * Count the number of Instalacions.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {InstalacionCountArgs} args - Arguments to filter Instalacions to count.
     * @example
     * // Count the number of Instalacions
     * const count = await prisma.instalacion.count({
     *   where: {
     *     // ... the filter for the Instalacions we want to count
     *   }
     * })
    **/
    count<T extends InstalacionCountArgs>(
      args?: Subset<T, InstalacionCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], InstalacionCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Instalacion.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {InstalacionAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends InstalacionAggregateArgs>(args: Subset<T, InstalacionAggregateArgs>): Prisma.PrismaPromise<GetInstalacionAggregateType<T>>

    /**
     * Group by Instalacion.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {InstalacionGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends InstalacionGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: InstalacionGroupByArgs['orderBy'] }
        : { orderBy?: InstalacionGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, InstalacionGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetInstalacionGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the Instalacion model
   */
  readonly fields: InstalacionFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for Instalacion.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__InstalacionClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    sucursal<T extends OrganizacionSucursalDefaultArgs<ExtArgs> = {}>(args?: Subset<T, OrganizacionSucursalDefaultArgs<ExtArgs>>): Prisma__OrganizacionSucursalClient<$Result.GetResult<Prisma.$OrganizacionSucursalPayload<ExtArgs>, T, "findUniqueOrThrow"> | Null, Null, ExtArgs>
    sensores<T extends Instalacion$sensoresArgs<ExtArgs> = {}>(args?: Subset<T, Instalacion$sensoresArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$SensorInstaladoPayload<ExtArgs>, T, "findMany"> | Null>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the Instalacion model
   */ 
  interface InstalacionFieldRefs {
    readonly id_instalacion: FieldRef<"Instalacion", 'Int'>
    readonly id_organizacion_sucursal: FieldRef<"Instalacion", 'Int'>
    readonly nombre_instalacion: FieldRef<"Instalacion", 'String'>
    readonly fecha_creacion: FieldRef<"Instalacion", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * Instalacion findUnique
   */
  export type InstalacionFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Instalacion
     */
    select?: InstalacionSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: InstalacionInclude<ExtArgs> | null
    /**
     * Filter, which Instalacion to fetch.
     */
    where: InstalacionWhereUniqueInput
  }

  /**
   * Instalacion findUniqueOrThrow
   */
  export type InstalacionFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Instalacion
     */
    select?: InstalacionSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: InstalacionInclude<ExtArgs> | null
    /**
     * Filter, which Instalacion to fetch.
     */
    where: InstalacionWhereUniqueInput
  }

  /**
   * Instalacion findFirst
   */
  export type InstalacionFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Instalacion
     */
    select?: InstalacionSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: InstalacionInclude<ExtArgs> | null
    /**
     * Filter, which Instalacion to fetch.
     */
    where?: InstalacionWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Instalacions to fetch.
     */
    orderBy?: InstalacionOrderByWithRelationInput | InstalacionOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Instalacions.
     */
    cursor?: InstalacionWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Instalacions from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Instalacions.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Instalacions.
     */
    distinct?: InstalacionScalarFieldEnum | InstalacionScalarFieldEnum[]
  }

  /**
   * Instalacion findFirstOrThrow
   */
  export type InstalacionFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Instalacion
     */
    select?: InstalacionSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: InstalacionInclude<ExtArgs> | null
    /**
     * Filter, which Instalacion to fetch.
     */
    where?: InstalacionWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Instalacions to fetch.
     */
    orderBy?: InstalacionOrderByWithRelationInput | InstalacionOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Instalacions.
     */
    cursor?: InstalacionWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Instalacions from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Instalacions.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Instalacions.
     */
    distinct?: InstalacionScalarFieldEnum | InstalacionScalarFieldEnum[]
  }

  /**
   * Instalacion findMany
   */
  export type InstalacionFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Instalacion
     */
    select?: InstalacionSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: InstalacionInclude<ExtArgs> | null
    /**
     * Filter, which Instalacions to fetch.
     */
    where?: InstalacionWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Instalacions to fetch.
     */
    orderBy?: InstalacionOrderByWithRelationInput | InstalacionOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing Instalacions.
     */
    cursor?: InstalacionWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Instalacions from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Instalacions.
     */
    skip?: number
    distinct?: InstalacionScalarFieldEnum | InstalacionScalarFieldEnum[]
  }

  /**
   * Instalacion create
   */
  export type InstalacionCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Instalacion
     */
    select?: InstalacionSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: InstalacionInclude<ExtArgs> | null
    /**
     * The data needed to create a Instalacion.
     */
    data: XOR<InstalacionCreateInput, InstalacionUncheckedCreateInput>
  }

  /**
   * Instalacion createMany
   */
  export type InstalacionCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many Instalacions.
     */
    data: InstalacionCreateManyInput | InstalacionCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * Instalacion update
   */
  export type InstalacionUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Instalacion
     */
    select?: InstalacionSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: InstalacionInclude<ExtArgs> | null
    /**
     * The data needed to update a Instalacion.
     */
    data: XOR<InstalacionUpdateInput, InstalacionUncheckedUpdateInput>
    /**
     * Choose, which Instalacion to update.
     */
    where: InstalacionWhereUniqueInput
  }

  /**
   * Instalacion updateMany
   */
  export type InstalacionUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update Instalacions.
     */
    data: XOR<InstalacionUpdateManyMutationInput, InstalacionUncheckedUpdateManyInput>
    /**
     * Filter which Instalacions to update
     */
    where?: InstalacionWhereInput
  }

  /**
   * Instalacion upsert
   */
  export type InstalacionUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Instalacion
     */
    select?: InstalacionSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: InstalacionInclude<ExtArgs> | null
    /**
     * The filter to search for the Instalacion to update in case it exists.
     */
    where: InstalacionWhereUniqueInput
    /**
     * In case the Instalacion found by the `where` argument doesn't exist, create a new Instalacion with this data.
     */
    create: XOR<InstalacionCreateInput, InstalacionUncheckedCreateInput>
    /**
     * In case the Instalacion was found with the provided `where` argument, update it with this data.
     */
    update: XOR<InstalacionUpdateInput, InstalacionUncheckedUpdateInput>
  }

  /**
   * Instalacion delete
   */
  export type InstalacionDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Instalacion
     */
    select?: InstalacionSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: InstalacionInclude<ExtArgs> | null
    /**
     * Filter which Instalacion to delete.
     */
    where: InstalacionWhereUniqueInput
  }

  /**
   * Instalacion deleteMany
   */
  export type InstalacionDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Instalacions to delete
     */
    where?: InstalacionWhereInput
  }

  /**
   * Instalacion.sensores
   */
  export type Instalacion$sensoresArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the SensorInstalado
     */
    select?: SensorInstaladoSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SensorInstaladoInclude<ExtArgs> | null
    where?: SensorInstaladoWhereInput
    orderBy?: SensorInstaladoOrderByWithRelationInput | SensorInstaladoOrderByWithRelationInput[]
    cursor?: SensorInstaladoWhereUniqueInput
    take?: number
    skip?: number
    distinct?: SensorInstaladoScalarFieldEnum | SensorInstaladoScalarFieldEnum[]
  }

  /**
   * Instalacion without action
   */
  export type InstalacionDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Instalacion
     */
    select?: InstalacionSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: InstalacionInclude<ExtArgs> | null
  }


  /**
   * Model CatalogoSensor
   */

  export type AggregateCatalogoSensor = {
    _count: CatalogoSensorCountAggregateOutputType | null
    _avg: CatalogoSensorAvgAggregateOutputType | null
    _sum: CatalogoSensorSumAggregateOutputType | null
    _min: CatalogoSensorMinAggregateOutputType | null
    _max: CatalogoSensorMaxAggregateOutputType | null
  }

  export type CatalogoSensorAvgAggregateOutputType = {
    id_sensor: number | null
    rango_min: Decimal | null
    rango_max: Decimal | null
  }

  export type CatalogoSensorSumAggregateOutputType = {
    id_sensor: number | null
    rango_min: Decimal | null
    rango_max: Decimal | null
  }

  export type CatalogoSensorMinAggregateOutputType = {
    id_sensor: number | null
    nombre: string | null
    unidad: string | null
    tipo_medida: $Enums.TipoMedida | null
    rango_min: Decimal | null
    rango_max: Decimal | null
  }

  export type CatalogoSensorMaxAggregateOutputType = {
    id_sensor: number | null
    nombre: string | null
    unidad: string | null
    tipo_medida: $Enums.TipoMedida | null
    rango_min: Decimal | null
    rango_max: Decimal | null
  }

  export type CatalogoSensorCountAggregateOutputType = {
    id_sensor: number
    nombre: number
    unidad: number
    tipo_medida: number
    rango_min: number
    rango_max: number
    _all: number
  }


  export type CatalogoSensorAvgAggregateInputType = {
    id_sensor?: true
    rango_min?: true
    rango_max?: true
  }

  export type CatalogoSensorSumAggregateInputType = {
    id_sensor?: true
    rango_min?: true
    rango_max?: true
  }

  export type CatalogoSensorMinAggregateInputType = {
    id_sensor?: true
    nombre?: true
    unidad?: true
    tipo_medida?: true
    rango_min?: true
    rango_max?: true
  }

  export type CatalogoSensorMaxAggregateInputType = {
    id_sensor?: true
    nombre?: true
    unidad?: true
    tipo_medida?: true
    rango_min?: true
    rango_max?: true
  }

  export type CatalogoSensorCountAggregateInputType = {
    id_sensor?: true
    nombre?: true
    unidad?: true
    tipo_medida?: true
    rango_min?: true
    rango_max?: true
    _all?: true
  }

  export type CatalogoSensorAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which CatalogoSensor to aggregate.
     */
    where?: CatalogoSensorWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of CatalogoSensors to fetch.
     */
    orderBy?: CatalogoSensorOrderByWithRelationInput | CatalogoSensorOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: CatalogoSensorWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` CatalogoSensors from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` CatalogoSensors.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned CatalogoSensors
    **/
    _count?: true | CatalogoSensorCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: CatalogoSensorAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: CatalogoSensorSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: CatalogoSensorMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: CatalogoSensorMaxAggregateInputType
  }

  export type GetCatalogoSensorAggregateType<T extends CatalogoSensorAggregateArgs> = {
        [P in keyof T & keyof AggregateCatalogoSensor]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateCatalogoSensor[P]>
      : GetScalarType<T[P], AggregateCatalogoSensor[P]>
  }




  export type CatalogoSensorGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: CatalogoSensorWhereInput
    orderBy?: CatalogoSensorOrderByWithAggregationInput | CatalogoSensorOrderByWithAggregationInput[]
    by: CatalogoSensorScalarFieldEnum[] | CatalogoSensorScalarFieldEnum
    having?: CatalogoSensorScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: CatalogoSensorCountAggregateInputType | true
    _avg?: CatalogoSensorAvgAggregateInputType
    _sum?: CatalogoSensorSumAggregateInputType
    _min?: CatalogoSensorMinAggregateInputType
    _max?: CatalogoSensorMaxAggregateInputType
  }

  export type CatalogoSensorGroupByOutputType = {
    id_sensor: number
    nombre: string
    unidad: string | null
    tipo_medida: $Enums.TipoMedida | null
    rango_min: Decimal | null
    rango_max: Decimal | null
    _count: CatalogoSensorCountAggregateOutputType | null
    _avg: CatalogoSensorAvgAggregateOutputType | null
    _sum: CatalogoSensorSumAggregateOutputType | null
    _min: CatalogoSensorMinAggregateOutputType | null
    _max: CatalogoSensorMaxAggregateOutputType | null
  }

  type GetCatalogoSensorGroupByPayload<T extends CatalogoSensorGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<CatalogoSensorGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof CatalogoSensorGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], CatalogoSensorGroupByOutputType[P]>
            : GetScalarType<T[P], CatalogoSensorGroupByOutputType[P]>
        }
      >
    >


  export type CatalogoSensorSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id_sensor?: boolean
    nombre?: boolean
    unidad?: boolean
    tipo_medida?: boolean
    rango_min?: boolean
    rango_max?: boolean
    sensoresInstalados?: boolean | CatalogoSensor$sensoresInstaladosArgs<ExtArgs>
    _count?: boolean | CatalogoSensorCountOutputTypeDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["catalogoSensor"]>


  export type CatalogoSensorSelectScalar = {
    id_sensor?: boolean
    nombre?: boolean
    unidad?: boolean
    tipo_medida?: boolean
    rango_min?: boolean
    rango_max?: boolean
  }

  export type CatalogoSensorInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    sensoresInstalados?: boolean | CatalogoSensor$sensoresInstaladosArgs<ExtArgs>
    _count?: boolean | CatalogoSensorCountOutputTypeDefaultArgs<ExtArgs>
  }

  export type $CatalogoSensorPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "CatalogoSensor"
    objects: {
      sensoresInstalados: Prisma.$SensorInstaladoPayload<ExtArgs>[]
    }
    scalars: $Extensions.GetPayloadResult<{
      id_sensor: number
      nombre: string
      unidad: string | null
      tipo_medida: $Enums.TipoMedida | null
      rango_min: Prisma.Decimal | null
      rango_max: Prisma.Decimal | null
    }, ExtArgs["result"]["catalogoSensor"]>
    composites: {}
  }

  type CatalogoSensorGetPayload<S extends boolean | null | undefined | CatalogoSensorDefaultArgs> = $Result.GetResult<Prisma.$CatalogoSensorPayload, S>

  type CatalogoSensorCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = 
    Omit<CatalogoSensorFindManyArgs, 'select' | 'include' | 'distinct'> & {
      select?: CatalogoSensorCountAggregateInputType | true
    }

  export interface CatalogoSensorDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['CatalogoSensor'], meta: { name: 'CatalogoSensor' } }
    /**
     * Find zero or one CatalogoSensor that matches the filter.
     * @param {CatalogoSensorFindUniqueArgs} args - Arguments to find a CatalogoSensor
     * @example
     * // Get one CatalogoSensor
     * const catalogoSensor = await prisma.catalogoSensor.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends CatalogoSensorFindUniqueArgs>(args: SelectSubset<T, CatalogoSensorFindUniqueArgs<ExtArgs>>): Prisma__CatalogoSensorClient<$Result.GetResult<Prisma.$CatalogoSensorPayload<ExtArgs>, T, "findUnique"> | null, null, ExtArgs>

    /**
     * Find one CatalogoSensor that matches the filter or throw an error with `error.code='P2025'` 
     * if no matches were found.
     * @param {CatalogoSensorFindUniqueOrThrowArgs} args - Arguments to find a CatalogoSensor
     * @example
     * // Get one CatalogoSensor
     * const catalogoSensor = await prisma.catalogoSensor.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends CatalogoSensorFindUniqueOrThrowArgs>(args: SelectSubset<T, CatalogoSensorFindUniqueOrThrowArgs<ExtArgs>>): Prisma__CatalogoSensorClient<$Result.GetResult<Prisma.$CatalogoSensorPayload<ExtArgs>, T, "findUniqueOrThrow">, never, ExtArgs>

    /**
     * Find the first CatalogoSensor that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {CatalogoSensorFindFirstArgs} args - Arguments to find a CatalogoSensor
     * @example
     * // Get one CatalogoSensor
     * const catalogoSensor = await prisma.catalogoSensor.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends CatalogoSensorFindFirstArgs>(args?: SelectSubset<T, CatalogoSensorFindFirstArgs<ExtArgs>>): Prisma__CatalogoSensorClient<$Result.GetResult<Prisma.$CatalogoSensorPayload<ExtArgs>, T, "findFirst"> | null, null, ExtArgs>

    /**
     * Find the first CatalogoSensor that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {CatalogoSensorFindFirstOrThrowArgs} args - Arguments to find a CatalogoSensor
     * @example
     * // Get one CatalogoSensor
     * const catalogoSensor = await prisma.catalogoSensor.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends CatalogoSensorFindFirstOrThrowArgs>(args?: SelectSubset<T, CatalogoSensorFindFirstOrThrowArgs<ExtArgs>>): Prisma__CatalogoSensorClient<$Result.GetResult<Prisma.$CatalogoSensorPayload<ExtArgs>, T, "findFirstOrThrow">, never, ExtArgs>

    /**
     * Find zero or more CatalogoSensors that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {CatalogoSensorFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all CatalogoSensors
     * const catalogoSensors = await prisma.catalogoSensor.findMany()
     * 
     * // Get first 10 CatalogoSensors
     * const catalogoSensors = await prisma.catalogoSensor.findMany({ take: 10 })
     * 
     * // Only select the `id_sensor`
     * const catalogoSensorWithId_sensorOnly = await prisma.catalogoSensor.findMany({ select: { id_sensor: true } })
     * 
     */
    findMany<T extends CatalogoSensorFindManyArgs>(args?: SelectSubset<T, CatalogoSensorFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$CatalogoSensorPayload<ExtArgs>, T, "findMany">>

    /**
     * Create a CatalogoSensor.
     * @param {CatalogoSensorCreateArgs} args - Arguments to create a CatalogoSensor.
     * @example
     * // Create one CatalogoSensor
     * const CatalogoSensor = await prisma.catalogoSensor.create({
     *   data: {
     *     // ... data to create a CatalogoSensor
     *   }
     * })
     * 
     */
    create<T extends CatalogoSensorCreateArgs>(args: SelectSubset<T, CatalogoSensorCreateArgs<ExtArgs>>): Prisma__CatalogoSensorClient<$Result.GetResult<Prisma.$CatalogoSensorPayload<ExtArgs>, T, "create">, never, ExtArgs>

    /**
     * Create many CatalogoSensors.
     * @param {CatalogoSensorCreateManyArgs} args - Arguments to create many CatalogoSensors.
     * @example
     * // Create many CatalogoSensors
     * const catalogoSensor = await prisma.catalogoSensor.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends CatalogoSensorCreateManyArgs>(args?: SelectSubset<T, CatalogoSensorCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Delete a CatalogoSensor.
     * @param {CatalogoSensorDeleteArgs} args - Arguments to delete one CatalogoSensor.
     * @example
     * // Delete one CatalogoSensor
     * const CatalogoSensor = await prisma.catalogoSensor.delete({
     *   where: {
     *     // ... filter to delete one CatalogoSensor
     *   }
     * })
     * 
     */
    delete<T extends CatalogoSensorDeleteArgs>(args: SelectSubset<T, CatalogoSensorDeleteArgs<ExtArgs>>): Prisma__CatalogoSensorClient<$Result.GetResult<Prisma.$CatalogoSensorPayload<ExtArgs>, T, "delete">, never, ExtArgs>

    /**
     * Update one CatalogoSensor.
     * @param {CatalogoSensorUpdateArgs} args - Arguments to update one CatalogoSensor.
     * @example
     * // Update one CatalogoSensor
     * const catalogoSensor = await prisma.catalogoSensor.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends CatalogoSensorUpdateArgs>(args: SelectSubset<T, CatalogoSensorUpdateArgs<ExtArgs>>): Prisma__CatalogoSensorClient<$Result.GetResult<Prisma.$CatalogoSensorPayload<ExtArgs>, T, "update">, never, ExtArgs>

    /**
     * Delete zero or more CatalogoSensors.
     * @param {CatalogoSensorDeleteManyArgs} args - Arguments to filter CatalogoSensors to delete.
     * @example
     * // Delete a few CatalogoSensors
     * const { count } = await prisma.catalogoSensor.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends CatalogoSensorDeleteManyArgs>(args?: SelectSubset<T, CatalogoSensorDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more CatalogoSensors.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {CatalogoSensorUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many CatalogoSensors
     * const catalogoSensor = await prisma.catalogoSensor.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends CatalogoSensorUpdateManyArgs>(args: SelectSubset<T, CatalogoSensorUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one CatalogoSensor.
     * @param {CatalogoSensorUpsertArgs} args - Arguments to update or create a CatalogoSensor.
     * @example
     * // Update or create a CatalogoSensor
     * const catalogoSensor = await prisma.catalogoSensor.upsert({
     *   create: {
     *     // ... data to create a CatalogoSensor
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the CatalogoSensor we want to update
     *   }
     * })
     */
    upsert<T extends CatalogoSensorUpsertArgs>(args: SelectSubset<T, CatalogoSensorUpsertArgs<ExtArgs>>): Prisma__CatalogoSensorClient<$Result.GetResult<Prisma.$CatalogoSensorPayload<ExtArgs>, T, "upsert">, never, ExtArgs>


    /**
     * Count the number of CatalogoSensors.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {CatalogoSensorCountArgs} args - Arguments to filter CatalogoSensors to count.
     * @example
     * // Count the number of CatalogoSensors
     * const count = await prisma.catalogoSensor.count({
     *   where: {
     *     // ... the filter for the CatalogoSensors we want to count
     *   }
     * })
    **/
    count<T extends CatalogoSensorCountArgs>(
      args?: Subset<T, CatalogoSensorCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], CatalogoSensorCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a CatalogoSensor.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {CatalogoSensorAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends CatalogoSensorAggregateArgs>(args: Subset<T, CatalogoSensorAggregateArgs>): Prisma.PrismaPromise<GetCatalogoSensorAggregateType<T>>

    /**
     * Group by CatalogoSensor.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {CatalogoSensorGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends CatalogoSensorGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: CatalogoSensorGroupByArgs['orderBy'] }
        : { orderBy?: CatalogoSensorGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, CatalogoSensorGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetCatalogoSensorGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the CatalogoSensor model
   */
  readonly fields: CatalogoSensorFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for CatalogoSensor.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__CatalogoSensorClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    sensoresInstalados<T extends CatalogoSensor$sensoresInstaladosArgs<ExtArgs> = {}>(args?: Subset<T, CatalogoSensor$sensoresInstaladosArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$SensorInstaladoPayload<ExtArgs>, T, "findMany"> | Null>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the CatalogoSensor model
   */ 
  interface CatalogoSensorFieldRefs {
    readonly id_sensor: FieldRef<"CatalogoSensor", 'Int'>
    readonly nombre: FieldRef<"CatalogoSensor", 'String'>
    readonly unidad: FieldRef<"CatalogoSensor", 'String'>
    readonly tipo_medida: FieldRef<"CatalogoSensor", 'TipoMedida'>
    readonly rango_min: FieldRef<"CatalogoSensor", 'Decimal'>
    readonly rango_max: FieldRef<"CatalogoSensor", 'Decimal'>
  }
    

  // Custom InputTypes
  /**
   * CatalogoSensor findUnique
   */
  export type CatalogoSensorFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the CatalogoSensor
     */
    select?: CatalogoSensorSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CatalogoSensorInclude<ExtArgs> | null
    /**
     * Filter, which CatalogoSensor to fetch.
     */
    where: CatalogoSensorWhereUniqueInput
  }

  /**
   * CatalogoSensor findUniqueOrThrow
   */
  export type CatalogoSensorFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the CatalogoSensor
     */
    select?: CatalogoSensorSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CatalogoSensorInclude<ExtArgs> | null
    /**
     * Filter, which CatalogoSensor to fetch.
     */
    where: CatalogoSensorWhereUniqueInput
  }

  /**
   * CatalogoSensor findFirst
   */
  export type CatalogoSensorFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the CatalogoSensor
     */
    select?: CatalogoSensorSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CatalogoSensorInclude<ExtArgs> | null
    /**
     * Filter, which CatalogoSensor to fetch.
     */
    where?: CatalogoSensorWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of CatalogoSensors to fetch.
     */
    orderBy?: CatalogoSensorOrderByWithRelationInput | CatalogoSensorOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for CatalogoSensors.
     */
    cursor?: CatalogoSensorWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` CatalogoSensors from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` CatalogoSensors.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of CatalogoSensors.
     */
    distinct?: CatalogoSensorScalarFieldEnum | CatalogoSensorScalarFieldEnum[]
  }

  /**
   * CatalogoSensor findFirstOrThrow
   */
  export type CatalogoSensorFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the CatalogoSensor
     */
    select?: CatalogoSensorSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CatalogoSensorInclude<ExtArgs> | null
    /**
     * Filter, which CatalogoSensor to fetch.
     */
    where?: CatalogoSensorWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of CatalogoSensors to fetch.
     */
    orderBy?: CatalogoSensorOrderByWithRelationInput | CatalogoSensorOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for CatalogoSensors.
     */
    cursor?: CatalogoSensorWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` CatalogoSensors from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` CatalogoSensors.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of CatalogoSensors.
     */
    distinct?: CatalogoSensorScalarFieldEnum | CatalogoSensorScalarFieldEnum[]
  }

  /**
   * CatalogoSensor findMany
   */
  export type CatalogoSensorFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the CatalogoSensor
     */
    select?: CatalogoSensorSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CatalogoSensorInclude<ExtArgs> | null
    /**
     * Filter, which CatalogoSensors to fetch.
     */
    where?: CatalogoSensorWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of CatalogoSensors to fetch.
     */
    orderBy?: CatalogoSensorOrderByWithRelationInput | CatalogoSensorOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing CatalogoSensors.
     */
    cursor?: CatalogoSensorWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` CatalogoSensors from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` CatalogoSensors.
     */
    skip?: number
    distinct?: CatalogoSensorScalarFieldEnum | CatalogoSensorScalarFieldEnum[]
  }

  /**
   * CatalogoSensor create
   */
  export type CatalogoSensorCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the CatalogoSensor
     */
    select?: CatalogoSensorSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CatalogoSensorInclude<ExtArgs> | null
    /**
     * The data needed to create a CatalogoSensor.
     */
    data: XOR<CatalogoSensorCreateInput, CatalogoSensorUncheckedCreateInput>
  }

  /**
   * CatalogoSensor createMany
   */
  export type CatalogoSensorCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many CatalogoSensors.
     */
    data: CatalogoSensorCreateManyInput | CatalogoSensorCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * CatalogoSensor update
   */
  export type CatalogoSensorUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the CatalogoSensor
     */
    select?: CatalogoSensorSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CatalogoSensorInclude<ExtArgs> | null
    /**
     * The data needed to update a CatalogoSensor.
     */
    data: XOR<CatalogoSensorUpdateInput, CatalogoSensorUncheckedUpdateInput>
    /**
     * Choose, which CatalogoSensor to update.
     */
    where: CatalogoSensorWhereUniqueInput
  }

  /**
   * CatalogoSensor updateMany
   */
  export type CatalogoSensorUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update CatalogoSensors.
     */
    data: XOR<CatalogoSensorUpdateManyMutationInput, CatalogoSensorUncheckedUpdateManyInput>
    /**
     * Filter which CatalogoSensors to update
     */
    where?: CatalogoSensorWhereInput
  }

  /**
   * CatalogoSensor upsert
   */
  export type CatalogoSensorUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the CatalogoSensor
     */
    select?: CatalogoSensorSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CatalogoSensorInclude<ExtArgs> | null
    /**
     * The filter to search for the CatalogoSensor to update in case it exists.
     */
    where: CatalogoSensorWhereUniqueInput
    /**
     * In case the CatalogoSensor found by the `where` argument doesn't exist, create a new CatalogoSensor with this data.
     */
    create: XOR<CatalogoSensorCreateInput, CatalogoSensorUncheckedCreateInput>
    /**
     * In case the CatalogoSensor was found with the provided `where` argument, update it with this data.
     */
    update: XOR<CatalogoSensorUpdateInput, CatalogoSensorUncheckedUpdateInput>
  }

  /**
   * CatalogoSensor delete
   */
  export type CatalogoSensorDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the CatalogoSensor
     */
    select?: CatalogoSensorSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CatalogoSensorInclude<ExtArgs> | null
    /**
     * Filter which CatalogoSensor to delete.
     */
    where: CatalogoSensorWhereUniqueInput
  }

  /**
   * CatalogoSensor deleteMany
   */
  export type CatalogoSensorDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which CatalogoSensors to delete
     */
    where?: CatalogoSensorWhereInput
  }

  /**
   * CatalogoSensor.sensoresInstalados
   */
  export type CatalogoSensor$sensoresInstaladosArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the SensorInstalado
     */
    select?: SensorInstaladoSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SensorInstaladoInclude<ExtArgs> | null
    where?: SensorInstaladoWhereInput
    orderBy?: SensorInstaladoOrderByWithRelationInput | SensorInstaladoOrderByWithRelationInput[]
    cursor?: SensorInstaladoWhereUniqueInput
    take?: number
    skip?: number
    distinct?: SensorInstaladoScalarFieldEnum | SensorInstaladoScalarFieldEnum[]
  }

  /**
   * CatalogoSensor without action
   */
  export type CatalogoSensorDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the CatalogoSensor
     */
    select?: CatalogoSensorSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CatalogoSensorInclude<ExtArgs> | null
  }


  /**
   * Model SensorInstalado
   */

  export type AggregateSensorInstalado = {
    _count: SensorInstaladoCountAggregateOutputType | null
    _avg: SensorInstaladoAvgAggregateOutputType | null
    _sum: SensorInstaladoSumAggregateOutputType | null
    _min: SensorInstaladoMinAggregateOutputType | null
    _max: SensorInstaladoMaxAggregateOutputType | null
  }

  export type SensorInstaladoAvgAggregateOutputType = {
    id_sensor_instalado: number | null
    id_instalacion: number | null
    id_sensor: number | null
  }

  export type SensorInstaladoSumAggregateOutputType = {
    id_sensor_instalado: number | null
    id_instalacion: number | null
    id_sensor: number | null
  }

  export type SensorInstaladoMinAggregateOutputType = {
    id_sensor_instalado: number | null
    id_instalacion: number | null
    id_sensor: number | null
    descripcion: string | null
    fecha_instalada: Date | null
  }

  export type SensorInstaladoMaxAggregateOutputType = {
    id_sensor_instalado: number | null
    id_instalacion: number | null
    id_sensor: number | null
    descripcion: string | null
    fecha_instalada: Date | null
  }

  export type SensorInstaladoCountAggregateOutputType = {
    id_sensor_instalado: number
    id_instalacion: number
    id_sensor: number
    descripcion: number
    fecha_instalada: number
    _all: number
  }


  export type SensorInstaladoAvgAggregateInputType = {
    id_sensor_instalado?: true
    id_instalacion?: true
    id_sensor?: true
  }

  export type SensorInstaladoSumAggregateInputType = {
    id_sensor_instalado?: true
    id_instalacion?: true
    id_sensor?: true
  }

  export type SensorInstaladoMinAggregateInputType = {
    id_sensor_instalado?: true
    id_instalacion?: true
    id_sensor?: true
    descripcion?: true
    fecha_instalada?: true
  }

  export type SensorInstaladoMaxAggregateInputType = {
    id_sensor_instalado?: true
    id_instalacion?: true
    id_sensor?: true
    descripcion?: true
    fecha_instalada?: true
  }

  export type SensorInstaladoCountAggregateInputType = {
    id_sensor_instalado?: true
    id_instalacion?: true
    id_sensor?: true
    descripcion?: true
    fecha_instalada?: true
    _all?: true
  }

  export type SensorInstaladoAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which SensorInstalado to aggregate.
     */
    where?: SensorInstaladoWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of SensorInstalados to fetch.
     */
    orderBy?: SensorInstaladoOrderByWithRelationInput | SensorInstaladoOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: SensorInstaladoWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` SensorInstalados from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` SensorInstalados.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned SensorInstalados
    **/
    _count?: true | SensorInstaladoCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: SensorInstaladoAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: SensorInstaladoSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: SensorInstaladoMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: SensorInstaladoMaxAggregateInputType
  }

  export type GetSensorInstaladoAggregateType<T extends SensorInstaladoAggregateArgs> = {
        [P in keyof T & keyof AggregateSensorInstalado]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateSensorInstalado[P]>
      : GetScalarType<T[P], AggregateSensorInstalado[P]>
  }




  export type SensorInstaladoGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: SensorInstaladoWhereInput
    orderBy?: SensorInstaladoOrderByWithAggregationInput | SensorInstaladoOrderByWithAggregationInput[]
    by: SensorInstaladoScalarFieldEnum[] | SensorInstaladoScalarFieldEnum
    having?: SensorInstaladoScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: SensorInstaladoCountAggregateInputType | true
    _avg?: SensorInstaladoAvgAggregateInputType
    _sum?: SensorInstaladoSumAggregateInputType
    _min?: SensorInstaladoMinAggregateInputType
    _max?: SensorInstaladoMaxAggregateInputType
  }

  export type SensorInstaladoGroupByOutputType = {
    id_sensor_instalado: number
    id_instalacion: number
    id_sensor: number
    descripcion: string | null
    fecha_instalada: Date | null
    _count: SensorInstaladoCountAggregateOutputType | null
    _avg: SensorInstaladoAvgAggregateOutputType | null
    _sum: SensorInstaladoSumAggregateOutputType | null
    _min: SensorInstaladoMinAggregateOutputType | null
    _max: SensorInstaladoMaxAggregateOutputType | null
  }

  type GetSensorInstaladoGroupByPayload<T extends SensorInstaladoGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<SensorInstaladoGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof SensorInstaladoGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], SensorInstaladoGroupByOutputType[P]>
            : GetScalarType<T[P], SensorInstaladoGroupByOutputType[P]>
        }
      >
    >


  export type SensorInstaladoSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id_sensor_instalado?: boolean
    id_instalacion?: boolean
    id_sensor?: boolean
    descripcion?: boolean
    fecha_instalada?: boolean
    instalacion?: boolean | InstalacionDefaultArgs<ExtArgs>
    catalogo?: boolean | CatalogoSensorDefaultArgs<ExtArgs>
    lecturas?: boolean | SensorInstalado$lecturasArgs<ExtArgs>
    _count?: boolean | SensorInstaladoCountOutputTypeDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["sensorInstalado"]>


  export type SensorInstaladoSelectScalar = {
    id_sensor_instalado?: boolean
    id_instalacion?: boolean
    id_sensor?: boolean
    descripcion?: boolean
    fecha_instalada?: boolean
  }

  export type SensorInstaladoInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    instalacion?: boolean | InstalacionDefaultArgs<ExtArgs>
    catalogo?: boolean | CatalogoSensorDefaultArgs<ExtArgs>
    lecturas?: boolean | SensorInstalado$lecturasArgs<ExtArgs>
    _count?: boolean | SensorInstaladoCountOutputTypeDefaultArgs<ExtArgs>
  }

  export type $SensorInstaladoPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "SensorInstalado"
    objects: {
      instalacion: Prisma.$InstalacionPayload<ExtArgs>
      catalogo: Prisma.$CatalogoSensorPayload<ExtArgs>
      lecturas: Prisma.$LecturaPayload<ExtArgs>[]
    }
    scalars: $Extensions.GetPayloadResult<{
      id_sensor_instalado: number
      id_instalacion: number
      id_sensor: number
      descripcion: string | null
      fecha_instalada: Date | null
    }, ExtArgs["result"]["sensorInstalado"]>
    composites: {}
  }

  type SensorInstaladoGetPayload<S extends boolean | null | undefined | SensorInstaladoDefaultArgs> = $Result.GetResult<Prisma.$SensorInstaladoPayload, S>

  type SensorInstaladoCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = 
    Omit<SensorInstaladoFindManyArgs, 'select' | 'include' | 'distinct'> & {
      select?: SensorInstaladoCountAggregateInputType | true
    }

  export interface SensorInstaladoDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['SensorInstalado'], meta: { name: 'SensorInstalado' } }
    /**
     * Find zero or one SensorInstalado that matches the filter.
     * @param {SensorInstaladoFindUniqueArgs} args - Arguments to find a SensorInstalado
     * @example
     * // Get one SensorInstalado
     * const sensorInstalado = await prisma.sensorInstalado.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends SensorInstaladoFindUniqueArgs>(args: SelectSubset<T, SensorInstaladoFindUniqueArgs<ExtArgs>>): Prisma__SensorInstaladoClient<$Result.GetResult<Prisma.$SensorInstaladoPayload<ExtArgs>, T, "findUnique"> | null, null, ExtArgs>

    /**
     * Find one SensorInstalado that matches the filter or throw an error with `error.code='P2025'` 
     * if no matches were found.
     * @param {SensorInstaladoFindUniqueOrThrowArgs} args - Arguments to find a SensorInstalado
     * @example
     * // Get one SensorInstalado
     * const sensorInstalado = await prisma.sensorInstalado.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends SensorInstaladoFindUniqueOrThrowArgs>(args: SelectSubset<T, SensorInstaladoFindUniqueOrThrowArgs<ExtArgs>>): Prisma__SensorInstaladoClient<$Result.GetResult<Prisma.$SensorInstaladoPayload<ExtArgs>, T, "findUniqueOrThrow">, never, ExtArgs>

    /**
     * Find the first SensorInstalado that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {SensorInstaladoFindFirstArgs} args - Arguments to find a SensorInstalado
     * @example
     * // Get one SensorInstalado
     * const sensorInstalado = await prisma.sensorInstalado.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends SensorInstaladoFindFirstArgs>(args?: SelectSubset<T, SensorInstaladoFindFirstArgs<ExtArgs>>): Prisma__SensorInstaladoClient<$Result.GetResult<Prisma.$SensorInstaladoPayload<ExtArgs>, T, "findFirst"> | null, null, ExtArgs>

    /**
     * Find the first SensorInstalado that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {SensorInstaladoFindFirstOrThrowArgs} args - Arguments to find a SensorInstalado
     * @example
     * // Get one SensorInstalado
     * const sensorInstalado = await prisma.sensorInstalado.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends SensorInstaladoFindFirstOrThrowArgs>(args?: SelectSubset<T, SensorInstaladoFindFirstOrThrowArgs<ExtArgs>>): Prisma__SensorInstaladoClient<$Result.GetResult<Prisma.$SensorInstaladoPayload<ExtArgs>, T, "findFirstOrThrow">, never, ExtArgs>

    /**
     * Find zero or more SensorInstalados that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {SensorInstaladoFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all SensorInstalados
     * const sensorInstalados = await prisma.sensorInstalado.findMany()
     * 
     * // Get first 10 SensorInstalados
     * const sensorInstalados = await prisma.sensorInstalado.findMany({ take: 10 })
     * 
     * // Only select the `id_sensor_instalado`
     * const sensorInstaladoWithId_sensor_instaladoOnly = await prisma.sensorInstalado.findMany({ select: { id_sensor_instalado: true } })
     * 
     */
    findMany<T extends SensorInstaladoFindManyArgs>(args?: SelectSubset<T, SensorInstaladoFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$SensorInstaladoPayload<ExtArgs>, T, "findMany">>

    /**
     * Create a SensorInstalado.
     * @param {SensorInstaladoCreateArgs} args - Arguments to create a SensorInstalado.
     * @example
     * // Create one SensorInstalado
     * const SensorInstalado = await prisma.sensorInstalado.create({
     *   data: {
     *     // ... data to create a SensorInstalado
     *   }
     * })
     * 
     */
    create<T extends SensorInstaladoCreateArgs>(args: SelectSubset<T, SensorInstaladoCreateArgs<ExtArgs>>): Prisma__SensorInstaladoClient<$Result.GetResult<Prisma.$SensorInstaladoPayload<ExtArgs>, T, "create">, never, ExtArgs>

    /**
     * Create many SensorInstalados.
     * @param {SensorInstaladoCreateManyArgs} args - Arguments to create many SensorInstalados.
     * @example
     * // Create many SensorInstalados
     * const sensorInstalado = await prisma.sensorInstalado.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends SensorInstaladoCreateManyArgs>(args?: SelectSubset<T, SensorInstaladoCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Delete a SensorInstalado.
     * @param {SensorInstaladoDeleteArgs} args - Arguments to delete one SensorInstalado.
     * @example
     * // Delete one SensorInstalado
     * const SensorInstalado = await prisma.sensorInstalado.delete({
     *   where: {
     *     // ... filter to delete one SensorInstalado
     *   }
     * })
     * 
     */
    delete<T extends SensorInstaladoDeleteArgs>(args: SelectSubset<T, SensorInstaladoDeleteArgs<ExtArgs>>): Prisma__SensorInstaladoClient<$Result.GetResult<Prisma.$SensorInstaladoPayload<ExtArgs>, T, "delete">, never, ExtArgs>

    /**
     * Update one SensorInstalado.
     * @param {SensorInstaladoUpdateArgs} args - Arguments to update one SensorInstalado.
     * @example
     * // Update one SensorInstalado
     * const sensorInstalado = await prisma.sensorInstalado.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends SensorInstaladoUpdateArgs>(args: SelectSubset<T, SensorInstaladoUpdateArgs<ExtArgs>>): Prisma__SensorInstaladoClient<$Result.GetResult<Prisma.$SensorInstaladoPayload<ExtArgs>, T, "update">, never, ExtArgs>

    /**
     * Delete zero or more SensorInstalados.
     * @param {SensorInstaladoDeleteManyArgs} args - Arguments to filter SensorInstalados to delete.
     * @example
     * // Delete a few SensorInstalados
     * const { count } = await prisma.sensorInstalado.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends SensorInstaladoDeleteManyArgs>(args?: SelectSubset<T, SensorInstaladoDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more SensorInstalados.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {SensorInstaladoUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many SensorInstalados
     * const sensorInstalado = await prisma.sensorInstalado.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends SensorInstaladoUpdateManyArgs>(args: SelectSubset<T, SensorInstaladoUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one SensorInstalado.
     * @param {SensorInstaladoUpsertArgs} args - Arguments to update or create a SensorInstalado.
     * @example
     * // Update or create a SensorInstalado
     * const sensorInstalado = await prisma.sensorInstalado.upsert({
     *   create: {
     *     // ... data to create a SensorInstalado
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the SensorInstalado we want to update
     *   }
     * })
     */
    upsert<T extends SensorInstaladoUpsertArgs>(args: SelectSubset<T, SensorInstaladoUpsertArgs<ExtArgs>>): Prisma__SensorInstaladoClient<$Result.GetResult<Prisma.$SensorInstaladoPayload<ExtArgs>, T, "upsert">, never, ExtArgs>


    /**
     * Count the number of SensorInstalados.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {SensorInstaladoCountArgs} args - Arguments to filter SensorInstalados to count.
     * @example
     * // Count the number of SensorInstalados
     * const count = await prisma.sensorInstalado.count({
     *   where: {
     *     // ... the filter for the SensorInstalados we want to count
     *   }
     * })
    **/
    count<T extends SensorInstaladoCountArgs>(
      args?: Subset<T, SensorInstaladoCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], SensorInstaladoCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a SensorInstalado.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {SensorInstaladoAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends SensorInstaladoAggregateArgs>(args: Subset<T, SensorInstaladoAggregateArgs>): Prisma.PrismaPromise<GetSensorInstaladoAggregateType<T>>

    /**
     * Group by SensorInstalado.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {SensorInstaladoGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends SensorInstaladoGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: SensorInstaladoGroupByArgs['orderBy'] }
        : { orderBy?: SensorInstaladoGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, SensorInstaladoGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetSensorInstaladoGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the SensorInstalado model
   */
  readonly fields: SensorInstaladoFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for SensorInstalado.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__SensorInstaladoClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    instalacion<T extends InstalacionDefaultArgs<ExtArgs> = {}>(args?: Subset<T, InstalacionDefaultArgs<ExtArgs>>): Prisma__InstalacionClient<$Result.GetResult<Prisma.$InstalacionPayload<ExtArgs>, T, "findUniqueOrThrow"> | Null, Null, ExtArgs>
    catalogo<T extends CatalogoSensorDefaultArgs<ExtArgs> = {}>(args?: Subset<T, CatalogoSensorDefaultArgs<ExtArgs>>): Prisma__CatalogoSensorClient<$Result.GetResult<Prisma.$CatalogoSensorPayload<ExtArgs>, T, "findUniqueOrThrow"> | Null, Null, ExtArgs>
    lecturas<T extends SensorInstalado$lecturasArgs<ExtArgs> = {}>(args?: Subset<T, SensorInstalado$lecturasArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$LecturaPayload<ExtArgs>, T, "findMany"> | Null>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the SensorInstalado model
   */ 
  interface SensorInstaladoFieldRefs {
    readonly id_sensor_instalado: FieldRef<"SensorInstalado", 'Int'>
    readonly id_instalacion: FieldRef<"SensorInstalado", 'Int'>
    readonly id_sensor: FieldRef<"SensorInstalado", 'Int'>
    readonly descripcion: FieldRef<"SensorInstalado", 'String'>
    readonly fecha_instalada: FieldRef<"SensorInstalado", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * SensorInstalado findUnique
   */
  export type SensorInstaladoFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the SensorInstalado
     */
    select?: SensorInstaladoSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SensorInstaladoInclude<ExtArgs> | null
    /**
     * Filter, which SensorInstalado to fetch.
     */
    where: SensorInstaladoWhereUniqueInput
  }

  /**
   * SensorInstalado findUniqueOrThrow
   */
  export type SensorInstaladoFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the SensorInstalado
     */
    select?: SensorInstaladoSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SensorInstaladoInclude<ExtArgs> | null
    /**
     * Filter, which SensorInstalado to fetch.
     */
    where: SensorInstaladoWhereUniqueInput
  }

  /**
   * SensorInstalado findFirst
   */
  export type SensorInstaladoFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the SensorInstalado
     */
    select?: SensorInstaladoSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SensorInstaladoInclude<ExtArgs> | null
    /**
     * Filter, which SensorInstalado to fetch.
     */
    where?: SensorInstaladoWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of SensorInstalados to fetch.
     */
    orderBy?: SensorInstaladoOrderByWithRelationInput | SensorInstaladoOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for SensorInstalados.
     */
    cursor?: SensorInstaladoWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` SensorInstalados from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` SensorInstalados.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of SensorInstalados.
     */
    distinct?: SensorInstaladoScalarFieldEnum | SensorInstaladoScalarFieldEnum[]
  }

  /**
   * SensorInstalado findFirstOrThrow
   */
  export type SensorInstaladoFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the SensorInstalado
     */
    select?: SensorInstaladoSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SensorInstaladoInclude<ExtArgs> | null
    /**
     * Filter, which SensorInstalado to fetch.
     */
    where?: SensorInstaladoWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of SensorInstalados to fetch.
     */
    orderBy?: SensorInstaladoOrderByWithRelationInput | SensorInstaladoOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for SensorInstalados.
     */
    cursor?: SensorInstaladoWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` SensorInstalados from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` SensorInstalados.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of SensorInstalados.
     */
    distinct?: SensorInstaladoScalarFieldEnum | SensorInstaladoScalarFieldEnum[]
  }

  /**
   * SensorInstalado findMany
   */
  export type SensorInstaladoFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the SensorInstalado
     */
    select?: SensorInstaladoSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SensorInstaladoInclude<ExtArgs> | null
    /**
     * Filter, which SensorInstalados to fetch.
     */
    where?: SensorInstaladoWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of SensorInstalados to fetch.
     */
    orderBy?: SensorInstaladoOrderByWithRelationInput | SensorInstaladoOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing SensorInstalados.
     */
    cursor?: SensorInstaladoWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` SensorInstalados from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` SensorInstalados.
     */
    skip?: number
    distinct?: SensorInstaladoScalarFieldEnum | SensorInstaladoScalarFieldEnum[]
  }

  /**
   * SensorInstalado create
   */
  export type SensorInstaladoCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the SensorInstalado
     */
    select?: SensorInstaladoSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SensorInstaladoInclude<ExtArgs> | null
    /**
     * The data needed to create a SensorInstalado.
     */
    data: XOR<SensorInstaladoCreateInput, SensorInstaladoUncheckedCreateInput>
  }

  /**
   * SensorInstalado createMany
   */
  export type SensorInstaladoCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many SensorInstalados.
     */
    data: SensorInstaladoCreateManyInput | SensorInstaladoCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * SensorInstalado update
   */
  export type SensorInstaladoUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the SensorInstalado
     */
    select?: SensorInstaladoSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SensorInstaladoInclude<ExtArgs> | null
    /**
     * The data needed to update a SensorInstalado.
     */
    data: XOR<SensorInstaladoUpdateInput, SensorInstaladoUncheckedUpdateInput>
    /**
     * Choose, which SensorInstalado to update.
     */
    where: SensorInstaladoWhereUniqueInput
  }

  /**
   * SensorInstalado updateMany
   */
  export type SensorInstaladoUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update SensorInstalados.
     */
    data: XOR<SensorInstaladoUpdateManyMutationInput, SensorInstaladoUncheckedUpdateManyInput>
    /**
     * Filter which SensorInstalados to update
     */
    where?: SensorInstaladoWhereInput
  }

  /**
   * SensorInstalado upsert
   */
  export type SensorInstaladoUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the SensorInstalado
     */
    select?: SensorInstaladoSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SensorInstaladoInclude<ExtArgs> | null
    /**
     * The filter to search for the SensorInstalado to update in case it exists.
     */
    where: SensorInstaladoWhereUniqueInput
    /**
     * In case the SensorInstalado found by the `where` argument doesn't exist, create a new SensorInstalado with this data.
     */
    create: XOR<SensorInstaladoCreateInput, SensorInstaladoUncheckedCreateInput>
    /**
     * In case the SensorInstalado was found with the provided `where` argument, update it with this data.
     */
    update: XOR<SensorInstaladoUpdateInput, SensorInstaladoUncheckedUpdateInput>
  }

  /**
   * SensorInstalado delete
   */
  export type SensorInstaladoDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the SensorInstalado
     */
    select?: SensorInstaladoSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SensorInstaladoInclude<ExtArgs> | null
    /**
     * Filter which SensorInstalado to delete.
     */
    where: SensorInstaladoWhereUniqueInput
  }

  /**
   * SensorInstalado deleteMany
   */
  export type SensorInstaladoDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which SensorInstalados to delete
     */
    where?: SensorInstaladoWhereInput
  }

  /**
   * SensorInstalado.lecturas
   */
  export type SensorInstalado$lecturasArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Lectura
     */
    select?: LecturaSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: LecturaInclude<ExtArgs> | null
    where?: LecturaWhereInput
    orderBy?: LecturaOrderByWithRelationInput | LecturaOrderByWithRelationInput[]
    cursor?: LecturaWhereUniqueInput
    take?: number
    skip?: number
    distinct?: LecturaScalarFieldEnum | LecturaScalarFieldEnum[]
  }

  /**
   * SensorInstalado without action
   */
  export type SensorInstaladoDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the SensorInstalado
     */
    select?: SensorInstaladoSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SensorInstaladoInclude<ExtArgs> | null
  }


  /**
   * Model Lectura
   */

  export type AggregateLectura = {
    _count: LecturaCountAggregateOutputType | null
    _avg: LecturaAvgAggregateOutputType | null
    _sum: LecturaSumAggregateOutputType | null
    _min: LecturaMinAggregateOutputType | null
    _max: LecturaMaxAggregateOutputType | null
  }

  export type LecturaAvgAggregateOutputType = {
    id_lectura: number | null
    id_sensor_instalado: number | null
    valor: Decimal | null
  }

  export type LecturaSumAggregateOutputType = {
    id_lectura: bigint | null
    id_sensor_instalado: number | null
    valor: Decimal | null
  }

  export type LecturaMinAggregateOutputType = {
    id_lectura: bigint | null
    id_sensor_instalado: number | null
    valor: Decimal | null
    tomada_en: Date | null
  }

  export type LecturaMaxAggregateOutputType = {
    id_lectura: bigint | null
    id_sensor_instalado: number | null
    valor: Decimal | null
    tomada_en: Date | null
  }

  export type LecturaCountAggregateOutputType = {
    id_lectura: number
    id_sensor_instalado: number
    valor: number
    tomada_en: number
    _all: number
  }


  export type LecturaAvgAggregateInputType = {
    id_lectura?: true
    id_sensor_instalado?: true
    valor?: true
  }

  export type LecturaSumAggregateInputType = {
    id_lectura?: true
    id_sensor_instalado?: true
    valor?: true
  }

  export type LecturaMinAggregateInputType = {
    id_lectura?: true
    id_sensor_instalado?: true
    valor?: true
    tomada_en?: true
  }

  export type LecturaMaxAggregateInputType = {
    id_lectura?: true
    id_sensor_instalado?: true
    valor?: true
    tomada_en?: true
  }

  export type LecturaCountAggregateInputType = {
    id_lectura?: true
    id_sensor_instalado?: true
    valor?: true
    tomada_en?: true
    _all?: true
  }

  export type LecturaAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Lectura to aggregate.
     */
    where?: LecturaWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Lecturas to fetch.
     */
    orderBy?: LecturaOrderByWithRelationInput | LecturaOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: LecturaWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Lecturas from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Lecturas.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned Lecturas
    **/
    _count?: true | LecturaCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: LecturaAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: LecturaSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: LecturaMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: LecturaMaxAggregateInputType
  }

  export type GetLecturaAggregateType<T extends LecturaAggregateArgs> = {
        [P in keyof T & keyof AggregateLectura]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateLectura[P]>
      : GetScalarType<T[P], AggregateLectura[P]>
  }




  export type LecturaGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: LecturaWhereInput
    orderBy?: LecturaOrderByWithAggregationInput | LecturaOrderByWithAggregationInput[]
    by: LecturaScalarFieldEnum[] | LecturaScalarFieldEnum
    having?: LecturaScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: LecturaCountAggregateInputType | true
    _avg?: LecturaAvgAggregateInputType
    _sum?: LecturaSumAggregateInputType
    _min?: LecturaMinAggregateInputType
    _max?: LecturaMaxAggregateInputType
  }

  export type LecturaGroupByOutputType = {
    id_lectura: bigint
    id_sensor_instalado: number
    valor: Decimal
    tomada_en: Date
    _count: LecturaCountAggregateOutputType | null
    _avg: LecturaAvgAggregateOutputType | null
    _sum: LecturaSumAggregateOutputType | null
    _min: LecturaMinAggregateOutputType | null
    _max: LecturaMaxAggregateOutputType | null
  }

  type GetLecturaGroupByPayload<T extends LecturaGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<LecturaGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof LecturaGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], LecturaGroupByOutputType[P]>
            : GetScalarType<T[P], LecturaGroupByOutputType[P]>
        }
      >
    >


  export type LecturaSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id_lectura?: boolean
    id_sensor_instalado?: boolean
    valor?: boolean
    tomada_en?: boolean
    sensor?: boolean | SensorInstaladoDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["lectura"]>


  export type LecturaSelectScalar = {
    id_lectura?: boolean
    id_sensor_instalado?: boolean
    valor?: boolean
    tomada_en?: boolean
  }

  export type LecturaInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    sensor?: boolean | SensorInstaladoDefaultArgs<ExtArgs>
  }

  export type $LecturaPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "Lectura"
    objects: {
      sensor: Prisma.$SensorInstaladoPayload<ExtArgs>
    }
    scalars: $Extensions.GetPayloadResult<{
      id_lectura: bigint
      id_sensor_instalado: number
      valor: Prisma.Decimal
      tomada_en: Date
    }, ExtArgs["result"]["lectura"]>
    composites: {}
  }

  type LecturaGetPayload<S extends boolean | null | undefined | LecturaDefaultArgs> = $Result.GetResult<Prisma.$LecturaPayload, S>

  type LecturaCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = 
    Omit<LecturaFindManyArgs, 'select' | 'include' | 'distinct'> & {
      select?: LecturaCountAggregateInputType | true
    }

  export interface LecturaDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['Lectura'], meta: { name: 'Lectura' } }
    /**
     * Find zero or one Lectura that matches the filter.
     * @param {LecturaFindUniqueArgs} args - Arguments to find a Lectura
     * @example
     * // Get one Lectura
     * const lectura = await prisma.lectura.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends LecturaFindUniqueArgs>(args: SelectSubset<T, LecturaFindUniqueArgs<ExtArgs>>): Prisma__LecturaClient<$Result.GetResult<Prisma.$LecturaPayload<ExtArgs>, T, "findUnique"> | null, null, ExtArgs>

    /**
     * Find one Lectura that matches the filter or throw an error with `error.code='P2025'` 
     * if no matches were found.
     * @param {LecturaFindUniqueOrThrowArgs} args - Arguments to find a Lectura
     * @example
     * // Get one Lectura
     * const lectura = await prisma.lectura.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends LecturaFindUniqueOrThrowArgs>(args: SelectSubset<T, LecturaFindUniqueOrThrowArgs<ExtArgs>>): Prisma__LecturaClient<$Result.GetResult<Prisma.$LecturaPayload<ExtArgs>, T, "findUniqueOrThrow">, never, ExtArgs>

    /**
     * Find the first Lectura that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {LecturaFindFirstArgs} args - Arguments to find a Lectura
     * @example
     * // Get one Lectura
     * const lectura = await prisma.lectura.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends LecturaFindFirstArgs>(args?: SelectSubset<T, LecturaFindFirstArgs<ExtArgs>>): Prisma__LecturaClient<$Result.GetResult<Prisma.$LecturaPayload<ExtArgs>, T, "findFirst"> | null, null, ExtArgs>

    /**
     * Find the first Lectura that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {LecturaFindFirstOrThrowArgs} args - Arguments to find a Lectura
     * @example
     * // Get one Lectura
     * const lectura = await prisma.lectura.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends LecturaFindFirstOrThrowArgs>(args?: SelectSubset<T, LecturaFindFirstOrThrowArgs<ExtArgs>>): Prisma__LecturaClient<$Result.GetResult<Prisma.$LecturaPayload<ExtArgs>, T, "findFirstOrThrow">, never, ExtArgs>

    /**
     * Find zero or more Lecturas that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {LecturaFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Lecturas
     * const lecturas = await prisma.lectura.findMany()
     * 
     * // Get first 10 Lecturas
     * const lecturas = await prisma.lectura.findMany({ take: 10 })
     * 
     * // Only select the `id_lectura`
     * const lecturaWithId_lecturaOnly = await prisma.lectura.findMany({ select: { id_lectura: true } })
     * 
     */
    findMany<T extends LecturaFindManyArgs>(args?: SelectSubset<T, LecturaFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$LecturaPayload<ExtArgs>, T, "findMany">>

    /**
     * Create a Lectura.
     * @param {LecturaCreateArgs} args - Arguments to create a Lectura.
     * @example
     * // Create one Lectura
     * const Lectura = await prisma.lectura.create({
     *   data: {
     *     // ... data to create a Lectura
     *   }
     * })
     * 
     */
    create<T extends LecturaCreateArgs>(args: SelectSubset<T, LecturaCreateArgs<ExtArgs>>): Prisma__LecturaClient<$Result.GetResult<Prisma.$LecturaPayload<ExtArgs>, T, "create">, never, ExtArgs>

    /**
     * Create many Lecturas.
     * @param {LecturaCreateManyArgs} args - Arguments to create many Lecturas.
     * @example
     * // Create many Lecturas
     * const lectura = await prisma.lectura.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends LecturaCreateManyArgs>(args?: SelectSubset<T, LecturaCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Delete a Lectura.
     * @param {LecturaDeleteArgs} args - Arguments to delete one Lectura.
     * @example
     * // Delete one Lectura
     * const Lectura = await prisma.lectura.delete({
     *   where: {
     *     // ... filter to delete one Lectura
     *   }
     * })
     * 
     */
    delete<T extends LecturaDeleteArgs>(args: SelectSubset<T, LecturaDeleteArgs<ExtArgs>>): Prisma__LecturaClient<$Result.GetResult<Prisma.$LecturaPayload<ExtArgs>, T, "delete">, never, ExtArgs>

    /**
     * Update one Lectura.
     * @param {LecturaUpdateArgs} args - Arguments to update one Lectura.
     * @example
     * // Update one Lectura
     * const lectura = await prisma.lectura.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends LecturaUpdateArgs>(args: SelectSubset<T, LecturaUpdateArgs<ExtArgs>>): Prisma__LecturaClient<$Result.GetResult<Prisma.$LecturaPayload<ExtArgs>, T, "update">, never, ExtArgs>

    /**
     * Delete zero or more Lecturas.
     * @param {LecturaDeleteManyArgs} args - Arguments to filter Lecturas to delete.
     * @example
     * // Delete a few Lecturas
     * const { count } = await prisma.lectura.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends LecturaDeleteManyArgs>(args?: SelectSubset<T, LecturaDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Lecturas.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {LecturaUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Lecturas
     * const lectura = await prisma.lectura.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends LecturaUpdateManyArgs>(args: SelectSubset<T, LecturaUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one Lectura.
     * @param {LecturaUpsertArgs} args - Arguments to update or create a Lectura.
     * @example
     * // Update or create a Lectura
     * const lectura = await prisma.lectura.upsert({
     *   create: {
     *     // ... data to create a Lectura
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Lectura we want to update
     *   }
     * })
     */
    upsert<T extends LecturaUpsertArgs>(args: SelectSubset<T, LecturaUpsertArgs<ExtArgs>>): Prisma__LecturaClient<$Result.GetResult<Prisma.$LecturaPayload<ExtArgs>, T, "upsert">, never, ExtArgs>


    /**
     * Count the number of Lecturas.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {LecturaCountArgs} args - Arguments to filter Lecturas to count.
     * @example
     * // Count the number of Lecturas
     * const count = await prisma.lectura.count({
     *   where: {
     *     // ... the filter for the Lecturas we want to count
     *   }
     * })
    **/
    count<T extends LecturaCountArgs>(
      args?: Subset<T, LecturaCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], LecturaCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Lectura.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {LecturaAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends LecturaAggregateArgs>(args: Subset<T, LecturaAggregateArgs>): Prisma.PrismaPromise<GetLecturaAggregateType<T>>

    /**
     * Group by Lectura.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {LecturaGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends LecturaGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: LecturaGroupByArgs['orderBy'] }
        : { orderBy?: LecturaGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, LecturaGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetLecturaGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the Lectura model
   */
  readonly fields: LecturaFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for Lectura.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__LecturaClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    sensor<T extends SensorInstaladoDefaultArgs<ExtArgs> = {}>(args?: Subset<T, SensorInstaladoDefaultArgs<ExtArgs>>): Prisma__SensorInstaladoClient<$Result.GetResult<Prisma.$SensorInstaladoPayload<ExtArgs>, T, "findUniqueOrThrow"> | Null, Null, ExtArgs>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the Lectura model
   */ 
  interface LecturaFieldRefs {
    readonly id_lectura: FieldRef<"Lectura", 'BigInt'>
    readonly id_sensor_instalado: FieldRef<"Lectura", 'Int'>
    readonly valor: FieldRef<"Lectura", 'Decimal'>
    readonly tomada_en: FieldRef<"Lectura", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * Lectura findUnique
   */
  export type LecturaFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Lectura
     */
    select?: LecturaSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: LecturaInclude<ExtArgs> | null
    /**
     * Filter, which Lectura to fetch.
     */
    where: LecturaWhereUniqueInput
  }

  /**
   * Lectura findUniqueOrThrow
   */
  export type LecturaFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Lectura
     */
    select?: LecturaSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: LecturaInclude<ExtArgs> | null
    /**
     * Filter, which Lectura to fetch.
     */
    where: LecturaWhereUniqueInput
  }

  /**
   * Lectura findFirst
   */
  export type LecturaFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Lectura
     */
    select?: LecturaSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: LecturaInclude<ExtArgs> | null
    /**
     * Filter, which Lectura to fetch.
     */
    where?: LecturaWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Lecturas to fetch.
     */
    orderBy?: LecturaOrderByWithRelationInput | LecturaOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Lecturas.
     */
    cursor?: LecturaWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Lecturas from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Lecturas.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Lecturas.
     */
    distinct?: LecturaScalarFieldEnum | LecturaScalarFieldEnum[]
  }

  /**
   * Lectura findFirstOrThrow
   */
  export type LecturaFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Lectura
     */
    select?: LecturaSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: LecturaInclude<ExtArgs> | null
    /**
     * Filter, which Lectura to fetch.
     */
    where?: LecturaWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Lecturas to fetch.
     */
    orderBy?: LecturaOrderByWithRelationInput | LecturaOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Lecturas.
     */
    cursor?: LecturaWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Lecturas from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Lecturas.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Lecturas.
     */
    distinct?: LecturaScalarFieldEnum | LecturaScalarFieldEnum[]
  }

  /**
   * Lectura findMany
   */
  export type LecturaFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Lectura
     */
    select?: LecturaSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: LecturaInclude<ExtArgs> | null
    /**
     * Filter, which Lecturas to fetch.
     */
    where?: LecturaWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Lecturas to fetch.
     */
    orderBy?: LecturaOrderByWithRelationInput | LecturaOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing Lecturas.
     */
    cursor?: LecturaWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Lecturas from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Lecturas.
     */
    skip?: number
    distinct?: LecturaScalarFieldEnum | LecturaScalarFieldEnum[]
  }

  /**
   * Lectura create
   */
  export type LecturaCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Lectura
     */
    select?: LecturaSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: LecturaInclude<ExtArgs> | null
    /**
     * The data needed to create a Lectura.
     */
    data: XOR<LecturaCreateInput, LecturaUncheckedCreateInput>
  }

  /**
   * Lectura createMany
   */
  export type LecturaCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many Lecturas.
     */
    data: LecturaCreateManyInput | LecturaCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * Lectura update
   */
  export type LecturaUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Lectura
     */
    select?: LecturaSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: LecturaInclude<ExtArgs> | null
    /**
     * The data needed to update a Lectura.
     */
    data: XOR<LecturaUpdateInput, LecturaUncheckedUpdateInput>
    /**
     * Choose, which Lectura to update.
     */
    where: LecturaWhereUniqueInput
  }

  /**
   * Lectura updateMany
   */
  export type LecturaUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update Lecturas.
     */
    data: XOR<LecturaUpdateManyMutationInput, LecturaUncheckedUpdateManyInput>
    /**
     * Filter which Lecturas to update
     */
    where?: LecturaWhereInput
  }

  /**
   * Lectura upsert
   */
  export type LecturaUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Lectura
     */
    select?: LecturaSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: LecturaInclude<ExtArgs> | null
    /**
     * The filter to search for the Lectura to update in case it exists.
     */
    where: LecturaWhereUniqueInput
    /**
     * In case the Lectura found by the `where` argument doesn't exist, create a new Lectura with this data.
     */
    create: XOR<LecturaCreateInput, LecturaUncheckedCreateInput>
    /**
     * In case the Lectura was found with the provided `where` argument, update it with this data.
     */
    update: XOR<LecturaUpdateInput, LecturaUncheckedUpdateInput>
  }

  /**
   * Lectura delete
   */
  export type LecturaDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Lectura
     */
    select?: LecturaSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: LecturaInclude<ExtArgs> | null
    /**
     * Filter which Lectura to delete.
     */
    where: LecturaWhereUniqueInput
  }

  /**
   * Lectura deleteMany
   */
  export type LecturaDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Lecturas to delete
     */
    where?: LecturaWhereInput
  }

  /**
   * Lectura without action
   */
  export type LecturaDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Lectura
     */
    select?: LecturaSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: LecturaInclude<ExtArgs> | null
  }


  /**
   * Model ResumenLecturaHoraria
   */

  export type AggregateResumenLecturaHoraria = {
    _count: ResumenLecturaHorariaCountAggregateOutputType | null
    _avg: ResumenLecturaHorariaAvgAggregateOutputType | null
    _sum: ResumenLecturaHorariaSumAggregateOutputType | null
    _min: ResumenLecturaHorariaMinAggregateOutputType | null
    _max: ResumenLecturaHorariaMaxAggregateOutputType | null
  }

  export type ResumenLecturaHorariaAvgAggregateOutputType = {
    id_sensor_instalado: number | null
    min_val: Decimal | null
    max_val: Decimal | null
    avg_val: Decimal | null
    cnt: number | null
  }

  export type ResumenLecturaHorariaSumAggregateOutputType = {
    id_sensor_instalado: number | null
    min_val: Decimal | null
    max_val: Decimal | null
    avg_val: Decimal | null
    cnt: number | null
  }

  export type ResumenLecturaHorariaMinAggregateOutputType = {
    id_sensor_instalado: number | null
    fecha_hora: Date | null
    min_val: Decimal | null
    max_val: Decimal | null
    avg_val: Decimal | null
    cnt: number | null
  }

  export type ResumenLecturaHorariaMaxAggregateOutputType = {
    id_sensor_instalado: number | null
    fecha_hora: Date | null
    min_val: Decimal | null
    max_val: Decimal | null
    avg_val: Decimal | null
    cnt: number | null
  }

  export type ResumenLecturaHorariaCountAggregateOutputType = {
    id_sensor_instalado: number
    fecha_hora: number
    min_val: number
    max_val: number
    avg_val: number
    cnt: number
    _all: number
  }


  export type ResumenLecturaHorariaAvgAggregateInputType = {
    id_sensor_instalado?: true
    min_val?: true
    max_val?: true
    avg_val?: true
    cnt?: true
  }

  export type ResumenLecturaHorariaSumAggregateInputType = {
    id_sensor_instalado?: true
    min_val?: true
    max_val?: true
    avg_val?: true
    cnt?: true
  }

  export type ResumenLecturaHorariaMinAggregateInputType = {
    id_sensor_instalado?: true
    fecha_hora?: true
    min_val?: true
    max_val?: true
    avg_val?: true
    cnt?: true
  }

  export type ResumenLecturaHorariaMaxAggregateInputType = {
    id_sensor_instalado?: true
    fecha_hora?: true
    min_val?: true
    max_val?: true
    avg_val?: true
    cnt?: true
  }

  export type ResumenLecturaHorariaCountAggregateInputType = {
    id_sensor_instalado?: true
    fecha_hora?: true
    min_val?: true
    max_val?: true
    avg_val?: true
    cnt?: true
    _all?: true
  }

  export type ResumenLecturaHorariaAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which ResumenLecturaHoraria to aggregate.
     */
    where?: ResumenLecturaHorariaWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of ResumenLecturaHorarias to fetch.
     */
    orderBy?: ResumenLecturaHorariaOrderByWithRelationInput | ResumenLecturaHorariaOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: ResumenLecturaHorariaWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` ResumenLecturaHorarias from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` ResumenLecturaHorarias.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned ResumenLecturaHorarias
    **/
    _count?: true | ResumenLecturaHorariaCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: ResumenLecturaHorariaAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: ResumenLecturaHorariaSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: ResumenLecturaHorariaMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: ResumenLecturaHorariaMaxAggregateInputType
  }

  export type GetResumenLecturaHorariaAggregateType<T extends ResumenLecturaHorariaAggregateArgs> = {
        [P in keyof T & keyof AggregateResumenLecturaHoraria]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateResumenLecturaHoraria[P]>
      : GetScalarType<T[P], AggregateResumenLecturaHoraria[P]>
  }




  export type ResumenLecturaHorariaGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: ResumenLecturaHorariaWhereInput
    orderBy?: ResumenLecturaHorariaOrderByWithAggregationInput | ResumenLecturaHorariaOrderByWithAggregationInput[]
    by: ResumenLecturaHorariaScalarFieldEnum[] | ResumenLecturaHorariaScalarFieldEnum
    having?: ResumenLecturaHorariaScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: ResumenLecturaHorariaCountAggregateInputType | true
    _avg?: ResumenLecturaHorariaAvgAggregateInputType
    _sum?: ResumenLecturaHorariaSumAggregateInputType
    _min?: ResumenLecturaHorariaMinAggregateInputType
    _max?: ResumenLecturaHorariaMaxAggregateInputType
  }

  export type ResumenLecturaHorariaGroupByOutputType = {
    id_sensor_instalado: number
    fecha_hora: Date
    min_val: Decimal
    max_val: Decimal
    avg_val: Decimal
    cnt: number
    _count: ResumenLecturaHorariaCountAggregateOutputType | null
    _avg: ResumenLecturaHorariaAvgAggregateOutputType | null
    _sum: ResumenLecturaHorariaSumAggregateOutputType | null
    _min: ResumenLecturaHorariaMinAggregateOutputType | null
    _max: ResumenLecturaHorariaMaxAggregateOutputType | null
  }

  type GetResumenLecturaHorariaGroupByPayload<T extends ResumenLecturaHorariaGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<ResumenLecturaHorariaGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof ResumenLecturaHorariaGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], ResumenLecturaHorariaGroupByOutputType[P]>
            : GetScalarType<T[P], ResumenLecturaHorariaGroupByOutputType[P]>
        }
      >
    >


  export type ResumenLecturaHorariaSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id_sensor_instalado?: boolean
    fecha_hora?: boolean
    min_val?: boolean
    max_val?: boolean
    avg_val?: boolean
    cnt?: boolean
  }, ExtArgs["result"]["resumenLecturaHoraria"]>


  export type ResumenLecturaHorariaSelectScalar = {
    id_sensor_instalado?: boolean
    fecha_hora?: boolean
    min_val?: boolean
    max_val?: boolean
    avg_val?: boolean
    cnt?: boolean
  }


  export type $ResumenLecturaHorariaPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "ResumenLecturaHoraria"
    objects: {}
    scalars: $Extensions.GetPayloadResult<{
      id_sensor_instalado: number
      fecha_hora: Date
      min_val: Prisma.Decimal
      max_val: Prisma.Decimal
      avg_val: Prisma.Decimal
      cnt: number
    }, ExtArgs["result"]["resumenLecturaHoraria"]>
    composites: {}
  }

  type ResumenLecturaHorariaGetPayload<S extends boolean | null | undefined | ResumenLecturaHorariaDefaultArgs> = $Result.GetResult<Prisma.$ResumenLecturaHorariaPayload, S>

  type ResumenLecturaHorariaCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = 
    Omit<ResumenLecturaHorariaFindManyArgs, 'select' | 'include' | 'distinct'> & {
      select?: ResumenLecturaHorariaCountAggregateInputType | true
    }

  export interface ResumenLecturaHorariaDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['ResumenLecturaHoraria'], meta: { name: 'ResumenLecturaHoraria' } }
    /**
     * Find zero or one ResumenLecturaHoraria that matches the filter.
     * @param {ResumenLecturaHorariaFindUniqueArgs} args - Arguments to find a ResumenLecturaHoraria
     * @example
     * // Get one ResumenLecturaHoraria
     * const resumenLecturaHoraria = await prisma.resumenLecturaHoraria.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends ResumenLecturaHorariaFindUniqueArgs>(args: SelectSubset<T, ResumenLecturaHorariaFindUniqueArgs<ExtArgs>>): Prisma__ResumenLecturaHorariaClient<$Result.GetResult<Prisma.$ResumenLecturaHorariaPayload<ExtArgs>, T, "findUnique"> | null, null, ExtArgs>

    /**
     * Find one ResumenLecturaHoraria that matches the filter or throw an error with `error.code='P2025'` 
     * if no matches were found.
     * @param {ResumenLecturaHorariaFindUniqueOrThrowArgs} args - Arguments to find a ResumenLecturaHoraria
     * @example
     * // Get one ResumenLecturaHoraria
     * const resumenLecturaHoraria = await prisma.resumenLecturaHoraria.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends ResumenLecturaHorariaFindUniqueOrThrowArgs>(args: SelectSubset<T, ResumenLecturaHorariaFindUniqueOrThrowArgs<ExtArgs>>): Prisma__ResumenLecturaHorariaClient<$Result.GetResult<Prisma.$ResumenLecturaHorariaPayload<ExtArgs>, T, "findUniqueOrThrow">, never, ExtArgs>

    /**
     * Find the first ResumenLecturaHoraria that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ResumenLecturaHorariaFindFirstArgs} args - Arguments to find a ResumenLecturaHoraria
     * @example
     * // Get one ResumenLecturaHoraria
     * const resumenLecturaHoraria = await prisma.resumenLecturaHoraria.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends ResumenLecturaHorariaFindFirstArgs>(args?: SelectSubset<T, ResumenLecturaHorariaFindFirstArgs<ExtArgs>>): Prisma__ResumenLecturaHorariaClient<$Result.GetResult<Prisma.$ResumenLecturaHorariaPayload<ExtArgs>, T, "findFirst"> | null, null, ExtArgs>

    /**
     * Find the first ResumenLecturaHoraria that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ResumenLecturaHorariaFindFirstOrThrowArgs} args - Arguments to find a ResumenLecturaHoraria
     * @example
     * // Get one ResumenLecturaHoraria
     * const resumenLecturaHoraria = await prisma.resumenLecturaHoraria.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends ResumenLecturaHorariaFindFirstOrThrowArgs>(args?: SelectSubset<T, ResumenLecturaHorariaFindFirstOrThrowArgs<ExtArgs>>): Prisma__ResumenLecturaHorariaClient<$Result.GetResult<Prisma.$ResumenLecturaHorariaPayload<ExtArgs>, T, "findFirstOrThrow">, never, ExtArgs>

    /**
     * Find zero or more ResumenLecturaHorarias that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ResumenLecturaHorariaFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all ResumenLecturaHorarias
     * const resumenLecturaHorarias = await prisma.resumenLecturaHoraria.findMany()
     * 
     * // Get first 10 ResumenLecturaHorarias
     * const resumenLecturaHorarias = await prisma.resumenLecturaHoraria.findMany({ take: 10 })
     * 
     * // Only select the `id_sensor_instalado`
     * const resumenLecturaHorariaWithId_sensor_instaladoOnly = await prisma.resumenLecturaHoraria.findMany({ select: { id_sensor_instalado: true } })
     * 
     */
    findMany<T extends ResumenLecturaHorariaFindManyArgs>(args?: SelectSubset<T, ResumenLecturaHorariaFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$ResumenLecturaHorariaPayload<ExtArgs>, T, "findMany">>

    /**
     * Create a ResumenLecturaHoraria.
     * @param {ResumenLecturaHorariaCreateArgs} args - Arguments to create a ResumenLecturaHoraria.
     * @example
     * // Create one ResumenLecturaHoraria
     * const ResumenLecturaHoraria = await prisma.resumenLecturaHoraria.create({
     *   data: {
     *     // ... data to create a ResumenLecturaHoraria
     *   }
     * })
     * 
     */
    create<T extends ResumenLecturaHorariaCreateArgs>(args: SelectSubset<T, ResumenLecturaHorariaCreateArgs<ExtArgs>>): Prisma__ResumenLecturaHorariaClient<$Result.GetResult<Prisma.$ResumenLecturaHorariaPayload<ExtArgs>, T, "create">, never, ExtArgs>

    /**
     * Create many ResumenLecturaHorarias.
     * @param {ResumenLecturaHorariaCreateManyArgs} args - Arguments to create many ResumenLecturaHorarias.
     * @example
     * // Create many ResumenLecturaHorarias
     * const resumenLecturaHoraria = await prisma.resumenLecturaHoraria.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends ResumenLecturaHorariaCreateManyArgs>(args?: SelectSubset<T, ResumenLecturaHorariaCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Delete a ResumenLecturaHoraria.
     * @param {ResumenLecturaHorariaDeleteArgs} args - Arguments to delete one ResumenLecturaHoraria.
     * @example
     * // Delete one ResumenLecturaHoraria
     * const ResumenLecturaHoraria = await prisma.resumenLecturaHoraria.delete({
     *   where: {
     *     // ... filter to delete one ResumenLecturaHoraria
     *   }
     * })
     * 
     */
    delete<T extends ResumenLecturaHorariaDeleteArgs>(args: SelectSubset<T, ResumenLecturaHorariaDeleteArgs<ExtArgs>>): Prisma__ResumenLecturaHorariaClient<$Result.GetResult<Prisma.$ResumenLecturaHorariaPayload<ExtArgs>, T, "delete">, never, ExtArgs>

    /**
     * Update one ResumenLecturaHoraria.
     * @param {ResumenLecturaHorariaUpdateArgs} args - Arguments to update one ResumenLecturaHoraria.
     * @example
     * // Update one ResumenLecturaHoraria
     * const resumenLecturaHoraria = await prisma.resumenLecturaHoraria.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends ResumenLecturaHorariaUpdateArgs>(args: SelectSubset<T, ResumenLecturaHorariaUpdateArgs<ExtArgs>>): Prisma__ResumenLecturaHorariaClient<$Result.GetResult<Prisma.$ResumenLecturaHorariaPayload<ExtArgs>, T, "update">, never, ExtArgs>

    /**
     * Delete zero or more ResumenLecturaHorarias.
     * @param {ResumenLecturaHorariaDeleteManyArgs} args - Arguments to filter ResumenLecturaHorarias to delete.
     * @example
     * // Delete a few ResumenLecturaHorarias
     * const { count } = await prisma.resumenLecturaHoraria.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends ResumenLecturaHorariaDeleteManyArgs>(args?: SelectSubset<T, ResumenLecturaHorariaDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more ResumenLecturaHorarias.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ResumenLecturaHorariaUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many ResumenLecturaHorarias
     * const resumenLecturaHoraria = await prisma.resumenLecturaHoraria.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends ResumenLecturaHorariaUpdateManyArgs>(args: SelectSubset<T, ResumenLecturaHorariaUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one ResumenLecturaHoraria.
     * @param {ResumenLecturaHorariaUpsertArgs} args - Arguments to update or create a ResumenLecturaHoraria.
     * @example
     * // Update or create a ResumenLecturaHoraria
     * const resumenLecturaHoraria = await prisma.resumenLecturaHoraria.upsert({
     *   create: {
     *     // ... data to create a ResumenLecturaHoraria
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the ResumenLecturaHoraria we want to update
     *   }
     * })
     */
    upsert<T extends ResumenLecturaHorariaUpsertArgs>(args: SelectSubset<T, ResumenLecturaHorariaUpsertArgs<ExtArgs>>): Prisma__ResumenLecturaHorariaClient<$Result.GetResult<Prisma.$ResumenLecturaHorariaPayload<ExtArgs>, T, "upsert">, never, ExtArgs>


    /**
     * Count the number of ResumenLecturaHorarias.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ResumenLecturaHorariaCountArgs} args - Arguments to filter ResumenLecturaHorarias to count.
     * @example
     * // Count the number of ResumenLecturaHorarias
     * const count = await prisma.resumenLecturaHoraria.count({
     *   where: {
     *     // ... the filter for the ResumenLecturaHorarias we want to count
     *   }
     * })
    **/
    count<T extends ResumenLecturaHorariaCountArgs>(
      args?: Subset<T, ResumenLecturaHorariaCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], ResumenLecturaHorariaCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a ResumenLecturaHoraria.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ResumenLecturaHorariaAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends ResumenLecturaHorariaAggregateArgs>(args: Subset<T, ResumenLecturaHorariaAggregateArgs>): Prisma.PrismaPromise<GetResumenLecturaHorariaAggregateType<T>>

    /**
     * Group by ResumenLecturaHoraria.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ResumenLecturaHorariaGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends ResumenLecturaHorariaGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: ResumenLecturaHorariaGroupByArgs['orderBy'] }
        : { orderBy?: ResumenLecturaHorariaGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, ResumenLecturaHorariaGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetResumenLecturaHorariaGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the ResumenLecturaHoraria model
   */
  readonly fields: ResumenLecturaHorariaFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for ResumenLecturaHoraria.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__ResumenLecturaHorariaClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the ResumenLecturaHoraria model
   */ 
  interface ResumenLecturaHorariaFieldRefs {
    readonly id_sensor_instalado: FieldRef<"ResumenLecturaHoraria", 'Int'>
    readonly fecha_hora: FieldRef<"ResumenLecturaHoraria", 'DateTime'>
    readonly min_val: FieldRef<"ResumenLecturaHoraria", 'Decimal'>
    readonly max_val: FieldRef<"ResumenLecturaHoraria", 'Decimal'>
    readonly avg_val: FieldRef<"ResumenLecturaHoraria", 'Decimal'>
    readonly cnt: FieldRef<"ResumenLecturaHoraria", 'Int'>
  }
    

  // Custom InputTypes
  /**
   * ResumenLecturaHoraria findUnique
   */
  export type ResumenLecturaHorariaFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ResumenLecturaHoraria
     */
    select?: ResumenLecturaHorariaSelect<ExtArgs> | null
    /**
     * Filter, which ResumenLecturaHoraria to fetch.
     */
    where: ResumenLecturaHorariaWhereUniqueInput
  }

  /**
   * ResumenLecturaHoraria findUniqueOrThrow
   */
  export type ResumenLecturaHorariaFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ResumenLecturaHoraria
     */
    select?: ResumenLecturaHorariaSelect<ExtArgs> | null
    /**
     * Filter, which ResumenLecturaHoraria to fetch.
     */
    where: ResumenLecturaHorariaWhereUniqueInput
  }

  /**
   * ResumenLecturaHoraria findFirst
   */
  export type ResumenLecturaHorariaFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ResumenLecturaHoraria
     */
    select?: ResumenLecturaHorariaSelect<ExtArgs> | null
    /**
     * Filter, which ResumenLecturaHoraria to fetch.
     */
    where?: ResumenLecturaHorariaWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of ResumenLecturaHorarias to fetch.
     */
    orderBy?: ResumenLecturaHorariaOrderByWithRelationInput | ResumenLecturaHorariaOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for ResumenLecturaHorarias.
     */
    cursor?: ResumenLecturaHorariaWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` ResumenLecturaHorarias from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` ResumenLecturaHorarias.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of ResumenLecturaHorarias.
     */
    distinct?: ResumenLecturaHorariaScalarFieldEnum | ResumenLecturaHorariaScalarFieldEnum[]
  }

  /**
   * ResumenLecturaHoraria findFirstOrThrow
   */
  export type ResumenLecturaHorariaFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ResumenLecturaHoraria
     */
    select?: ResumenLecturaHorariaSelect<ExtArgs> | null
    /**
     * Filter, which ResumenLecturaHoraria to fetch.
     */
    where?: ResumenLecturaHorariaWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of ResumenLecturaHorarias to fetch.
     */
    orderBy?: ResumenLecturaHorariaOrderByWithRelationInput | ResumenLecturaHorariaOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for ResumenLecturaHorarias.
     */
    cursor?: ResumenLecturaHorariaWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` ResumenLecturaHorarias from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` ResumenLecturaHorarias.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of ResumenLecturaHorarias.
     */
    distinct?: ResumenLecturaHorariaScalarFieldEnum | ResumenLecturaHorariaScalarFieldEnum[]
  }

  /**
   * ResumenLecturaHoraria findMany
   */
  export type ResumenLecturaHorariaFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ResumenLecturaHoraria
     */
    select?: ResumenLecturaHorariaSelect<ExtArgs> | null
    /**
     * Filter, which ResumenLecturaHorarias to fetch.
     */
    where?: ResumenLecturaHorariaWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of ResumenLecturaHorarias to fetch.
     */
    orderBy?: ResumenLecturaHorariaOrderByWithRelationInput | ResumenLecturaHorariaOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing ResumenLecturaHorarias.
     */
    cursor?: ResumenLecturaHorariaWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` ResumenLecturaHorarias from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` ResumenLecturaHorarias.
     */
    skip?: number
    distinct?: ResumenLecturaHorariaScalarFieldEnum | ResumenLecturaHorariaScalarFieldEnum[]
  }

  /**
   * ResumenLecturaHoraria create
   */
  export type ResumenLecturaHorariaCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ResumenLecturaHoraria
     */
    select?: ResumenLecturaHorariaSelect<ExtArgs> | null
    /**
     * The data needed to create a ResumenLecturaHoraria.
     */
    data: XOR<ResumenLecturaHorariaCreateInput, ResumenLecturaHorariaUncheckedCreateInput>
  }

  /**
   * ResumenLecturaHoraria createMany
   */
  export type ResumenLecturaHorariaCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many ResumenLecturaHorarias.
     */
    data: ResumenLecturaHorariaCreateManyInput | ResumenLecturaHorariaCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * ResumenLecturaHoraria update
   */
  export type ResumenLecturaHorariaUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ResumenLecturaHoraria
     */
    select?: ResumenLecturaHorariaSelect<ExtArgs> | null
    /**
     * The data needed to update a ResumenLecturaHoraria.
     */
    data: XOR<ResumenLecturaHorariaUpdateInput, ResumenLecturaHorariaUncheckedUpdateInput>
    /**
     * Choose, which ResumenLecturaHoraria to update.
     */
    where: ResumenLecturaHorariaWhereUniqueInput
  }

  /**
   * ResumenLecturaHoraria updateMany
   */
  export type ResumenLecturaHorariaUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update ResumenLecturaHorarias.
     */
    data: XOR<ResumenLecturaHorariaUpdateManyMutationInput, ResumenLecturaHorariaUncheckedUpdateManyInput>
    /**
     * Filter which ResumenLecturaHorarias to update
     */
    where?: ResumenLecturaHorariaWhereInput
  }

  /**
   * ResumenLecturaHoraria upsert
   */
  export type ResumenLecturaHorariaUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ResumenLecturaHoraria
     */
    select?: ResumenLecturaHorariaSelect<ExtArgs> | null
    /**
     * The filter to search for the ResumenLecturaHoraria to update in case it exists.
     */
    where: ResumenLecturaHorariaWhereUniqueInput
    /**
     * In case the ResumenLecturaHoraria found by the `where` argument doesn't exist, create a new ResumenLecturaHoraria with this data.
     */
    create: XOR<ResumenLecturaHorariaCreateInput, ResumenLecturaHorariaUncheckedCreateInput>
    /**
     * In case the ResumenLecturaHoraria was found with the provided `where` argument, update it with this data.
     */
    update: XOR<ResumenLecturaHorariaUpdateInput, ResumenLecturaHorariaUncheckedUpdateInput>
  }

  /**
   * ResumenLecturaHoraria delete
   */
  export type ResumenLecturaHorariaDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ResumenLecturaHoraria
     */
    select?: ResumenLecturaHorariaSelect<ExtArgs> | null
    /**
     * Filter which ResumenLecturaHoraria to delete.
     */
    where: ResumenLecturaHorariaWhereUniqueInput
  }

  /**
   * ResumenLecturaHoraria deleteMany
   */
  export type ResumenLecturaHorariaDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which ResumenLecturaHorarias to delete
     */
    where?: ResumenLecturaHorariaWhereInput
  }

  /**
   * ResumenLecturaHoraria without action
   */
  export type ResumenLecturaHorariaDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ResumenLecturaHoraria
     */
    select?: ResumenLecturaHorariaSelect<ExtArgs> | null
  }


  /**
   * Model Promedio15min
   */

  export type AggregatePromedio15min = {
    _count: Promedio15minCountAggregateOutputType | null
    _avg: Promedio15minAvgAggregateOutputType | null
    _sum: Promedio15minSumAggregateOutputType | null
    _min: Promedio15minMinAggregateOutputType | null
    _max: Promedio15minMaxAggregateOutputType | null
  }

  export type Promedio15minAvgAggregateOutputType = {
    id_sensor_instalado: number | null
    promedio: Decimal | null
  }

  export type Promedio15minSumAggregateOutputType = {
    id_sensor_instalado: number | null
    promedio: Decimal | null
  }

  export type Promedio15minMinAggregateOutputType = {
    id_sensor_instalado: number | null
    fecha: Date | null
    hora: Date | null
    promedio: Decimal | null
    fecha_actualizacion: Date | null
  }

  export type Promedio15minMaxAggregateOutputType = {
    id_sensor_instalado: number | null
    fecha: Date | null
    hora: Date | null
    promedio: Decimal | null
    fecha_actualizacion: Date | null
  }

  export type Promedio15minCountAggregateOutputType = {
    id_sensor_instalado: number
    fecha: number
    hora: number
    promedio: number
    fecha_actualizacion: number
    _all: number
  }


  export type Promedio15minAvgAggregateInputType = {
    id_sensor_instalado?: true
    promedio?: true
  }

  export type Promedio15minSumAggregateInputType = {
    id_sensor_instalado?: true
    promedio?: true
  }

  export type Promedio15minMinAggregateInputType = {
    id_sensor_instalado?: true
    fecha?: true
    hora?: true
    promedio?: true
    fecha_actualizacion?: true
  }

  export type Promedio15minMaxAggregateInputType = {
    id_sensor_instalado?: true
    fecha?: true
    hora?: true
    promedio?: true
    fecha_actualizacion?: true
  }

  export type Promedio15minCountAggregateInputType = {
    id_sensor_instalado?: true
    fecha?: true
    hora?: true
    promedio?: true
    fecha_actualizacion?: true
    _all?: true
  }

  export type Promedio15minAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Promedio15min to aggregate.
     */
    where?: Promedio15minWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Promedio15mins to fetch.
     */
    orderBy?: Promedio15minOrderByWithRelationInput | Promedio15minOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: Promedio15minWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Promedio15mins from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Promedio15mins.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned Promedio15mins
    **/
    _count?: true | Promedio15minCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: Promedio15minAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: Promedio15minSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: Promedio15minMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: Promedio15minMaxAggregateInputType
  }

  export type GetPromedio15minAggregateType<T extends Promedio15minAggregateArgs> = {
        [P in keyof T & keyof AggregatePromedio15min]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregatePromedio15min[P]>
      : GetScalarType<T[P], AggregatePromedio15min[P]>
  }




  export type Promedio15minGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: Promedio15minWhereInput
    orderBy?: Promedio15minOrderByWithAggregationInput | Promedio15minOrderByWithAggregationInput[]
    by: Promedio15minScalarFieldEnum[] | Promedio15minScalarFieldEnum
    having?: Promedio15minScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: Promedio15minCountAggregateInputType | true
    _avg?: Promedio15minAvgAggregateInputType
    _sum?: Promedio15minSumAggregateInputType
    _min?: Promedio15minMinAggregateInputType
    _max?: Promedio15minMaxAggregateInputType
  }

  export type Promedio15minGroupByOutputType = {
    id_sensor_instalado: number
    fecha: Date
    hora: Date
    promedio: Decimal
    fecha_actualizacion: Date
    _count: Promedio15minCountAggregateOutputType | null
    _avg: Promedio15minAvgAggregateOutputType | null
    _sum: Promedio15minSumAggregateOutputType | null
    _min: Promedio15minMinAggregateOutputType | null
    _max: Promedio15minMaxAggregateOutputType | null
  }

  type GetPromedio15minGroupByPayload<T extends Promedio15minGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<Promedio15minGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof Promedio15minGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], Promedio15minGroupByOutputType[P]>
            : GetScalarType<T[P], Promedio15minGroupByOutputType[P]>
        }
      >
    >


  export type Promedio15minSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id_sensor_instalado?: boolean
    fecha?: boolean
    hora?: boolean
    promedio?: boolean
    fecha_actualizacion?: boolean
  }, ExtArgs["result"]["promedio15min"]>


  export type Promedio15minSelectScalar = {
    id_sensor_instalado?: boolean
    fecha?: boolean
    hora?: boolean
    promedio?: boolean
    fecha_actualizacion?: boolean
  }


  export type $Promedio15minPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "Promedio15min"
    objects: {}
    scalars: $Extensions.GetPayloadResult<{
      id_sensor_instalado: number
      fecha: Date
      hora: Date
      promedio: Prisma.Decimal
      fecha_actualizacion: Date
    }, ExtArgs["result"]["promedio15min"]>
    composites: {}
  }

  type Promedio15minGetPayload<S extends boolean | null | undefined | Promedio15minDefaultArgs> = $Result.GetResult<Prisma.$Promedio15minPayload, S>

  type Promedio15minCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = 
    Omit<Promedio15minFindManyArgs, 'select' | 'include' | 'distinct'> & {
      select?: Promedio15minCountAggregateInputType | true
    }

  export interface Promedio15minDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['Promedio15min'], meta: { name: 'Promedio15min' } }
    /**
     * Find zero or one Promedio15min that matches the filter.
     * @param {Promedio15minFindUniqueArgs} args - Arguments to find a Promedio15min
     * @example
     * // Get one Promedio15min
     * const promedio15min = await prisma.promedio15min.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends Promedio15minFindUniqueArgs>(args: SelectSubset<T, Promedio15minFindUniqueArgs<ExtArgs>>): Prisma__Promedio15minClient<$Result.GetResult<Prisma.$Promedio15minPayload<ExtArgs>, T, "findUnique"> | null, null, ExtArgs>

    /**
     * Find one Promedio15min that matches the filter or throw an error with `error.code='P2025'` 
     * if no matches were found.
     * @param {Promedio15minFindUniqueOrThrowArgs} args - Arguments to find a Promedio15min
     * @example
     * // Get one Promedio15min
     * const promedio15min = await prisma.promedio15min.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends Promedio15minFindUniqueOrThrowArgs>(args: SelectSubset<T, Promedio15minFindUniqueOrThrowArgs<ExtArgs>>): Prisma__Promedio15minClient<$Result.GetResult<Prisma.$Promedio15minPayload<ExtArgs>, T, "findUniqueOrThrow">, never, ExtArgs>

    /**
     * Find the first Promedio15min that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {Promedio15minFindFirstArgs} args - Arguments to find a Promedio15min
     * @example
     * // Get one Promedio15min
     * const promedio15min = await prisma.promedio15min.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends Promedio15minFindFirstArgs>(args?: SelectSubset<T, Promedio15minFindFirstArgs<ExtArgs>>): Prisma__Promedio15minClient<$Result.GetResult<Prisma.$Promedio15minPayload<ExtArgs>, T, "findFirst"> | null, null, ExtArgs>

    /**
     * Find the first Promedio15min that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {Promedio15minFindFirstOrThrowArgs} args - Arguments to find a Promedio15min
     * @example
     * // Get one Promedio15min
     * const promedio15min = await prisma.promedio15min.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends Promedio15minFindFirstOrThrowArgs>(args?: SelectSubset<T, Promedio15minFindFirstOrThrowArgs<ExtArgs>>): Prisma__Promedio15minClient<$Result.GetResult<Prisma.$Promedio15minPayload<ExtArgs>, T, "findFirstOrThrow">, never, ExtArgs>

    /**
     * Find zero or more Promedio15mins that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {Promedio15minFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Promedio15mins
     * const promedio15mins = await prisma.promedio15min.findMany()
     * 
     * // Get first 10 Promedio15mins
     * const promedio15mins = await prisma.promedio15min.findMany({ take: 10 })
     * 
     * // Only select the `id_sensor_instalado`
     * const promedio15minWithId_sensor_instaladoOnly = await prisma.promedio15min.findMany({ select: { id_sensor_instalado: true } })
     * 
     */
    findMany<T extends Promedio15minFindManyArgs>(args?: SelectSubset<T, Promedio15minFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$Promedio15minPayload<ExtArgs>, T, "findMany">>

    /**
     * Create a Promedio15min.
     * @param {Promedio15minCreateArgs} args - Arguments to create a Promedio15min.
     * @example
     * // Create one Promedio15min
     * const Promedio15min = await prisma.promedio15min.create({
     *   data: {
     *     // ... data to create a Promedio15min
     *   }
     * })
     * 
     */
    create<T extends Promedio15minCreateArgs>(args: SelectSubset<T, Promedio15minCreateArgs<ExtArgs>>): Prisma__Promedio15minClient<$Result.GetResult<Prisma.$Promedio15minPayload<ExtArgs>, T, "create">, never, ExtArgs>

    /**
     * Create many Promedio15mins.
     * @param {Promedio15minCreateManyArgs} args - Arguments to create many Promedio15mins.
     * @example
     * // Create many Promedio15mins
     * const promedio15min = await prisma.promedio15min.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends Promedio15minCreateManyArgs>(args?: SelectSubset<T, Promedio15minCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Delete a Promedio15min.
     * @param {Promedio15minDeleteArgs} args - Arguments to delete one Promedio15min.
     * @example
     * // Delete one Promedio15min
     * const Promedio15min = await prisma.promedio15min.delete({
     *   where: {
     *     // ... filter to delete one Promedio15min
     *   }
     * })
     * 
     */
    delete<T extends Promedio15minDeleteArgs>(args: SelectSubset<T, Promedio15minDeleteArgs<ExtArgs>>): Prisma__Promedio15minClient<$Result.GetResult<Prisma.$Promedio15minPayload<ExtArgs>, T, "delete">, never, ExtArgs>

    /**
     * Update one Promedio15min.
     * @param {Promedio15minUpdateArgs} args - Arguments to update one Promedio15min.
     * @example
     * // Update one Promedio15min
     * const promedio15min = await prisma.promedio15min.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends Promedio15minUpdateArgs>(args: SelectSubset<T, Promedio15minUpdateArgs<ExtArgs>>): Prisma__Promedio15minClient<$Result.GetResult<Prisma.$Promedio15minPayload<ExtArgs>, T, "update">, never, ExtArgs>

    /**
     * Delete zero or more Promedio15mins.
     * @param {Promedio15minDeleteManyArgs} args - Arguments to filter Promedio15mins to delete.
     * @example
     * // Delete a few Promedio15mins
     * const { count } = await prisma.promedio15min.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends Promedio15minDeleteManyArgs>(args?: SelectSubset<T, Promedio15minDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Promedio15mins.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {Promedio15minUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Promedio15mins
     * const promedio15min = await prisma.promedio15min.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends Promedio15minUpdateManyArgs>(args: SelectSubset<T, Promedio15minUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one Promedio15min.
     * @param {Promedio15minUpsertArgs} args - Arguments to update or create a Promedio15min.
     * @example
     * // Update or create a Promedio15min
     * const promedio15min = await prisma.promedio15min.upsert({
     *   create: {
     *     // ... data to create a Promedio15min
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Promedio15min we want to update
     *   }
     * })
     */
    upsert<T extends Promedio15minUpsertArgs>(args: SelectSubset<T, Promedio15minUpsertArgs<ExtArgs>>): Prisma__Promedio15minClient<$Result.GetResult<Prisma.$Promedio15minPayload<ExtArgs>, T, "upsert">, never, ExtArgs>


    /**
     * Count the number of Promedio15mins.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {Promedio15minCountArgs} args - Arguments to filter Promedio15mins to count.
     * @example
     * // Count the number of Promedio15mins
     * const count = await prisma.promedio15min.count({
     *   where: {
     *     // ... the filter for the Promedio15mins we want to count
     *   }
     * })
    **/
    count<T extends Promedio15minCountArgs>(
      args?: Subset<T, Promedio15minCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], Promedio15minCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Promedio15min.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {Promedio15minAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends Promedio15minAggregateArgs>(args: Subset<T, Promedio15minAggregateArgs>): Prisma.PrismaPromise<GetPromedio15minAggregateType<T>>

    /**
     * Group by Promedio15min.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {Promedio15minGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends Promedio15minGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: Promedio15minGroupByArgs['orderBy'] }
        : { orderBy?: Promedio15minGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, Promedio15minGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetPromedio15minGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the Promedio15min model
   */
  readonly fields: Promedio15minFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for Promedio15min.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__Promedio15minClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the Promedio15min model
   */ 
  interface Promedio15minFieldRefs {
    readonly id_sensor_instalado: FieldRef<"Promedio15min", 'Int'>
    readonly fecha: FieldRef<"Promedio15min", 'DateTime'>
    readonly hora: FieldRef<"Promedio15min", 'DateTime'>
    readonly promedio: FieldRef<"Promedio15min", 'Decimal'>
    readonly fecha_actualizacion: FieldRef<"Promedio15min", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * Promedio15min findUnique
   */
  export type Promedio15minFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Promedio15min
     */
    select?: Promedio15minSelect<ExtArgs> | null
    /**
     * Filter, which Promedio15min to fetch.
     */
    where: Promedio15minWhereUniqueInput
  }

  /**
   * Promedio15min findUniqueOrThrow
   */
  export type Promedio15minFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Promedio15min
     */
    select?: Promedio15minSelect<ExtArgs> | null
    /**
     * Filter, which Promedio15min to fetch.
     */
    where: Promedio15minWhereUniqueInput
  }

  /**
   * Promedio15min findFirst
   */
  export type Promedio15minFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Promedio15min
     */
    select?: Promedio15minSelect<ExtArgs> | null
    /**
     * Filter, which Promedio15min to fetch.
     */
    where?: Promedio15minWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Promedio15mins to fetch.
     */
    orderBy?: Promedio15minOrderByWithRelationInput | Promedio15minOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Promedio15mins.
     */
    cursor?: Promedio15minWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Promedio15mins from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Promedio15mins.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Promedio15mins.
     */
    distinct?: Promedio15minScalarFieldEnum | Promedio15minScalarFieldEnum[]
  }

  /**
   * Promedio15min findFirstOrThrow
   */
  export type Promedio15minFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Promedio15min
     */
    select?: Promedio15minSelect<ExtArgs> | null
    /**
     * Filter, which Promedio15min to fetch.
     */
    where?: Promedio15minWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Promedio15mins to fetch.
     */
    orderBy?: Promedio15minOrderByWithRelationInput | Promedio15minOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Promedio15mins.
     */
    cursor?: Promedio15minWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Promedio15mins from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Promedio15mins.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Promedio15mins.
     */
    distinct?: Promedio15minScalarFieldEnum | Promedio15minScalarFieldEnum[]
  }

  /**
   * Promedio15min findMany
   */
  export type Promedio15minFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Promedio15min
     */
    select?: Promedio15minSelect<ExtArgs> | null
    /**
     * Filter, which Promedio15mins to fetch.
     */
    where?: Promedio15minWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Promedio15mins to fetch.
     */
    orderBy?: Promedio15minOrderByWithRelationInput | Promedio15minOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing Promedio15mins.
     */
    cursor?: Promedio15minWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Promedio15mins from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Promedio15mins.
     */
    skip?: number
    distinct?: Promedio15minScalarFieldEnum | Promedio15minScalarFieldEnum[]
  }

  /**
   * Promedio15min create
   */
  export type Promedio15minCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Promedio15min
     */
    select?: Promedio15minSelect<ExtArgs> | null
    /**
     * The data needed to create a Promedio15min.
     */
    data: XOR<Promedio15minCreateInput, Promedio15minUncheckedCreateInput>
  }

  /**
   * Promedio15min createMany
   */
  export type Promedio15minCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many Promedio15mins.
     */
    data: Promedio15minCreateManyInput | Promedio15minCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * Promedio15min update
   */
  export type Promedio15minUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Promedio15min
     */
    select?: Promedio15minSelect<ExtArgs> | null
    /**
     * The data needed to update a Promedio15min.
     */
    data: XOR<Promedio15minUpdateInput, Promedio15minUncheckedUpdateInput>
    /**
     * Choose, which Promedio15min to update.
     */
    where: Promedio15minWhereUniqueInput
  }

  /**
   * Promedio15min updateMany
   */
  export type Promedio15minUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update Promedio15mins.
     */
    data: XOR<Promedio15minUpdateManyMutationInput, Promedio15minUncheckedUpdateManyInput>
    /**
     * Filter which Promedio15mins to update
     */
    where?: Promedio15minWhereInput
  }

  /**
   * Promedio15min upsert
   */
  export type Promedio15minUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Promedio15min
     */
    select?: Promedio15minSelect<ExtArgs> | null
    /**
     * The filter to search for the Promedio15min to update in case it exists.
     */
    where: Promedio15minWhereUniqueInput
    /**
     * In case the Promedio15min found by the `where` argument doesn't exist, create a new Promedio15min with this data.
     */
    create: XOR<Promedio15minCreateInput, Promedio15minUncheckedCreateInput>
    /**
     * In case the Promedio15min was found with the provided `where` argument, update it with this data.
     */
    update: XOR<Promedio15minUpdateInput, Promedio15minUncheckedUpdateInput>
  }

  /**
   * Promedio15min delete
   */
  export type Promedio15minDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Promedio15min
     */
    select?: Promedio15minSelect<ExtArgs> | null
    /**
     * Filter which Promedio15min to delete.
     */
    where: Promedio15minWhereUniqueInput
  }

  /**
   * Promedio15min deleteMany
   */
  export type Promedio15minDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Promedio15mins to delete
     */
    where?: Promedio15minWhereInput
  }

  /**
   * Promedio15min without action
   */
  export type Promedio15minDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Promedio15min
     */
    select?: Promedio15minSelect<ExtArgs> | null
  }


  /**
   * Model Estado
   */

  export type AggregateEstado = {
    _count: EstadoCountAggregateOutputType | null
    _avg: EstadoAvgAggregateOutputType | null
    _sum: EstadoSumAggregateOutputType | null
    _min: EstadoMinAggregateOutputType | null
    _max: EstadoMaxAggregateOutputType | null
  }

  export type EstadoAvgAggregateOutputType = {
    id_estado: number | null
  }

  export type EstadoSumAggregateOutputType = {
    id_estado: number | null
  }

  export type EstadoMinAggregateOutputType = {
    id_estado: number | null
    nombre: string | null
    codigo: string | null
  }

  export type EstadoMaxAggregateOutputType = {
    id_estado: number | null
    nombre: string | null
    codigo: string | null
  }

  export type EstadoCountAggregateOutputType = {
    id_estado: number
    nombre: number
    codigo: number
    _all: number
  }


  export type EstadoAvgAggregateInputType = {
    id_estado?: true
  }

  export type EstadoSumAggregateInputType = {
    id_estado?: true
  }

  export type EstadoMinAggregateInputType = {
    id_estado?: true
    nombre?: true
    codigo?: true
  }

  export type EstadoMaxAggregateInputType = {
    id_estado?: true
    nombre?: true
    codigo?: true
  }

  export type EstadoCountAggregateInputType = {
    id_estado?: true
    nombre?: true
    codigo?: true
    _all?: true
  }

  export type EstadoAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Estado to aggregate.
     */
    where?: EstadoWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Estados to fetch.
     */
    orderBy?: EstadoOrderByWithRelationInput | EstadoOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: EstadoWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Estados from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Estados.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned Estados
    **/
    _count?: true | EstadoCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: EstadoAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: EstadoSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: EstadoMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: EstadoMaxAggregateInputType
  }

  export type GetEstadoAggregateType<T extends EstadoAggregateArgs> = {
        [P in keyof T & keyof AggregateEstado]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateEstado[P]>
      : GetScalarType<T[P], AggregateEstado[P]>
  }




  export type EstadoGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: EstadoWhereInput
    orderBy?: EstadoOrderByWithAggregationInput | EstadoOrderByWithAggregationInput[]
    by: EstadoScalarFieldEnum[] | EstadoScalarFieldEnum
    having?: EstadoScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: EstadoCountAggregateInputType | true
    _avg?: EstadoAvgAggregateInputType
    _sum?: EstadoSumAggregateInputType
    _min?: EstadoMinAggregateInputType
    _max?: EstadoMaxAggregateInputType
  }

  export type EstadoGroupByOutputType = {
    id_estado: number
    nombre: string
    codigo: string
    _count: EstadoCountAggregateOutputType | null
    _avg: EstadoAvgAggregateOutputType | null
    _sum: EstadoSumAggregateOutputType | null
    _min: EstadoMinAggregateOutputType | null
    _max: EstadoMaxAggregateOutputType | null
  }

  type GetEstadoGroupByPayload<T extends EstadoGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<EstadoGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof EstadoGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], EstadoGroupByOutputType[P]>
            : GetScalarType<T[P], EstadoGroupByOutputType[P]>
        }
      >
    >


  export type EstadoSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id_estado?: boolean
    nombre?: boolean
    codigo?: boolean
    municipios?: boolean | Estado$municipiosArgs<ExtArgs>
    _count?: boolean | EstadoCountOutputTypeDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["estado"]>


  export type EstadoSelectScalar = {
    id_estado?: boolean
    nombre?: boolean
    codigo?: boolean
  }

  export type EstadoInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    municipios?: boolean | Estado$municipiosArgs<ExtArgs>
    _count?: boolean | EstadoCountOutputTypeDefaultArgs<ExtArgs>
  }

  export type $EstadoPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "Estado"
    objects: {
      municipios: Prisma.$MunicipioPayload<ExtArgs>[]
    }
    scalars: $Extensions.GetPayloadResult<{
      id_estado: number
      nombre: string
      codigo: string
    }, ExtArgs["result"]["estado"]>
    composites: {}
  }

  type EstadoGetPayload<S extends boolean | null | undefined | EstadoDefaultArgs> = $Result.GetResult<Prisma.$EstadoPayload, S>

  type EstadoCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = 
    Omit<EstadoFindManyArgs, 'select' | 'include' | 'distinct'> & {
      select?: EstadoCountAggregateInputType | true
    }

  export interface EstadoDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['Estado'], meta: { name: 'Estado' } }
    /**
     * Find zero or one Estado that matches the filter.
     * @param {EstadoFindUniqueArgs} args - Arguments to find a Estado
     * @example
     * // Get one Estado
     * const estado = await prisma.estado.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends EstadoFindUniqueArgs>(args: SelectSubset<T, EstadoFindUniqueArgs<ExtArgs>>): Prisma__EstadoClient<$Result.GetResult<Prisma.$EstadoPayload<ExtArgs>, T, "findUnique"> | null, null, ExtArgs>

    /**
     * Find one Estado that matches the filter or throw an error with `error.code='P2025'` 
     * if no matches were found.
     * @param {EstadoFindUniqueOrThrowArgs} args - Arguments to find a Estado
     * @example
     * // Get one Estado
     * const estado = await prisma.estado.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends EstadoFindUniqueOrThrowArgs>(args: SelectSubset<T, EstadoFindUniqueOrThrowArgs<ExtArgs>>): Prisma__EstadoClient<$Result.GetResult<Prisma.$EstadoPayload<ExtArgs>, T, "findUniqueOrThrow">, never, ExtArgs>

    /**
     * Find the first Estado that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {EstadoFindFirstArgs} args - Arguments to find a Estado
     * @example
     * // Get one Estado
     * const estado = await prisma.estado.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends EstadoFindFirstArgs>(args?: SelectSubset<T, EstadoFindFirstArgs<ExtArgs>>): Prisma__EstadoClient<$Result.GetResult<Prisma.$EstadoPayload<ExtArgs>, T, "findFirst"> | null, null, ExtArgs>

    /**
     * Find the first Estado that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {EstadoFindFirstOrThrowArgs} args - Arguments to find a Estado
     * @example
     * // Get one Estado
     * const estado = await prisma.estado.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends EstadoFindFirstOrThrowArgs>(args?: SelectSubset<T, EstadoFindFirstOrThrowArgs<ExtArgs>>): Prisma__EstadoClient<$Result.GetResult<Prisma.$EstadoPayload<ExtArgs>, T, "findFirstOrThrow">, never, ExtArgs>

    /**
     * Find zero or more Estados that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {EstadoFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Estados
     * const estados = await prisma.estado.findMany()
     * 
     * // Get first 10 Estados
     * const estados = await prisma.estado.findMany({ take: 10 })
     * 
     * // Only select the `id_estado`
     * const estadoWithId_estadoOnly = await prisma.estado.findMany({ select: { id_estado: true } })
     * 
     */
    findMany<T extends EstadoFindManyArgs>(args?: SelectSubset<T, EstadoFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$EstadoPayload<ExtArgs>, T, "findMany">>

    /**
     * Create a Estado.
     * @param {EstadoCreateArgs} args - Arguments to create a Estado.
     * @example
     * // Create one Estado
     * const Estado = await prisma.estado.create({
     *   data: {
     *     // ... data to create a Estado
     *   }
     * })
     * 
     */
    create<T extends EstadoCreateArgs>(args: SelectSubset<T, EstadoCreateArgs<ExtArgs>>): Prisma__EstadoClient<$Result.GetResult<Prisma.$EstadoPayload<ExtArgs>, T, "create">, never, ExtArgs>

    /**
     * Create many Estados.
     * @param {EstadoCreateManyArgs} args - Arguments to create many Estados.
     * @example
     * // Create many Estados
     * const estado = await prisma.estado.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends EstadoCreateManyArgs>(args?: SelectSubset<T, EstadoCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Delete a Estado.
     * @param {EstadoDeleteArgs} args - Arguments to delete one Estado.
     * @example
     * // Delete one Estado
     * const Estado = await prisma.estado.delete({
     *   where: {
     *     // ... filter to delete one Estado
     *   }
     * })
     * 
     */
    delete<T extends EstadoDeleteArgs>(args: SelectSubset<T, EstadoDeleteArgs<ExtArgs>>): Prisma__EstadoClient<$Result.GetResult<Prisma.$EstadoPayload<ExtArgs>, T, "delete">, never, ExtArgs>

    /**
     * Update one Estado.
     * @param {EstadoUpdateArgs} args - Arguments to update one Estado.
     * @example
     * // Update one Estado
     * const estado = await prisma.estado.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends EstadoUpdateArgs>(args: SelectSubset<T, EstadoUpdateArgs<ExtArgs>>): Prisma__EstadoClient<$Result.GetResult<Prisma.$EstadoPayload<ExtArgs>, T, "update">, never, ExtArgs>

    /**
     * Delete zero or more Estados.
     * @param {EstadoDeleteManyArgs} args - Arguments to filter Estados to delete.
     * @example
     * // Delete a few Estados
     * const { count } = await prisma.estado.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends EstadoDeleteManyArgs>(args?: SelectSubset<T, EstadoDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Estados.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {EstadoUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Estados
     * const estado = await prisma.estado.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends EstadoUpdateManyArgs>(args: SelectSubset<T, EstadoUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one Estado.
     * @param {EstadoUpsertArgs} args - Arguments to update or create a Estado.
     * @example
     * // Update or create a Estado
     * const estado = await prisma.estado.upsert({
     *   create: {
     *     // ... data to create a Estado
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Estado we want to update
     *   }
     * })
     */
    upsert<T extends EstadoUpsertArgs>(args: SelectSubset<T, EstadoUpsertArgs<ExtArgs>>): Prisma__EstadoClient<$Result.GetResult<Prisma.$EstadoPayload<ExtArgs>, T, "upsert">, never, ExtArgs>


    /**
     * Count the number of Estados.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {EstadoCountArgs} args - Arguments to filter Estados to count.
     * @example
     * // Count the number of Estados
     * const count = await prisma.estado.count({
     *   where: {
     *     // ... the filter for the Estados we want to count
     *   }
     * })
    **/
    count<T extends EstadoCountArgs>(
      args?: Subset<T, EstadoCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], EstadoCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Estado.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {EstadoAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends EstadoAggregateArgs>(args: Subset<T, EstadoAggregateArgs>): Prisma.PrismaPromise<GetEstadoAggregateType<T>>

    /**
     * Group by Estado.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {EstadoGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends EstadoGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: EstadoGroupByArgs['orderBy'] }
        : { orderBy?: EstadoGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, EstadoGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetEstadoGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the Estado model
   */
  readonly fields: EstadoFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for Estado.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__EstadoClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    municipios<T extends Estado$municipiosArgs<ExtArgs> = {}>(args?: Subset<T, Estado$municipiosArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$MunicipioPayload<ExtArgs>, T, "findMany"> | Null>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the Estado model
   */ 
  interface EstadoFieldRefs {
    readonly id_estado: FieldRef<"Estado", 'Int'>
    readonly nombre: FieldRef<"Estado", 'String'>
    readonly codigo: FieldRef<"Estado", 'String'>
  }
    

  // Custom InputTypes
  /**
   * Estado findUnique
   */
  export type EstadoFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Estado
     */
    select?: EstadoSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: EstadoInclude<ExtArgs> | null
    /**
     * Filter, which Estado to fetch.
     */
    where: EstadoWhereUniqueInput
  }

  /**
   * Estado findUniqueOrThrow
   */
  export type EstadoFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Estado
     */
    select?: EstadoSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: EstadoInclude<ExtArgs> | null
    /**
     * Filter, which Estado to fetch.
     */
    where: EstadoWhereUniqueInput
  }

  /**
   * Estado findFirst
   */
  export type EstadoFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Estado
     */
    select?: EstadoSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: EstadoInclude<ExtArgs> | null
    /**
     * Filter, which Estado to fetch.
     */
    where?: EstadoWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Estados to fetch.
     */
    orderBy?: EstadoOrderByWithRelationInput | EstadoOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Estados.
     */
    cursor?: EstadoWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Estados from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Estados.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Estados.
     */
    distinct?: EstadoScalarFieldEnum | EstadoScalarFieldEnum[]
  }

  /**
   * Estado findFirstOrThrow
   */
  export type EstadoFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Estado
     */
    select?: EstadoSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: EstadoInclude<ExtArgs> | null
    /**
     * Filter, which Estado to fetch.
     */
    where?: EstadoWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Estados to fetch.
     */
    orderBy?: EstadoOrderByWithRelationInput | EstadoOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Estados.
     */
    cursor?: EstadoWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Estados from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Estados.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Estados.
     */
    distinct?: EstadoScalarFieldEnum | EstadoScalarFieldEnum[]
  }

  /**
   * Estado findMany
   */
  export type EstadoFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Estado
     */
    select?: EstadoSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: EstadoInclude<ExtArgs> | null
    /**
     * Filter, which Estados to fetch.
     */
    where?: EstadoWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Estados to fetch.
     */
    orderBy?: EstadoOrderByWithRelationInput | EstadoOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing Estados.
     */
    cursor?: EstadoWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Estados from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Estados.
     */
    skip?: number
    distinct?: EstadoScalarFieldEnum | EstadoScalarFieldEnum[]
  }

  /**
   * Estado create
   */
  export type EstadoCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Estado
     */
    select?: EstadoSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: EstadoInclude<ExtArgs> | null
    /**
     * The data needed to create a Estado.
     */
    data: XOR<EstadoCreateInput, EstadoUncheckedCreateInput>
  }

  /**
   * Estado createMany
   */
  export type EstadoCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many Estados.
     */
    data: EstadoCreateManyInput | EstadoCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * Estado update
   */
  export type EstadoUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Estado
     */
    select?: EstadoSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: EstadoInclude<ExtArgs> | null
    /**
     * The data needed to update a Estado.
     */
    data: XOR<EstadoUpdateInput, EstadoUncheckedUpdateInput>
    /**
     * Choose, which Estado to update.
     */
    where: EstadoWhereUniqueInput
  }

  /**
   * Estado updateMany
   */
  export type EstadoUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update Estados.
     */
    data: XOR<EstadoUpdateManyMutationInput, EstadoUncheckedUpdateManyInput>
    /**
     * Filter which Estados to update
     */
    where?: EstadoWhereInput
  }

  /**
   * Estado upsert
   */
  export type EstadoUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Estado
     */
    select?: EstadoSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: EstadoInclude<ExtArgs> | null
    /**
     * The filter to search for the Estado to update in case it exists.
     */
    where: EstadoWhereUniqueInput
    /**
     * In case the Estado found by the `where` argument doesn't exist, create a new Estado with this data.
     */
    create: XOR<EstadoCreateInput, EstadoUncheckedCreateInput>
    /**
     * In case the Estado was found with the provided `where` argument, update it with this data.
     */
    update: XOR<EstadoUpdateInput, EstadoUncheckedUpdateInput>
  }

  /**
   * Estado delete
   */
  export type EstadoDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Estado
     */
    select?: EstadoSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: EstadoInclude<ExtArgs> | null
    /**
     * Filter which Estado to delete.
     */
    where: EstadoWhereUniqueInput
  }

  /**
   * Estado deleteMany
   */
  export type EstadoDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Estados to delete
     */
    where?: EstadoWhereInput
  }

  /**
   * Estado.municipios
   */
  export type Estado$municipiosArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Municipio
     */
    select?: MunicipioSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: MunicipioInclude<ExtArgs> | null
    where?: MunicipioWhereInput
    orderBy?: MunicipioOrderByWithRelationInput | MunicipioOrderByWithRelationInput[]
    cursor?: MunicipioWhereUniqueInput
    take?: number
    skip?: number
    distinct?: MunicipioScalarFieldEnum | MunicipioScalarFieldEnum[]
  }

  /**
   * Estado without action
   */
  export type EstadoDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Estado
     */
    select?: EstadoSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: EstadoInclude<ExtArgs> | null
  }


  /**
   * Model Municipio
   */

  export type AggregateMunicipio = {
    _count: MunicipioCountAggregateOutputType | null
    _avg: MunicipioAvgAggregateOutputType | null
    _sum: MunicipioSumAggregateOutputType | null
    _min: MunicipioMinAggregateOutputType | null
    _max: MunicipioMaxAggregateOutputType | null
  }

  export type MunicipioAvgAggregateOutputType = {
    id_municipio: number | null
    id_estado: number | null
  }

  export type MunicipioSumAggregateOutputType = {
    id_municipio: number | null
    id_estado: number | null
  }

  export type MunicipioMinAggregateOutputType = {
    id_municipio: number | null
    id_estado: number | null
    nombre: string | null
  }

  export type MunicipioMaxAggregateOutputType = {
    id_municipio: number | null
    id_estado: number | null
    nombre: string | null
  }

  export type MunicipioCountAggregateOutputType = {
    id_municipio: number
    id_estado: number
    nombre: number
    _all: number
  }


  export type MunicipioAvgAggregateInputType = {
    id_municipio?: true
    id_estado?: true
  }

  export type MunicipioSumAggregateInputType = {
    id_municipio?: true
    id_estado?: true
  }

  export type MunicipioMinAggregateInputType = {
    id_municipio?: true
    id_estado?: true
    nombre?: true
  }

  export type MunicipioMaxAggregateInputType = {
    id_municipio?: true
    id_estado?: true
    nombre?: true
  }

  export type MunicipioCountAggregateInputType = {
    id_municipio?: true
    id_estado?: true
    nombre?: true
    _all?: true
  }

  export type MunicipioAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Municipio to aggregate.
     */
    where?: MunicipioWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Municipios to fetch.
     */
    orderBy?: MunicipioOrderByWithRelationInput | MunicipioOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: MunicipioWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Municipios from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Municipios.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned Municipios
    **/
    _count?: true | MunicipioCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: MunicipioAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: MunicipioSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: MunicipioMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: MunicipioMaxAggregateInputType
  }

  export type GetMunicipioAggregateType<T extends MunicipioAggregateArgs> = {
        [P in keyof T & keyof AggregateMunicipio]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateMunicipio[P]>
      : GetScalarType<T[P], AggregateMunicipio[P]>
  }




  export type MunicipioGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: MunicipioWhereInput
    orderBy?: MunicipioOrderByWithAggregationInput | MunicipioOrderByWithAggregationInput[]
    by: MunicipioScalarFieldEnum[] | MunicipioScalarFieldEnum
    having?: MunicipioScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: MunicipioCountAggregateInputType | true
    _avg?: MunicipioAvgAggregateInputType
    _sum?: MunicipioSumAggregateInputType
    _min?: MunicipioMinAggregateInputType
    _max?: MunicipioMaxAggregateInputType
  }

  export type MunicipioGroupByOutputType = {
    id_municipio: number
    id_estado: number
    nombre: string
    _count: MunicipioCountAggregateOutputType | null
    _avg: MunicipioAvgAggregateOutputType | null
    _sum: MunicipioSumAggregateOutputType | null
    _min: MunicipioMinAggregateOutputType | null
    _max: MunicipioMaxAggregateOutputType | null
  }

  type GetMunicipioGroupByPayload<T extends MunicipioGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<MunicipioGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof MunicipioGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], MunicipioGroupByOutputType[P]>
            : GetScalarType<T[P], MunicipioGroupByOutputType[P]>
        }
      >
    >


  export type MunicipioSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id_municipio?: boolean
    id_estado?: boolean
    nombre?: boolean
    estado?: boolean | EstadoDefaultArgs<ExtArgs>
    codigosPostales?: boolean | Municipio$codigosPostalesArgs<ExtArgs>
    _count?: boolean | MunicipioCountOutputTypeDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["municipio"]>


  export type MunicipioSelectScalar = {
    id_municipio?: boolean
    id_estado?: boolean
    nombre?: boolean
  }

  export type MunicipioInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    estado?: boolean | EstadoDefaultArgs<ExtArgs>
    codigosPostales?: boolean | Municipio$codigosPostalesArgs<ExtArgs>
    _count?: boolean | MunicipioCountOutputTypeDefaultArgs<ExtArgs>
  }

  export type $MunicipioPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "Municipio"
    objects: {
      estado: Prisma.$EstadoPayload<ExtArgs>
      codigosPostales: Prisma.$CodigoPostalPayload<ExtArgs>[]
    }
    scalars: $Extensions.GetPayloadResult<{
      id_municipio: number
      id_estado: number
      nombre: string
    }, ExtArgs["result"]["municipio"]>
    composites: {}
  }

  type MunicipioGetPayload<S extends boolean | null | undefined | MunicipioDefaultArgs> = $Result.GetResult<Prisma.$MunicipioPayload, S>

  type MunicipioCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = 
    Omit<MunicipioFindManyArgs, 'select' | 'include' | 'distinct'> & {
      select?: MunicipioCountAggregateInputType | true
    }

  export interface MunicipioDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['Municipio'], meta: { name: 'Municipio' } }
    /**
     * Find zero or one Municipio that matches the filter.
     * @param {MunicipioFindUniqueArgs} args - Arguments to find a Municipio
     * @example
     * // Get one Municipio
     * const municipio = await prisma.municipio.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends MunicipioFindUniqueArgs>(args: SelectSubset<T, MunicipioFindUniqueArgs<ExtArgs>>): Prisma__MunicipioClient<$Result.GetResult<Prisma.$MunicipioPayload<ExtArgs>, T, "findUnique"> | null, null, ExtArgs>

    /**
     * Find one Municipio that matches the filter or throw an error with `error.code='P2025'` 
     * if no matches were found.
     * @param {MunicipioFindUniqueOrThrowArgs} args - Arguments to find a Municipio
     * @example
     * // Get one Municipio
     * const municipio = await prisma.municipio.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends MunicipioFindUniqueOrThrowArgs>(args: SelectSubset<T, MunicipioFindUniqueOrThrowArgs<ExtArgs>>): Prisma__MunicipioClient<$Result.GetResult<Prisma.$MunicipioPayload<ExtArgs>, T, "findUniqueOrThrow">, never, ExtArgs>

    /**
     * Find the first Municipio that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {MunicipioFindFirstArgs} args - Arguments to find a Municipio
     * @example
     * // Get one Municipio
     * const municipio = await prisma.municipio.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends MunicipioFindFirstArgs>(args?: SelectSubset<T, MunicipioFindFirstArgs<ExtArgs>>): Prisma__MunicipioClient<$Result.GetResult<Prisma.$MunicipioPayload<ExtArgs>, T, "findFirst"> | null, null, ExtArgs>

    /**
     * Find the first Municipio that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {MunicipioFindFirstOrThrowArgs} args - Arguments to find a Municipio
     * @example
     * // Get one Municipio
     * const municipio = await prisma.municipio.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends MunicipioFindFirstOrThrowArgs>(args?: SelectSubset<T, MunicipioFindFirstOrThrowArgs<ExtArgs>>): Prisma__MunicipioClient<$Result.GetResult<Prisma.$MunicipioPayload<ExtArgs>, T, "findFirstOrThrow">, never, ExtArgs>

    /**
     * Find zero or more Municipios that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {MunicipioFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Municipios
     * const municipios = await prisma.municipio.findMany()
     * 
     * // Get first 10 Municipios
     * const municipios = await prisma.municipio.findMany({ take: 10 })
     * 
     * // Only select the `id_municipio`
     * const municipioWithId_municipioOnly = await prisma.municipio.findMany({ select: { id_municipio: true } })
     * 
     */
    findMany<T extends MunicipioFindManyArgs>(args?: SelectSubset<T, MunicipioFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$MunicipioPayload<ExtArgs>, T, "findMany">>

    /**
     * Create a Municipio.
     * @param {MunicipioCreateArgs} args - Arguments to create a Municipio.
     * @example
     * // Create one Municipio
     * const Municipio = await prisma.municipio.create({
     *   data: {
     *     // ... data to create a Municipio
     *   }
     * })
     * 
     */
    create<T extends MunicipioCreateArgs>(args: SelectSubset<T, MunicipioCreateArgs<ExtArgs>>): Prisma__MunicipioClient<$Result.GetResult<Prisma.$MunicipioPayload<ExtArgs>, T, "create">, never, ExtArgs>

    /**
     * Create many Municipios.
     * @param {MunicipioCreateManyArgs} args - Arguments to create many Municipios.
     * @example
     * // Create many Municipios
     * const municipio = await prisma.municipio.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends MunicipioCreateManyArgs>(args?: SelectSubset<T, MunicipioCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Delete a Municipio.
     * @param {MunicipioDeleteArgs} args - Arguments to delete one Municipio.
     * @example
     * // Delete one Municipio
     * const Municipio = await prisma.municipio.delete({
     *   where: {
     *     // ... filter to delete one Municipio
     *   }
     * })
     * 
     */
    delete<T extends MunicipioDeleteArgs>(args: SelectSubset<T, MunicipioDeleteArgs<ExtArgs>>): Prisma__MunicipioClient<$Result.GetResult<Prisma.$MunicipioPayload<ExtArgs>, T, "delete">, never, ExtArgs>

    /**
     * Update one Municipio.
     * @param {MunicipioUpdateArgs} args - Arguments to update one Municipio.
     * @example
     * // Update one Municipio
     * const municipio = await prisma.municipio.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends MunicipioUpdateArgs>(args: SelectSubset<T, MunicipioUpdateArgs<ExtArgs>>): Prisma__MunicipioClient<$Result.GetResult<Prisma.$MunicipioPayload<ExtArgs>, T, "update">, never, ExtArgs>

    /**
     * Delete zero or more Municipios.
     * @param {MunicipioDeleteManyArgs} args - Arguments to filter Municipios to delete.
     * @example
     * // Delete a few Municipios
     * const { count } = await prisma.municipio.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends MunicipioDeleteManyArgs>(args?: SelectSubset<T, MunicipioDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Municipios.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {MunicipioUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Municipios
     * const municipio = await prisma.municipio.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends MunicipioUpdateManyArgs>(args: SelectSubset<T, MunicipioUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one Municipio.
     * @param {MunicipioUpsertArgs} args - Arguments to update or create a Municipio.
     * @example
     * // Update or create a Municipio
     * const municipio = await prisma.municipio.upsert({
     *   create: {
     *     // ... data to create a Municipio
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Municipio we want to update
     *   }
     * })
     */
    upsert<T extends MunicipioUpsertArgs>(args: SelectSubset<T, MunicipioUpsertArgs<ExtArgs>>): Prisma__MunicipioClient<$Result.GetResult<Prisma.$MunicipioPayload<ExtArgs>, T, "upsert">, never, ExtArgs>


    /**
     * Count the number of Municipios.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {MunicipioCountArgs} args - Arguments to filter Municipios to count.
     * @example
     * // Count the number of Municipios
     * const count = await prisma.municipio.count({
     *   where: {
     *     // ... the filter for the Municipios we want to count
     *   }
     * })
    **/
    count<T extends MunicipioCountArgs>(
      args?: Subset<T, MunicipioCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], MunicipioCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Municipio.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {MunicipioAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends MunicipioAggregateArgs>(args: Subset<T, MunicipioAggregateArgs>): Prisma.PrismaPromise<GetMunicipioAggregateType<T>>

    /**
     * Group by Municipio.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {MunicipioGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends MunicipioGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: MunicipioGroupByArgs['orderBy'] }
        : { orderBy?: MunicipioGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, MunicipioGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetMunicipioGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the Municipio model
   */
  readonly fields: MunicipioFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for Municipio.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__MunicipioClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    estado<T extends EstadoDefaultArgs<ExtArgs> = {}>(args?: Subset<T, EstadoDefaultArgs<ExtArgs>>): Prisma__EstadoClient<$Result.GetResult<Prisma.$EstadoPayload<ExtArgs>, T, "findUniqueOrThrow"> | Null, Null, ExtArgs>
    codigosPostales<T extends Municipio$codigosPostalesArgs<ExtArgs> = {}>(args?: Subset<T, Municipio$codigosPostalesArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$CodigoPostalPayload<ExtArgs>, T, "findMany"> | Null>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the Municipio model
   */ 
  interface MunicipioFieldRefs {
    readonly id_municipio: FieldRef<"Municipio", 'Int'>
    readonly id_estado: FieldRef<"Municipio", 'Int'>
    readonly nombre: FieldRef<"Municipio", 'String'>
  }
    

  // Custom InputTypes
  /**
   * Municipio findUnique
   */
  export type MunicipioFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Municipio
     */
    select?: MunicipioSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: MunicipioInclude<ExtArgs> | null
    /**
     * Filter, which Municipio to fetch.
     */
    where: MunicipioWhereUniqueInput
  }

  /**
   * Municipio findUniqueOrThrow
   */
  export type MunicipioFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Municipio
     */
    select?: MunicipioSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: MunicipioInclude<ExtArgs> | null
    /**
     * Filter, which Municipio to fetch.
     */
    where: MunicipioWhereUniqueInput
  }

  /**
   * Municipio findFirst
   */
  export type MunicipioFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Municipio
     */
    select?: MunicipioSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: MunicipioInclude<ExtArgs> | null
    /**
     * Filter, which Municipio to fetch.
     */
    where?: MunicipioWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Municipios to fetch.
     */
    orderBy?: MunicipioOrderByWithRelationInput | MunicipioOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Municipios.
     */
    cursor?: MunicipioWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Municipios from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Municipios.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Municipios.
     */
    distinct?: MunicipioScalarFieldEnum | MunicipioScalarFieldEnum[]
  }

  /**
   * Municipio findFirstOrThrow
   */
  export type MunicipioFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Municipio
     */
    select?: MunicipioSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: MunicipioInclude<ExtArgs> | null
    /**
     * Filter, which Municipio to fetch.
     */
    where?: MunicipioWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Municipios to fetch.
     */
    orderBy?: MunicipioOrderByWithRelationInput | MunicipioOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Municipios.
     */
    cursor?: MunicipioWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Municipios from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Municipios.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Municipios.
     */
    distinct?: MunicipioScalarFieldEnum | MunicipioScalarFieldEnum[]
  }

  /**
   * Municipio findMany
   */
  export type MunicipioFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Municipio
     */
    select?: MunicipioSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: MunicipioInclude<ExtArgs> | null
    /**
     * Filter, which Municipios to fetch.
     */
    where?: MunicipioWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Municipios to fetch.
     */
    orderBy?: MunicipioOrderByWithRelationInput | MunicipioOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing Municipios.
     */
    cursor?: MunicipioWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Municipios from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Municipios.
     */
    skip?: number
    distinct?: MunicipioScalarFieldEnum | MunicipioScalarFieldEnum[]
  }

  /**
   * Municipio create
   */
  export type MunicipioCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Municipio
     */
    select?: MunicipioSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: MunicipioInclude<ExtArgs> | null
    /**
     * The data needed to create a Municipio.
     */
    data: XOR<MunicipioCreateInput, MunicipioUncheckedCreateInput>
  }

  /**
   * Municipio createMany
   */
  export type MunicipioCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many Municipios.
     */
    data: MunicipioCreateManyInput | MunicipioCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * Municipio update
   */
  export type MunicipioUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Municipio
     */
    select?: MunicipioSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: MunicipioInclude<ExtArgs> | null
    /**
     * The data needed to update a Municipio.
     */
    data: XOR<MunicipioUpdateInput, MunicipioUncheckedUpdateInput>
    /**
     * Choose, which Municipio to update.
     */
    where: MunicipioWhereUniqueInput
  }

  /**
   * Municipio updateMany
   */
  export type MunicipioUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update Municipios.
     */
    data: XOR<MunicipioUpdateManyMutationInput, MunicipioUncheckedUpdateManyInput>
    /**
     * Filter which Municipios to update
     */
    where?: MunicipioWhereInput
  }

  /**
   * Municipio upsert
   */
  export type MunicipioUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Municipio
     */
    select?: MunicipioSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: MunicipioInclude<ExtArgs> | null
    /**
     * The filter to search for the Municipio to update in case it exists.
     */
    where: MunicipioWhereUniqueInput
    /**
     * In case the Municipio found by the `where` argument doesn't exist, create a new Municipio with this data.
     */
    create: XOR<MunicipioCreateInput, MunicipioUncheckedCreateInput>
    /**
     * In case the Municipio was found with the provided `where` argument, update it with this data.
     */
    update: XOR<MunicipioUpdateInput, MunicipioUncheckedUpdateInput>
  }

  /**
   * Municipio delete
   */
  export type MunicipioDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Municipio
     */
    select?: MunicipioSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: MunicipioInclude<ExtArgs> | null
    /**
     * Filter which Municipio to delete.
     */
    where: MunicipioWhereUniqueInput
  }

  /**
   * Municipio deleteMany
   */
  export type MunicipioDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Municipios to delete
     */
    where?: MunicipioWhereInput
  }

  /**
   * Municipio.codigosPostales
   */
  export type Municipio$codigosPostalesArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the CodigoPostal
     */
    select?: CodigoPostalSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CodigoPostalInclude<ExtArgs> | null
    where?: CodigoPostalWhereInput
    orderBy?: CodigoPostalOrderByWithRelationInput | CodigoPostalOrderByWithRelationInput[]
    cursor?: CodigoPostalWhereUniqueInput
    take?: number
    skip?: number
    distinct?: CodigoPostalScalarFieldEnum | CodigoPostalScalarFieldEnum[]
  }

  /**
   * Municipio without action
   */
  export type MunicipioDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Municipio
     */
    select?: MunicipioSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: MunicipioInclude<ExtArgs> | null
  }


  /**
   * Model CodigoPostal
   */

  export type AggregateCodigoPostal = {
    _count: CodigoPostalCountAggregateOutputType | null
    _avg: CodigoPostalAvgAggregateOutputType | null
    _sum: CodigoPostalSumAggregateOutputType | null
    _min: CodigoPostalMinAggregateOutputType | null
    _max: CodigoPostalMaxAggregateOutputType | null
  }

  export type CodigoPostalAvgAggregateOutputType = {
    id_codigo_postal: number | null
    id_municipio: number | null
  }

  export type CodigoPostalSumAggregateOutputType = {
    id_codigo_postal: number | null
    id_municipio: number | null
  }

  export type CodigoPostalMinAggregateOutputType = {
    id_codigo_postal: number | null
    id_municipio: number | null
    codigo_postal: string | null
  }

  export type CodigoPostalMaxAggregateOutputType = {
    id_codigo_postal: number | null
    id_municipio: number | null
    codigo_postal: string | null
  }

  export type CodigoPostalCountAggregateOutputType = {
    id_codigo_postal: number
    id_municipio: number
    codigo_postal: number
    _all: number
  }


  export type CodigoPostalAvgAggregateInputType = {
    id_codigo_postal?: true
    id_municipio?: true
  }

  export type CodigoPostalSumAggregateInputType = {
    id_codigo_postal?: true
    id_municipio?: true
  }

  export type CodigoPostalMinAggregateInputType = {
    id_codigo_postal?: true
    id_municipio?: true
    codigo_postal?: true
  }

  export type CodigoPostalMaxAggregateInputType = {
    id_codigo_postal?: true
    id_municipio?: true
    codigo_postal?: true
  }

  export type CodigoPostalCountAggregateInputType = {
    id_codigo_postal?: true
    id_municipio?: true
    codigo_postal?: true
    _all?: true
  }

  export type CodigoPostalAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which CodigoPostal to aggregate.
     */
    where?: CodigoPostalWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of CodigoPostals to fetch.
     */
    orderBy?: CodigoPostalOrderByWithRelationInput | CodigoPostalOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: CodigoPostalWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` CodigoPostals from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` CodigoPostals.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned CodigoPostals
    **/
    _count?: true | CodigoPostalCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: CodigoPostalAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: CodigoPostalSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: CodigoPostalMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: CodigoPostalMaxAggregateInputType
  }

  export type GetCodigoPostalAggregateType<T extends CodigoPostalAggregateArgs> = {
        [P in keyof T & keyof AggregateCodigoPostal]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateCodigoPostal[P]>
      : GetScalarType<T[P], AggregateCodigoPostal[P]>
  }




  export type CodigoPostalGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: CodigoPostalWhereInput
    orderBy?: CodigoPostalOrderByWithAggregationInput | CodigoPostalOrderByWithAggregationInput[]
    by: CodigoPostalScalarFieldEnum[] | CodigoPostalScalarFieldEnum
    having?: CodigoPostalScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: CodigoPostalCountAggregateInputType | true
    _avg?: CodigoPostalAvgAggregateInputType
    _sum?: CodigoPostalSumAggregateInputType
    _min?: CodigoPostalMinAggregateInputType
    _max?: CodigoPostalMaxAggregateInputType
  }

  export type CodigoPostalGroupByOutputType = {
    id_codigo_postal: number
    id_municipio: number
    codigo_postal: string
    _count: CodigoPostalCountAggregateOutputType | null
    _avg: CodigoPostalAvgAggregateOutputType | null
    _sum: CodigoPostalSumAggregateOutputType | null
    _min: CodigoPostalMinAggregateOutputType | null
    _max: CodigoPostalMaxAggregateOutputType | null
  }

  type GetCodigoPostalGroupByPayload<T extends CodigoPostalGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<CodigoPostalGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof CodigoPostalGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], CodigoPostalGroupByOutputType[P]>
            : GetScalarType<T[P], CodigoPostalGroupByOutputType[P]>
        }
      >
    >


  export type CodigoPostalSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id_codigo_postal?: boolean
    id_municipio?: boolean
    codigo_postal?: boolean
    municipio?: boolean | MunicipioDefaultArgs<ExtArgs>
    colonias?: boolean | CodigoPostal$coloniasArgs<ExtArgs>
    _count?: boolean | CodigoPostalCountOutputTypeDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["codigoPostal"]>


  export type CodigoPostalSelectScalar = {
    id_codigo_postal?: boolean
    id_municipio?: boolean
    codigo_postal?: boolean
  }

  export type CodigoPostalInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    municipio?: boolean | MunicipioDefaultArgs<ExtArgs>
    colonias?: boolean | CodigoPostal$coloniasArgs<ExtArgs>
    _count?: boolean | CodigoPostalCountOutputTypeDefaultArgs<ExtArgs>
  }

  export type $CodigoPostalPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "CodigoPostal"
    objects: {
      municipio: Prisma.$MunicipioPayload<ExtArgs>
      colonias: Prisma.$ColoniaPayload<ExtArgs>[]
    }
    scalars: $Extensions.GetPayloadResult<{
      id_codigo_postal: number
      id_municipio: number
      codigo_postal: string
    }, ExtArgs["result"]["codigoPostal"]>
    composites: {}
  }

  type CodigoPostalGetPayload<S extends boolean | null | undefined | CodigoPostalDefaultArgs> = $Result.GetResult<Prisma.$CodigoPostalPayload, S>

  type CodigoPostalCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = 
    Omit<CodigoPostalFindManyArgs, 'select' | 'include' | 'distinct'> & {
      select?: CodigoPostalCountAggregateInputType | true
    }

  export interface CodigoPostalDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['CodigoPostal'], meta: { name: 'CodigoPostal' } }
    /**
     * Find zero or one CodigoPostal that matches the filter.
     * @param {CodigoPostalFindUniqueArgs} args - Arguments to find a CodigoPostal
     * @example
     * // Get one CodigoPostal
     * const codigoPostal = await prisma.codigoPostal.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends CodigoPostalFindUniqueArgs>(args: SelectSubset<T, CodigoPostalFindUniqueArgs<ExtArgs>>): Prisma__CodigoPostalClient<$Result.GetResult<Prisma.$CodigoPostalPayload<ExtArgs>, T, "findUnique"> | null, null, ExtArgs>

    /**
     * Find one CodigoPostal that matches the filter or throw an error with `error.code='P2025'` 
     * if no matches were found.
     * @param {CodigoPostalFindUniqueOrThrowArgs} args - Arguments to find a CodigoPostal
     * @example
     * // Get one CodigoPostal
     * const codigoPostal = await prisma.codigoPostal.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends CodigoPostalFindUniqueOrThrowArgs>(args: SelectSubset<T, CodigoPostalFindUniqueOrThrowArgs<ExtArgs>>): Prisma__CodigoPostalClient<$Result.GetResult<Prisma.$CodigoPostalPayload<ExtArgs>, T, "findUniqueOrThrow">, never, ExtArgs>

    /**
     * Find the first CodigoPostal that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {CodigoPostalFindFirstArgs} args - Arguments to find a CodigoPostal
     * @example
     * // Get one CodigoPostal
     * const codigoPostal = await prisma.codigoPostal.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends CodigoPostalFindFirstArgs>(args?: SelectSubset<T, CodigoPostalFindFirstArgs<ExtArgs>>): Prisma__CodigoPostalClient<$Result.GetResult<Prisma.$CodigoPostalPayload<ExtArgs>, T, "findFirst"> | null, null, ExtArgs>

    /**
     * Find the first CodigoPostal that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {CodigoPostalFindFirstOrThrowArgs} args - Arguments to find a CodigoPostal
     * @example
     * // Get one CodigoPostal
     * const codigoPostal = await prisma.codigoPostal.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends CodigoPostalFindFirstOrThrowArgs>(args?: SelectSubset<T, CodigoPostalFindFirstOrThrowArgs<ExtArgs>>): Prisma__CodigoPostalClient<$Result.GetResult<Prisma.$CodigoPostalPayload<ExtArgs>, T, "findFirstOrThrow">, never, ExtArgs>

    /**
     * Find zero or more CodigoPostals that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {CodigoPostalFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all CodigoPostals
     * const codigoPostals = await prisma.codigoPostal.findMany()
     * 
     * // Get first 10 CodigoPostals
     * const codigoPostals = await prisma.codigoPostal.findMany({ take: 10 })
     * 
     * // Only select the `id_codigo_postal`
     * const codigoPostalWithId_codigo_postalOnly = await prisma.codigoPostal.findMany({ select: { id_codigo_postal: true } })
     * 
     */
    findMany<T extends CodigoPostalFindManyArgs>(args?: SelectSubset<T, CodigoPostalFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$CodigoPostalPayload<ExtArgs>, T, "findMany">>

    /**
     * Create a CodigoPostal.
     * @param {CodigoPostalCreateArgs} args - Arguments to create a CodigoPostal.
     * @example
     * // Create one CodigoPostal
     * const CodigoPostal = await prisma.codigoPostal.create({
     *   data: {
     *     // ... data to create a CodigoPostal
     *   }
     * })
     * 
     */
    create<T extends CodigoPostalCreateArgs>(args: SelectSubset<T, CodigoPostalCreateArgs<ExtArgs>>): Prisma__CodigoPostalClient<$Result.GetResult<Prisma.$CodigoPostalPayload<ExtArgs>, T, "create">, never, ExtArgs>

    /**
     * Create many CodigoPostals.
     * @param {CodigoPostalCreateManyArgs} args - Arguments to create many CodigoPostals.
     * @example
     * // Create many CodigoPostals
     * const codigoPostal = await prisma.codigoPostal.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends CodigoPostalCreateManyArgs>(args?: SelectSubset<T, CodigoPostalCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Delete a CodigoPostal.
     * @param {CodigoPostalDeleteArgs} args - Arguments to delete one CodigoPostal.
     * @example
     * // Delete one CodigoPostal
     * const CodigoPostal = await prisma.codigoPostal.delete({
     *   where: {
     *     // ... filter to delete one CodigoPostal
     *   }
     * })
     * 
     */
    delete<T extends CodigoPostalDeleteArgs>(args: SelectSubset<T, CodigoPostalDeleteArgs<ExtArgs>>): Prisma__CodigoPostalClient<$Result.GetResult<Prisma.$CodigoPostalPayload<ExtArgs>, T, "delete">, never, ExtArgs>

    /**
     * Update one CodigoPostal.
     * @param {CodigoPostalUpdateArgs} args - Arguments to update one CodigoPostal.
     * @example
     * // Update one CodigoPostal
     * const codigoPostal = await prisma.codigoPostal.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends CodigoPostalUpdateArgs>(args: SelectSubset<T, CodigoPostalUpdateArgs<ExtArgs>>): Prisma__CodigoPostalClient<$Result.GetResult<Prisma.$CodigoPostalPayload<ExtArgs>, T, "update">, never, ExtArgs>

    /**
     * Delete zero or more CodigoPostals.
     * @param {CodigoPostalDeleteManyArgs} args - Arguments to filter CodigoPostals to delete.
     * @example
     * // Delete a few CodigoPostals
     * const { count } = await prisma.codigoPostal.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends CodigoPostalDeleteManyArgs>(args?: SelectSubset<T, CodigoPostalDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more CodigoPostals.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {CodigoPostalUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many CodigoPostals
     * const codigoPostal = await prisma.codigoPostal.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends CodigoPostalUpdateManyArgs>(args: SelectSubset<T, CodigoPostalUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one CodigoPostal.
     * @param {CodigoPostalUpsertArgs} args - Arguments to update or create a CodigoPostal.
     * @example
     * // Update or create a CodigoPostal
     * const codigoPostal = await prisma.codigoPostal.upsert({
     *   create: {
     *     // ... data to create a CodigoPostal
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the CodigoPostal we want to update
     *   }
     * })
     */
    upsert<T extends CodigoPostalUpsertArgs>(args: SelectSubset<T, CodigoPostalUpsertArgs<ExtArgs>>): Prisma__CodigoPostalClient<$Result.GetResult<Prisma.$CodigoPostalPayload<ExtArgs>, T, "upsert">, never, ExtArgs>


    /**
     * Count the number of CodigoPostals.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {CodigoPostalCountArgs} args - Arguments to filter CodigoPostals to count.
     * @example
     * // Count the number of CodigoPostals
     * const count = await prisma.codigoPostal.count({
     *   where: {
     *     // ... the filter for the CodigoPostals we want to count
     *   }
     * })
    **/
    count<T extends CodigoPostalCountArgs>(
      args?: Subset<T, CodigoPostalCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], CodigoPostalCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a CodigoPostal.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {CodigoPostalAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends CodigoPostalAggregateArgs>(args: Subset<T, CodigoPostalAggregateArgs>): Prisma.PrismaPromise<GetCodigoPostalAggregateType<T>>

    /**
     * Group by CodigoPostal.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {CodigoPostalGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends CodigoPostalGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: CodigoPostalGroupByArgs['orderBy'] }
        : { orderBy?: CodigoPostalGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, CodigoPostalGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetCodigoPostalGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the CodigoPostal model
   */
  readonly fields: CodigoPostalFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for CodigoPostal.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__CodigoPostalClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    municipio<T extends MunicipioDefaultArgs<ExtArgs> = {}>(args?: Subset<T, MunicipioDefaultArgs<ExtArgs>>): Prisma__MunicipioClient<$Result.GetResult<Prisma.$MunicipioPayload<ExtArgs>, T, "findUniqueOrThrow"> | Null, Null, ExtArgs>
    colonias<T extends CodigoPostal$coloniasArgs<ExtArgs> = {}>(args?: Subset<T, CodigoPostal$coloniasArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$ColoniaPayload<ExtArgs>, T, "findMany"> | Null>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the CodigoPostal model
   */ 
  interface CodigoPostalFieldRefs {
    readonly id_codigo_postal: FieldRef<"CodigoPostal", 'Int'>
    readonly id_municipio: FieldRef<"CodigoPostal", 'Int'>
    readonly codigo_postal: FieldRef<"CodigoPostal", 'String'>
  }
    

  // Custom InputTypes
  /**
   * CodigoPostal findUnique
   */
  export type CodigoPostalFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the CodigoPostal
     */
    select?: CodigoPostalSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CodigoPostalInclude<ExtArgs> | null
    /**
     * Filter, which CodigoPostal to fetch.
     */
    where: CodigoPostalWhereUniqueInput
  }

  /**
   * CodigoPostal findUniqueOrThrow
   */
  export type CodigoPostalFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the CodigoPostal
     */
    select?: CodigoPostalSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CodigoPostalInclude<ExtArgs> | null
    /**
     * Filter, which CodigoPostal to fetch.
     */
    where: CodigoPostalWhereUniqueInput
  }

  /**
   * CodigoPostal findFirst
   */
  export type CodigoPostalFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the CodigoPostal
     */
    select?: CodigoPostalSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CodigoPostalInclude<ExtArgs> | null
    /**
     * Filter, which CodigoPostal to fetch.
     */
    where?: CodigoPostalWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of CodigoPostals to fetch.
     */
    orderBy?: CodigoPostalOrderByWithRelationInput | CodigoPostalOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for CodigoPostals.
     */
    cursor?: CodigoPostalWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` CodigoPostals from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` CodigoPostals.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of CodigoPostals.
     */
    distinct?: CodigoPostalScalarFieldEnum | CodigoPostalScalarFieldEnum[]
  }

  /**
   * CodigoPostal findFirstOrThrow
   */
  export type CodigoPostalFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the CodigoPostal
     */
    select?: CodigoPostalSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CodigoPostalInclude<ExtArgs> | null
    /**
     * Filter, which CodigoPostal to fetch.
     */
    where?: CodigoPostalWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of CodigoPostals to fetch.
     */
    orderBy?: CodigoPostalOrderByWithRelationInput | CodigoPostalOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for CodigoPostals.
     */
    cursor?: CodigoPostalWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` CodigoPostals from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` CodigoPostals.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of CodigoPostals.
     */
    distinct?: CodigoPostalScalarFieldEnum | CodigoPostalScalarFieldEnum[]
  }

  /**
   * CodigoPostal findMany
   */
  export type CodigoPostalFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the CodigoPostal
     */
    select?: CodigoPostalSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CodigoPostalInclude<ExtArgs> | null
    /**
     * Filter, which CodigoPostals to fetch.
     */
    where?: CodigoPostalWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of CodigoPostals to fetch.
     */
    orderBy?: CodigoPostalOrderByWithRelationInput | CodigoPostalOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing CodigoPostals.
     */
    cursor?: CodigoPostalWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` CodigoPostals from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` CodigoPostals.
     */
    skip?: number
    distinct?: CodigoPostalScalarFieldEnum | CodigoPostalScalarFieldEnum[]
  }

  /**
   * CodigoPostal create
   */
  export type CodigoPostalCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the CodigoPostal
     */
    select?: CodigoPostalSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CodigoPostalInclude<ExtArgs> | null
    /**
     * The data needed to create a CodigoPostal.
     */
    data: XOR<CodigoPostalCreateInput, CodigoPostalUncheckedCreateInput>
  }

  /**
   * CodigoPostal createMany
   */
  export type CodigoPostalCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many CodigoPostals.
     */
    data: CodigoPostalCreateManyInput | CodigoPostalCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * CodigoPostal update
   */
  export type CodigoPostalUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the CodigoPostal
     */
    select?: CodigoPostalSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CodigoPostalInclude<ExtArgs> | null
    /**
     * The data needed to update a CodigoPostal.
     */
    data: XOR<CodigoPostalUpdateInput, CodigoPostalUncheckedUpdateInput>
    /**
     * Choose, which CodigoPostal to update.
     */
    where: CodigoPostalWhereUniqueInput
  }

  /**
   * CodigoPostal updateMany
   */
  export type CodigoPostalUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update CodigoPostals.
     */
    data: XOR<CodigoPostalUpdateManyMutationInput, CodigoPostalUncheckedUpdateManyInput>
    /**
     * Filter which CodigoPostals to update
     */
    where?: CodigoPostalWhereInput
  }

  /**
   * CodigoPostal upsert
   */
  export type CodigoPostalUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the CodigoPostal
     */
    select?: CodigoPostalSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CodigoPostalInclude<ExtArgs> | null
    /**
     * The filter to search for the CodigoPostal to update in case it exists.
     */
    where: CodigoPostalWhereUniqueInput
    /**
     * In case the CodigoPostal found by the `where` argument doesn't exist, create a new CodigoPostal with this data.
     */
    create: XOR<CodigoPostalCreateInput, CodigoPostalUncheckedCreateInput>
    /**
     * In case the CodigoPostal was found with the provided `where` argument, update it with this data.
     */
    update: XOR<CodigoPostalUpdateInput, CodigoPostalUncheckedUpdateInput>
  }

  /**
   * CodigoPostal delete
   */
  export type CodigoPostalDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the CodigoPostal
     */
    select?: CodigoPostalSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CodigoPostalInclude<ExtArgs> | null
    /**
     * Filter which CodigoPostal to delete.
     */
    where: CodigoPostalWhereUniqueInput
  }

  /**
   * CodigoPostal deleteMany
   */
  export type CodigoPostalDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which CodigoPostals to delete
     */
    where?: CodigoPostalWhereInput
  }

  /**
   * CodigoPostal.colonias
   */
  export type CodigoPostal$coloniasArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Colonia
     */
    select?: ColoniaSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ColoniaInclude<ExtArgs> | null
    where?: ColoniaWhereInput
    orderBy?: ColoniaOrderByWithRelationInput | ColoniaOrderByWithRelationInput[]
    cursor?: ColoniaWhereUniqueInput
    take?: number
    skip?: number
    distinct?: ColoniaScalarFieldEnum | ColoniaScalarFieldEnum[]
  }

  /**
   * CodigoPostal without action
   */
  export type CodigoPostalDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the CodigoPostal
     */
    select?: CodigoPostalSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CodigoPostalInclude<ExtArgs> | null
  }


  /**
   * Model Colonia
   */

  export type AggregateColonia = {
    _count: ColoniaCountAggregateOutputType | null
    _avg: ColoniaAvgAggregateOutputType | null
    _sum: ColoniaSumAggregateOutputType | null
    _min: ColoniaMinAggregateOutputType | null
    _max: ColoniaMaxAggregateOutputType | null
  }

  export type ColoniaAvgAggregateOutputType = {
    id_colonia: number | null
    id_codigo_postal: number | null
  }

  export type ColoniaSumAggregateOutputType = {
    id_colonia: number | null
    id_codigo_postal: number | null
  }

  export type ColoniaMinAggregateOutputType = {
    id_colonia: number | null
    id_codigo_postal: number | null
    nombre: string | null
  }

  export type ColoniaMaxAggregateOutputType = {
    id_colonia: number | null
    id_codigo_postal: number | null
    nombre: string | null
  }

  export type ColoniaCountAggregateOutputType = {
    id_colonia: number
    id_codigo_postal: number
    nombre: number
    _all: number
  }


  export type ColoniaAvgAggregateInputType = {
    id_colonia?: true
    id_codigo_postal?: true
  }

  export type ColoniaSumAggregateInputType = {
    id_colonia?: true
    id_codigo_postal?: true
  }

  export type ColoniaMinAggregateInputType = {
    id_colonia?: true
    id_codigo_postal?: true
    nombre?: true
  }

  export type ColoniaMaxAggregateInputType = {
    id_colonia?: true
    id_codigo_postal?: true
    nombre?: true
  }

  export type ColoniaCountAggregateInputType = {
    id_colonia?: true
    id_codigo_postal?: true
    nombre?: true
    _all?: true
  }

  export type ColoniaAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Colonia to aggregate.
     */
    where?: ColoniaWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Colonias to fetch.
     */
    orderBy?: ColoniaOrderByWithRelationInput | ColoniaOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: ColoniaWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Colonias from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Colonias.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned Colonias
    **/
    _count?: true | ColoniaCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: ColoniaAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: ColoniaSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: ColoniaMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: ColoniaMaxAggregateInputType
  }

  export type GetColoniaAggregateType<T extends ColoniaAggregateArgs> = {
        [P in keyof T & keyof AggregateColonia]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateColonia[P]>
      : GetScalarType<T[P], AggregateColonia[P]>
  }




  export type ColoniaGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: ColoniaWhereInput
    orderBy?: ColoniaOrderByWithAggregationInput | ColoniaOrderByWithAggregationInput[]
    by: ColoniaScalarFieldEnum[] | ColoniaScalarFieldEnum
    having?: ColoniaScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: ColoniaCountAggregateInputType | true
    _avg?: ColoniaAvgAggregateInputType
    _sum?: ColoniaSumAggregateInputType
    _min?: ColoniaMinAggregateInputType
    _max?: ColoniaMaxAggregateInputType
  }

  export type ColoniaGroupByOutputType = {
    id_colonia: number
    id_codigo_postal: number
    nombre: string
    _count: ColoniaCountAggregateOutputType | null
    _avg: ColoniaAvgAggregateOutputType | null
    _sum: ColoniaSumAggregateOutputType | null
    _min: ColoniaMinAggregateOutputType | null
    _max: ColoniaMaxAggregateOutputType | null
  }

  type GetColoniaGroupByPayload<T extends ColoniaGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<ColoniaGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof ColoniaGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], ColoniaGroupByOutputType[P]>
            : GetScalarType<T[P], ColoniaGroupByOutputType[P]>
        }
      >
    >


  export type ColoniaSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id_colonia?: boolean
    id_codigo_postal?: boolean
    nombre?: boolean
    codigoPostal?: boolean | CodigoPostalDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["colonia"]>


  export type ColoniaSelectScalar = {
    id_colonia?: boolean
    id_codigo_postal?: boolean
    nombre?: boolean
  }

  export type ColoniaInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    codigoPostal?: boolean | CodigoPostalDefaultArgs<ExtArgs>
  }

  export type $ColoniaPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "Colonia"
    objects: {
      codigoPostal: Prisma.$CodigoPostalPayload<ExtArgs>
    }
    scalars: $Extensions.GetPayloadResult<{
      id_colonia: number
      id_codigo_postal: number
      nombre: string
    }, ExtArgs["result"]["colonia"]>
    composites: {}
  }

  type ColoniaGetPayload<S extends boolean | null | undefined | ColoniaDefaultArgs> = $Result.GetResult<Prisma.$ColoniaPayload, S>

  type ColoniaCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = 
    Omit<ColoniaFindManyArgs, 'select' | 'include' | 'distinct'> & {
      select?: ColoniaCountAggregateInputType | true
    }

  export interface ColoniaDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['Colonia'], meta: { name: 'Colonia' } }
    /**
     * Find zero or one Colonia that matches the filter.
     * @param {ColoniaFindUniqueArgs} args - Arguments to find a Colonia
     * @example
     * // Get one Colonia
     * const colonia = await prisma.colonia.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends ColoniaFindUniqueArgs>(args: SelectSubset<T, ColoniaFindUniqueArgs<ExtArgs>>): Prisma__ColoniaClient<$Result.GetResult<Prisma.$ColoniaPayload<ExtArgs>, T, "findUnique"> | null, null, ExtArgs>

    /**
     * Find one Colonia that matches the filter or throw an error with `error.code='P2025'` 
     * if no matches were found.
     * @param {ColoniaFindUniqueOrThrowArgs} args - Arguments to find a Colonia
     * @example
     * // Get one Colonia
     * const colonia = await prisma.colonia.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends ColoniaFindUniqueOrThrowArgs>(args: SelectSubset<T, ColoniaFindUniqueOrThrowArgs<ExtArgs>>): Prisma__ColoniaClient<$Result.GetResult<Prisma.$ColoniaPayload<ExtArgs>, T, "findUniqueOrThrow">, never, ExtArgs>

    /**
     * Find the first Colonia that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ColoniaFindFirstArgs} args - Arguments to find a Colonia
     * @example
     * // Get one Colonia
     * const colonia = await prisma.colonia.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends ColoniaFindFirstArgs>(args?: SelectSubset<T, ColoniaFindFirstArgs<ExtArgs>>): Prisma__ColoniaClient<$Result.GetResult<Prisma.$ColoniaPayload<ExtArgs>, T, "findFirst"> | null, null, ExtArgs>

    /**
     * Find the first Colonia that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ColoniaFindFirstOrThrowArgs} args - Arguments to find a Colonia
     * @example
     * // Get one Colonia
     * const colonia = await prisma.colonia.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends ColoniaFindFirstOrThrowArgs>(args?: SelectSubset<T, ColoniaFindFirstOrThrowArgs<ExtArgs>>): Prisma__ColoniaClient<$Result.GetResult<Prisma.$ColoniaPayload<ExtArgs>, T, "findFirstOrThrow">, never, ExtArgs>

    /**
     * Find zero or more Colonias that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ColoniaFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Colonias
     * const colonias = await prisma.colonia.findMany()
     * 
     * // Get first 10 Colonias
     * const colonias = await prisma.colonia.findMany({ take: 10 })
     * 
     * // Only select the `id_colonia`
     * const coloniaWithId_coloniaOnly = await prisma.colonia.findMany({ select: { id_colonia: true } })
     * 
     */
    findMany<T extends ColoniaFindManyArgs>(args?: SelectSubset<T, ColoniaFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$ColoniaPayload<ExtArgs>, T, "findMany">>

    /**
     * Create a Colonia.
     * @param {ColoniaCreateArgs} args - Arguments to create a Colonia.
     * @example
     * // Create one Colonia
     * const Colonia = await prisma.colonia.create({
     *   data: {
     *     // ... data to create a Colonia
     *   }
     * })
     * 
     */
    create<T extends ColoniaCreateArgs>(args: SelectSubset<T, ColoniaCreateArgs<ExtArgs>>): Prisma__ColoniaClient<$Result.GetResult<Prisma.$ColoniaPayload<ExtArgs>, T, "create">, never, ExtArgs>

    /**
     * Create many Colonias.
     * @param {ColoniaCreateManyArgs} args - Arguments to create many Colonias.
     * @example
     * // Create many Colonias
     * const colonia = await prisma.colonia.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends ColoniaCreateManyArgs>(args?: SelectSubset<T, ColoniaCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Delete a Colonia.
     * @param {ColoniaDeleteArgs} args - Arguments to delete one Colonia.
     * @example
     * // Delete one Colonia
     * const Colonia = await prisma.colonia.delete({
     *   where: {
     *     // ... filter to delete one Colonia
     *   }
     * })
     * 
     */
    delete<T extends ColoniaDeleteArgs>(args: SelectSubset<T, ColoniaDeleteArgs<ExtArgs>>): Prisma__ColoniaClient<$Result.GetResult<Prisma.$ColoniaPayload<ExtArgs>, T, "delete">, never, ExtArgs>

    /**
     * Update one Colonia.
     * @param {ColoniaUpdateArgs} args - Arguments to update one Colonia.
     * @example
     * // Update one Colonia
     * const colonia = await prisma.colonia.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends ColoniaUpdateArgs>(args: SelectSubset<T, ColoniaUpdateArgs<ExtArgs>>): Prisma__ColoniaClient<$Result.GetResult<Prisma.$ColoniaPayload<ExtArgs>, T, "update">, never, ExtArgs>

    /**
     * Delete zero or more Colonias.
     * @param {ColoniaDeleteManyArgs} args - Arguments to filter Colonias to delete.
     * @example
     * // Delete a few Colonias
     * const { count } = await prisma.colonia.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends ColoniaDeleteManyArgs>(args?: SelectSubset<T, ColoniaDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Colonias.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ColoniaUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Colonias
     * const colonia = await prisma.colonia.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends ColoniaUpdateManyArgs>(args: SelectSubset<T, ColoniaUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one Colonia.
     * @param {ColoniaUpsertArgs} args - Arguments to update or create a Colonia.
     * @example
     * // Update or create a Colonia
     * const colonia = await prisma.colonia.upsert({
     *   create: {
     *     // ... data to create a Colonia
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Colonia we want to update
     *   }
     * })
     */
    upsert<T extends ColoniaUpsertArgs>(args: SelectSubset<T, ColoniaUpsertArgs<ExtArgs>>): Prisma__ColoniaClient<$Result.GetResult<Prisma.$ColoniaPayload<ExtArgs>, T, "upsert">, never, ExtArgs>


    /**
     * Count the number of Colonias.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ColoniaCountArgs} args - Arguments to filter Colonias to count.
     * @example
     * // Count the number of Colonias
     * const count = await prisma.colonia.count({
     *   where: {
     *     // ... the filter for the Colonias we want to count
     *   }
     * })
    **/
    count<T extends ColoniaCountArgs>(
      args?: Subset<T, ColoniaCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], ColoniaCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Colonia.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ColoniaAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends ColoniaAggregateArgs>(args: Subset<T, ColoniaAggregateArgs>): Prisma.PrismaPromise<GetColoniaAggregateType<T>>

    /**
     * Group by Colonia.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ColoniaGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends ColoniaGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: ColoniaGroupByArgs['orderBy'] }
        : { orderBy?: ColoniaGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, ColoniaGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetColoniaGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the Colonia model
   */
  readonly fields: ColoniaFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for Colonia.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__ColoniaClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    codigoPostal<T extends CodigoPostalDefaultArgs<ExtArgs> = {}>(args?: Subset<T, CodigoPostalDefaultArgs<ExtArgs>>): Prisma__CodigoPostalClient<$Result.GetResult<Prisma.$CodigoPostalPayload<ExtArgs>, T, "findUniqueOrThrow"> | Null, Null, ExtArgs>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the Colonia model
   */ 
  interface ColoniaFieldRefs {
    readonly id_colonia: FieldRef<"Colonia", 'Int'>
    readonly id_codigo_postal: FieldRef<"Colonia", 'Int'>
    readonly nombre: FieldRef<"Colonia", 'String'>
  }
    

  // Custom InputTypes
  /**
   * Colonia findUnique
   */
  export type ColoniaFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Colonia
     */
    select?: ColoniaSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ColoniaInclude<ExtArgs> | null
    /**
     * Filter, which Colonia to fetch.
     */
    where: ColoniaWhereUniqueInput
  }

  /**
   * Colonia findUniqueOrThrow
   */
  export type ColoniaFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Colonia
     */
    select?: ColoniaSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ColoniaInclude<ExtArgs> | null
    /**
     * Filter, which Colonia to fetch.
     */
    where: ColoniaWhereUniqueInput
  }

  /**
   * Colonia findFirst
   */
  export type ColoniaFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Colonia
     */
    select?: ColoniaSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ColoniaInclude<ExtArgs> | null
    /**
     * Filter, which Colonia to fetch.
     */
    where?: ColoniaWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Colonias to fetch.
     */
    orderBy?: ColoniaOrderByWithRelationInput | ColoniaOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Colonias.
     */
    cursor?: ColoniaWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Colonias from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Colonias.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Colonias.
     */
    distinct?: ColoniaScalarFieldEnum | ColoniaScalarFieldEnum[]
  }

  /**
   * Colonia findFirstOrThrow
   */
  export type ColoniaFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Colonia
     */
    select?: ColoniaSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ColoniaInclude<ExtArgs> | null
    /**
     * Filter, which Colonia to fetch.
     */
    where?: ColoniaWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Colonias to fetch.
     */
    orderBy?: ColoniaOrderByWithRelationInput | ColoniaOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Colonias.
     */
    cursor?: ColoniaWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Colonias from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Colonias.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Colonias.
     */
    distinct?: ColoniaScalarFieldEnum | ColoniaScalarFieldEnum[]
  }

  /**
   * Colonia findMany
   */
  export type ColoniaFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Colonia
     */
    select?: ColoniaSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ColoniaInclude<ExtArgs> | null
    /**
     * Filter, which Colonias to fetch.
     */
    where?: ColoniaWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Colonias to fetch.
     */
    orderBy?: ColoniaOrderByWithRelationInput | ColoniaOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing Colonias.
     */
    cursor?: ColoniaWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Colonias from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Colonias.
     */
    skip?: number
    distinct?: ColoniaScalarFieldEnum | ColoniaScalarFieldEnum[]
  }

  /**
   * Colonia create
   */
  export type ColoniaCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Colonia
     */
    select?: ColoniaSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ColoniaInclude<ExtArgs> | null
    /**
     * The data needed to create a Colonia.
     */
    data: XOR<ColoniaCreateInput, ColoniaUncheckedCreateInput>
  }

  /**
   * Colonia createMany
   */
  export type ColoniaCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many Colonias.
     */
    data: ColoniaCreateManyInput | ColoniaCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * Colonia update
   */
  export type ColoniaUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Colonia
     */
    select?: ColoniaSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ColoniaInclude<ExtArgs> | null
    /**
     * The data needed to update a Colonia.
     */
    data: XOR<ColoniaUpdateInput, ColoniaUncheckedUpdateInput>
    /**
     * Choose, which Colonia to update.
     */
    where: ColoniaWhereUniqueInput
  }

  /**
   * Colonia updateMany
   */
  export type ColoniaUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update Colonias.
     */
    data: XOR<ColoniaUpdateManyMutationInput, ColoniaUncheckedUpdateManyInput>
    /**
     * Filter which Colonias to update
     */
    where?: ColoniaWhereInput
  }

  /**
   * Colonia upsert
   */
  export type ColoniaUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Colonia
     */
    select?: ColoniaSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ColoniaInclude<ExtArgs> | null
    /**
     * The filter to search for the Colonia to update in case it exists.
     */
    where: ColoniaWhereUniqueInput
    /**
     * In case the Colonia found by the `where` argument doesn't exist, create a new Colonia with this data.
     */
    create: XOR<ColoniaCreateInput, ColoniaUncheckedCreateInput>
    /**
     * In case the Colonia was found with the provided `where` argument, update it with this data.
     */
    update: XOR<ColoniaUpdateInput, ColoniaUncheckedUpdateInput>
  }

  /**
   * Colonia delete
   */
  export type ColoniaDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Colonia
     */
    select?: ColoniaSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ColoniaInclude<ExtArgs> | null
    /**
     * Filter which Colonia to delete.
     */
    where: ColoniaWhereUniqueInput
  }

  /**
   * Colonia deleteMany
   */
  export type ColoniaDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Colonias to delete
     */
    where?: ColoniaWhereInput
  }

  /**
   * Colonia without action
   */
  export type ColoniaDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Colonia
     */
    select?: ColoniaSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ColoniaInclude<ExtArgs> | null
  }


  /**
   * Model Usuario
   */

  export type AggregateUsuario = {
    _count: UsuarioCountAggregateOutputType | null
    _avg: UsuarioAvgAggregateOutputType | null
    _sum: UsuarioSumAggregateOutputType | null
    _min: UsuarioMinAggregateOutputType | null
    _max: UsuarioMaxAggregateOutputType | null
  }

  export type UsuarioAvgAggregateOutputType = {
    id_usuario: number | null
    id_tipo_rol: number | null
  }

  export type UsuarioSumAggregateOutputType = {
    id_usuario: number | null
    id_tipo_rol: number | null
  }

  export type UsuarioMinAggregateOutputType = {
    id_usuario: number | null
    nombre: string | null
    email: string | null
    password_hash: string | null
    id_tipo_rol: number | null
    activo: boolean | null
    fecha_creacion: Date | null
  }

  export type UsuarioMaxAggregateOutputType = {
    id_usuario: number | null
    nombre: string | null
    email: string | null
    password_hash: string | null
    id_tipo_rol: number | null
    activo: boolean | null
    fecha_creacion: Date | null
  }

  export type UsuarioCountAggregateOutputType = {
    id_usuario: number
    nombre: number
    email: number
    password_hash: number
    id_tipo_rol: number
    activo: number
    fecha_creacion: number
    _all: number
  }


  export type UsuarioAvgAggregateInputType = {
    id_usuario?: true
    id_tipo_rol?: true
  }

  export type UsuarioSumAggregateInputType = {
    id_usuario?: true
    id_tipo_rol?: true
  }

  export type UsuarioMinAggregateInputType = {
    id_usuario?: true
    nombre?: true
    email?: true
    password_hash?: true
    id_tipo_rol?: true
    activo?: true
    fecha_creacion?: true
  }

  export type UsuarioMaxAggregateInputType = {
    id_usuario?: true
    nombre?: true
    email?: true
    password_hash?: true
    id_tipo_rol?: true
    activo?: true
    fecha_creacion?: true
  }

  export type UsuarioCountAggregateInputType = {
    id_usuario?: true
    nombre?: true
    email?: true
    password_hash?: true
    id_tipo_rol?: true
    activo?: true
    fecha_creacion?: true
    _all?: true
  }

  export type UsuarioAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Usuario to aggregate.
     */
    where?: UsuarioWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Usuarios to fetch.
     */
    orderBy?: UsuarioOrderByWithRelationInput | UsuarioOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: UsuarioWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Usuarios from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Usuarios.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned Usuarios
    **/
    _count?: true | UsuarioCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: UsuarioAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: UsuarioSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: UsuarioMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: UsuarioMaxAggregateInputType
  }

  export type GetUsuarioAggregateType<T extends UsuarioAggregateArgs> = {
        [P in keyof T & keyof AggregateUsuario]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateUsuario[P]>
      : GetScalarType<T[P], AggregateUsuario[P]>
  }




  export type UsuarioGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: UsuarioWhereInput
    orderBy?: UsuarioOrderByWithAggregationInput | UsuarioOrderByWithAggregationInput[]
    by: UsuarioScalarFieldEnum[] | UsuarioScalarFieldEnum
    having?: UsuarioScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: UsuarioCountAggregateInputType | true
    _avg?: UsuarioAvgAggregateInputType
    _sum?: UsuarioSumAggregateInputType
    _min?: UsuarioMinAggregateInputType
    _max?: UsuarioMaxAggregateInputType
  }

  export type UsuarioGroupByOutputType = {
    id_usuario: number
    nombre: string
    email: string
    password_hash: string
    id_tipo_rol: number
    activo: boolean
    fecha_creacion: Date
    _count: UsuarioCountAggregateOutputType | null
    _avg: UsuarioAvgAggregateOutputType | null
    _sum: UsuarioSumAggregateOutputType | null
    _min: UsuarioMinAggregateOutputType | null
    _max: UsuarioMaxAggregateOutputType | null
  }

  type GetUsuarioGroupByPayload<T extends UsuarioGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<UsuarioGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof UsuarioGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], UsuarioGroupByOutputType[P]>
            : GetScalarType<T[P], UsuarioGroupByOutputType[P]>
        }
      >
    >


  export type UsuarioSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id_usuario?: boolean
    nombre?: boolean
    email?: boolean
    password_hash?: boolean
    id_tipo_rol?: boolean
    activo?: boolean
    fecha_creacion?: boolean
    tipoRol?: boolean | TipoRolDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["usuario"]>


  export type UsuarioSelectScalar = {
    id_usuario?: boolean
    nombre?: boolean
    email?: boolean
    password_hash?: boolean
    id_tipo_rol?: boolean
    activo?: boolean
    fecha_creacion?: boolean
  }

  export type UsuarioInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    tipoRol?: boolean | TipoRolDefaultArgs<ExtArgs>
  }

  export type $UsuarioPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "Usuario"
    objects: {
      tipoRol: Prisma.$TipoRolPayload<ExtArgs>
    }
    scalars: $Extensions.GetPayloadResult<{
      id_usuario: number
      nombre: string
      email: string
      password_hash: string
      id_tipo_rol: number
      activo: boolean
      fecha_creacion: Date
    }, ExtArgs["result"]["usuario"]>
    composites: {}
  }

  type UsuarioGetPayload<S extends boolean | null | undefined | UsuarioDefaultArgs> = $Result.GetResult<Prisma.$UsuarioPayload, S>

  type UsuarioCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = 
    Omit<UsuarioFindManyArgs, 'select' | 'include' | 'distinct'> & {
      select?: UsuarioCountAggregateInputType | true
    }

  export interface UsuarioDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['Usuario'], meta: { name: 'Usuario' } }
    /**
     * Find zero or one Usuario that matches the filter.
     * @param {UsuarioFindUniqueArgs} args - Arguments to find a Usuario
     * @example
     * // Get one Usuario
     * const usuario = await prisma.usuario.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends UsuarioFindUniqueArgs>(args: SelectSubset<T, UsuarioFindUniqueArgs<ExtArgs>>): Prisma__UsuarioClient<$Result.GetResult<Prisma.$UsuarioPayload<ExtArgs>, T, "findUnique"> | null, null, ExtArgs>

    /**
     * Find one Usuario that matches the filter or throw an error with `error.code='P2025'` 
     * if no matches were found.
     * @param {UsuarioFindUniqueOrThrowArgs} args - Arguments to find a Usuario
     * @example
     * // Get one Usuario
     * const usuario = await prisma.usuario.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends UsuarioFindUniqueOrThrowArgs>(args: SelectSubset<T, UsuarioFindUniqueOrThrowArgs<ExtArgs>>): Prisma__UsuarioClient<$Result.GetResult<Prisma.$UsuarioPayload<ExtArgs>, T, "findUniqueOrThrow">, never, ExtArgs>

    /**
     * Find the first Usuario that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {UsuarioFindFirstArgs} args - Arguments to find a Usuario
     * @example
     * // Get one Usuario
     * const usuario = await prisma.usuario.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends UsuarioFindFirstArgs>(args?: SelectSubset<T, UsuarioFindFirstArgs<ExtArgs>>): Prisma__UsuarioClient<$Result.GetResult<Prisma.$UsuarioPayload<ExtArgs>, T, "findFirst"> | null, null, ExtArgs>

    /**
     * Find the first Usuario that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {UsuarioFindFirstOrThrowArgs} args - Arguments to find a Usuario
     * @example
     * // Get one Usuario
     * const usuario = await prisma.usuario.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends UsuarioFindFirstOrThrowArgs>(args?: SelectSubset<T, UsuarioFindFirstOrThrowArgs<ExtArgs>>): Prisma__UsuarioClient<$Result.GetResult<Prisma.$UsuarioPayload<ExtArgs>, T, "findFirstOrThrow">, never, ExtArgs>

    /**
     * Find zero or more Usuarios that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {UsuarioFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Usuarios
     * const usuarios = await prisma.usuario.findMany()
     * 
     * // Get first 10 Usuarios
     * const usuarios = await prisma.usuario.findMany({ take: 10 })
     * 
     * // Only select the `id_usuario`
     * const usuarioWithId_usuarioOnly = await prisma.usuario.findMany({ select: { id_usuario: true } })
     * 
     */
    findMany<T extends UsuarioFindManyArgs>(args?: SelectSubset<T, UsuarioFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$UsuarioPayload<ExtArgs>, T, "findMany">>

    /**
     * Create a Usuario.
     * @param {UsuarioCreateArgs} args - Arguments to create a Usuario.
     * @example
     * // Create one Usuario
     * const Usuario = await prisma.usuario.create({
     *   data: {
     *     // ... data to create a Usuario
     *   }
     * })
     * 
     */
    create<T extends UsuarioCreateArgs>(args: SelectSubset<T, UsuarioCreateArgs<ExtArgs>>): Prisma__UsuarioClient<$Result.GetResult<Prisma.$UsuarioPayload<ExtArgs>, T, "create">, never, ExtArgs>

    /**
     * Create many Usuarios.
     * @param {UsuarioCreateManyArgs} args - Arguments to create many Usuarios.
     * @example
     * // Create many Usuarios
     * const usuario = await prisma.usuario.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends UsuarioCreateManyArgs>(args?: SelectSubset<T, UsuarioCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Delete a Usuario.
     * @param {UsuarioDeleteArgs} args - Arguments to delete one Usuario.
     * @example
     * // Delete one Usuario
     * const Usuario = await prisma.usuario.delete({
     *   where: {
     *     // ... filter to delete one Usuario
     *   }
     * })
     * 
     */
    delete<T extends UsuarioDeleteArgs>(args: SelectSubset<T, UsuarioDeleteArgs<ExtArgs>>): Prisma__UsuarioClient<$Result.GetResult<Prisma.$UsuarioPayload<ExtArgs>, T, "delete">, never, ExtArgs>

    /**
     * Update one Usuario.
     * @param {UsuarioUpdateArgs} args - Arguments to update one Usuario.
     * @example
     * // Update one Usuario
     * const usuario = await prisma.usuario.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends UsuarioUpdateArgs>(args: SelectSubset<T, UsuarioUpdateArgs<ExtArgs>>): Prisma__UsuarioClient<$Result.GetResult<Prisma.$UsuarioPayload<ExtArgs>, T, "update">, never, ExtArgs>

    /**
     * Delete zero or more Usuarios.
     * @param {UsuarioDeleteManyArgs} args - Arguments to filter Usuarios to delete.
     * @example
     * // Delete a few Usuarios
     * const { count } = await prisma.usuario.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends UsuarioDeleteManyArgs>(args?: SelectSubset<T, UsuarioDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Usuarios.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {UsuarioUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Usuarios
     * const usuario = await prisma.usuario.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends UsuarioUpdateManyArgs>(args: SelectSubset<T, UsuarioUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one Usuario.
     * @param {UsuarioUpsertArgs} args - Arguments to update or create a Usuario.
     * @example
     * // Update or create a Usuario
     * const usuario = await prisma.usuario.upsert({
     *   create: {
     *     // ... data to create a Usuario
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Usuario we want to update
     *   }
     * })
     */
    upsert<T extends UsuarioUpsertArgs>(args: SelectSubset<T, UsuarioUpsertArgs<ExtArgs>>): Prisma__UsuarioClient<$Result.GetResult<Prisma.$UsuarioPayload<ExtArgs>, T, "upsert">, never, ExtArgs>


    /**
     * Count the number of Usuarios.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {UsuarioCountArgs} args - Arguments to filter Usuarios to count.
     * @example
     * // Count the number of Usuarios
     * const count = await prisma.usuario.count({
     *   where: {
     *     // ... the filter for the Usuarios we want to count
     *   }
     * })
    **/
    count<T extends UsuarioCountArgs>(
      args?: Subset<T, UsuarioCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], UsuarioCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Usuario.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {UsuarioAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends UsuarioAggregateArgs>(args: Subset<T, UsuarioAggregateArgs>): Prisma.PrismaPromise<GetUsuarioAggregateType<T>>

    /**
     * Group by Usuario.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {UsuarioGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends UsuarioGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: UsuarioGroupByArgs['orderBy'] }
        : { orderBy?: UsuarioGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, UsuarioGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetUsuarioGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the Usuario model
   */
  readonly fields: UsuarioFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for Usuario.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__UsuarioClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    tipoRol<T extends TipoRolDefaultArgs<ExtArgs> = {}>(args?: Subset<T, TipoRolDefaultArgs<ExtArgs>>): Prisma__TipoRolClient<$Result.GetResult<Prisma.$TipoRolPayload<ExtArgs>, T, "findUniqueOrThrow"> | Null, Null, ExtArgs>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the Usuario model
   */ 
  interface UsuarioFieldRefs {
    readonly id_usuario: FieldRef<"Usuario", 'Int'>
    readonly nombre: FieldRef<"Usuario", 'String'>
    readonly email: FieldRef<"Usuario", 'String'>
    readonly password_hash: FieldRef<"Usuario", 'String'>
    readonly id_tipo_rol: FieldRef<"Usuario", 'Int'>
    readonly activo: FieldRef<"Usuario", 'Boolean'>
    readonly fecha_creacion: FieldRef<"Usuario", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * Usuario findUnique
   */
  export type UsuarioFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Usuario
     */
    select?: UsuarioSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UsuarioInclude<ExtArgs> | null
    /**
     * Filter, which Usuario to fetch.
     */
    where: UsuarioWhereUniqueInput
  }

  /**
   * Usuario findUniqueOrThrow
   */
  export type UsuarioFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Usuario
     */
    select?: UsuarioSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UsuarioInclude<ExtArgs> | null
    /**
     * Filter, which Usuario to fetch.
     */
    where: UsuarioWhereUniqueInput
  }

  /**
   * Usuario findFirst
   */
  export type UsuarioFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Usuario
     */
    select?: UsuarioSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UsuarioInclude<ExtArgs> | null
    /**
     * Filter, which Usuario to fetch.
     */
    where?: UsuarioWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Usuarios to fetch.
     */
    orderBy?: UsuarioOrderByWithRelationInput | UsuarioOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Usuarios.
     */
    cursor?: UsuarioWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Usuarios from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Usuarios.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Usuarios.
     */
    distinct?: UsuarioScalarFieldEnum | UsuarioScalarFieldEnum[]
  }

  /**
   * Usuario findFirstOrThrow
   */
  export type UsuarioFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Usuario
     */
    select?: UsuarioSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UsuarioInclude<ExtArgs> | null
    /**
     * Filter, which Usuario to fetch.
     */
    where?: UsuarioWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Usuarios to fetch.
     */
    orderBy?: UsuarioOrderByWithRelationInput | UsuarioOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Usuarios.
     */
    cursor?: UsuarioWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Usuarios from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Usuarios.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Usuarios.
     */
    distinct?: UsuarioScalarFieldEnum | UsuarioScalarFieldEnum[]
  }

  /**
   * Usuario findMany
   */
  export type UsuarioFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Usuario
     */
    select?: UsuarioSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UsuarioInclude<ExtArgs> | null
    /**
     * Filter, which Usuarios to fetch.
     */
    where?: UsuarioWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Usuarios to fetch.
     */
    orderBy?: UsuarioOrderByWithRelationInput | UsuarioOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing Usuarios.
     */
    cursor?: UsuarioWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Usuarios from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Usuarios.
     */
    skip?: number
    distinct?: UsuarioScalarFieldEnum | UsuarioScalarFieldEnum[]
  }

  /**
   * Usuario create
   */
  export type UsuarioCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Usuario
     */
    select?: UsuarioSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UsuarioInclude<ExtArgs> | null
    /**
     * The data needed to create a Usuario.
     */
    data: XOR<UsuarioCreateInput, UsuarioUncheckedCreateInput>
  }

  /**
   * Usuario createMany
   */
  export type UsuarioCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many Usuarios.
     */
    data: UsuarioCreateManyInput | UsuarioCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * Usuario update
   */
  export type UsuarioUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Usuario
     */
    select?: UsuarioSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UsuarioInclude<ExtArgs> | null
    /**
     * The data needed to update a Usuario.
     */
    data: XOR<UsuarioUpdateInput, UsuarioUncheckedUpdateInput>
    /**
     * Choose, which Usuario to update.
     */
    where: UsuarioWhereUniqueInput
  }

  /**
   * Usuario updateMany
   */
  export type UsuarioUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update Usuarios.
     */
    data: XOR<UsuarioUpdateManyMutationInput, UsuarioUncheckedUpdateManyInput>
    /**
     * Filter which Usuarios to update
     */
    where?: UsuarioWhereInput
  }

  /**
   * Usuario upsert
   */
  export type UsuarioUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Usuario
     */
    select?: UsuarioSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UsuarioInclude<ExtArgs> | null
    /**
     * The filter to search for the Usuario to update in case it exists.
     */
    where: UsuarioWhereUniqueInput
    /**
     * In case the Usuario found by the `where` argument doesn't exist, create a new Usuario with this data.
     */
    create: XOR<UsuarioCreateInput, UsuarioUncheckedCreateInput>
    /**
     * In case the Usuario was found with the provided `where` argument, update it with this data.
     */
    update: XOR<UsuarioUpdateInput, UsuarioUncheckedUpdateInput>
  }

  /**
   * Usuario delete
   */
  export type UsuarioDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Usuario
     */
    select?: UsuarioSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UsuarioInclude<ExtArgs> | null
    /**
     * Filter which Usuario to delete.
     */
    where: UsuarioWhereUniqueInput
  }

  /**
   * Usuario deleteMany
   */
  export type UsuarioDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Usuarios to delete
     */
    where?: UsuarioWhereInput
  }

  /**
   * Usuario without action
   */
  export type UsuarioDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Usuario
     */
    select?: UsuarioSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UsuarioInclude<ExtArgs> | null
  }


  /**
   * Model TipoRol
   */

  export type AggregateTipoRol = {
    _count: TipoRolCountAggregateOutputType | null
    _avg: TipoRolAvgAggregateOutputType | null
    _sum: TipoRolSumAggregateOutputType | null
    _min: TipoRolMinAggregateOutputType | null
    _max: TipoRolMaxAggregateOutputType | null
  }

  export type TipoRolAvgAggregateOutputType = {
    id_tipo_rol: number | null
  }

  export type TipoRolSumAggregateOutputType = {
    id_tipo_rol: number | null
  }

  export type TipoRolMinAggregateOutputType = {
    id_tipo_rol: number | null
    nombre_rol: string | null
    descripcion: string | null
  }

  export type TipoRolMaxAggregateOutputType = {
    id_tipo_rol: number | null
    nombre_rol: string | null
    descripcion: string | null
  }

  export type TipoRolCountAggregateOutputType = {
    id_tipo_rol: number
    nombre_rol: number
    descripcion: number
    _all: number
  }


  export type TipoRolAvgAggregateInputType = {
    id_tipo_rol?: true
  }

  export type TipoRolSumAggregateInputType = {
    id_tipo_rol?: true
  }

  export type TipoRolMinAggregateInputType = {
    id_tipo_rol?: true
    nombre_rol?: true
    descripcion?: true
  }

  export type TipoRolMaxAggregateInputType = {
    id_tipo_rol?: true
    nombre_rol?: true
    descripcion?: true
  }

  export type TipoRolCountAggregateInputType = {
    id_tipo_rol?: true
    nombre_rol?: true
    descripcion?: true
    _all?: true
  }

  export type TipoRolAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which TipoRol to aggregate.
     */
    where?: TipoRolWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of TipoRols to fetch.
     */
    orderBy?: TipoRolOrderByWithRelationInput | TipoRolOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: TipoRolWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` TipoRols from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` TipoRols.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned TipoRols
    **/
    _count?: true | TipoRolCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: TipoRolAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: TipoRolSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: TipoRolMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: TipoRolMaxAggregateInputType
  }

  export type GetTipoRolAggregateType<T extends TipoRolAggregateArgs> = {
        [P in keyof T & keyof AggregateTipoRol]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateTipoRol[P]>
      : GetScalarType<T[P], AggregateTipoRol[P]>
  }




  export type TipoRolGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: TipoRolWhereInput
    orderBy?: TipoRolOrderByWithAggregationInput | TipoRolOrderByWithAggregationInput[]
    by: TipoRolScalarFieldEnum[] | TipoRolScalarFieldEnum
    having?: TipoRolScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: TipoRolCountAggregateInputType | true
    _avg?: TipoRolAvgAggregateInputType
    _sum?: TipoRolSumAggregateInputType
    _min?: TipoRolMinAggregateInputType
    _max?: TipoRolMaxAggregateInputType
  }

  export type TipoRolGroupByOutputType = {
    id_tipo_rol: number
    nombre_rol: string
    descripcion: string | null
    _count: TipoRolCountAggregateOutputType | null
    _avg: TipoRolAvgAggregateOutputType | null
    _sum: TipoRolSumAggregateOutputType | null
    _min: TipoRolMinAggregateOutputType | null
    _max: TipoRolMaxAggregateOutputType | null
  }

  type GetTipoRolGroupByPayload<T extends TipoRolGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<TipoRolGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof TipoRolGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], TipoRolGroupByOutputType[P]>
            : GetScalarType<T[P], TipoRolGroupByOutputType[P]>
        }
      >
    >


  export type TipoRolSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id_tipo_rol?: boolean
    nombre_rol?: boolean
    descripcion?: boolean
    usuarios?: boolean | TipoRol$usuariosArgs<ExtArgs>
    _count?: boolean | TipoRolCountOutputTypeDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["tipoRol"]>


  export type TipoRolSelectScalar = {
    id_tipo_rol?: boolean
    nombre_rol?: boolean
    descripcion?: boolean
  }

  export type TipoRolInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    usuarios?: boolean | TipoRol$usuariosArgs<ExtArgs>
    _count?: boolean | TipoRolCountOutputTypeDefaultArgs<ExtArgs>
  }

  export type $TipoRolPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "TipoRol"
    objects: {
      usuarios: Prisma.$UsuarioPayload<ExtArgs>[]
    }
    scalars: $Extensions.GetPayloadResult<{
      id_tipo_rol: number
      nombre_rol: string
      descripcion: string | null
    }, ExtArgs["result"]["tipoRol"]>
    composites: {}
  }

  type TipoRolGetPayload<S extends boolean | null | undefined | TipoRolDefaultArgs> = $Result.GetResult<Prisma.$TipoRolPayload, S>

  type TipoRolCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = 
    Omit<TipoRolFindManyArgs, 'select' | 'include' | 'distinct'> & {
      select?: TipoRolCountAggregateInputType | true
    }

  export interface TipoRolDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['TipoRol'], meta: { name: 'TipoRol' } }
    /**
     * Find zero or one TipoRol that matches the filter.
     * @param {TipoRolFindUniqueArgs} args - Arguments to find a TipoRol
     * @example
     * // Get one TipoRol
     * const tipoRol = await prisma.tipoRol.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends TipoRolFindUniqueArgs>(args: SelectSubset<T, TipoRolFindUniqueArgs<ExtArgs>>): Prisma__TipoRolClient<$Result.GetResult<Prisma.$TipoRolPayload<ExtArgs>, T, "findUnique"> | null, null, ExtArgs>

    /**
     * Find one TipoRol that matches the filter or throw an error with `error.code='P2025'` 
     * if no matches were found.
     * @param {TipoRolFindUniqueOrThrowArgs} args - Arguments to find a TipoRol
     * @example
     * // Get one TipoRol
     * const tipoRol = await prisma.tipoRol.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends TipoRolFindUniqueOrThrowArgs>(args: SelectSubset<T, TipoRolFindUniqueOrThrowArgs<ExtArgs>>): Prisma__TipoRolClient<$Result.GetResult<Prisma.$TipoRolPayload<ExtArgs>, T, "findUniqueOrThrow">, never, ExtArgs>

    /**
     * Find the first TipoRol that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {TipoRolFindFirstArgs} args - Arguments to find a TipoRol
     * @example
     * // Get one TipoRol
     * const tipoRol = await prisma.tipoRol.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends TipoRolFindFirstArgs>(args?: SelectSubset<T, TipoRolFindFirstArgs<ExtArgs>>): Prisma__TipoRolClient<$Result.GetResult<Prisma.$TipoRolPayload<ExtArgs>, T, "findFirst"> | null, null, ExtArgs>

    /**
     * Find the first TipoRol that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {TipoRolFindFirstOrThrowArgs} args - Arguments to find a TipoRol
     * @example
     * // Get one TipoRol
     * const tipoRol = await prisma.tipoRol.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends TipoRolFindFirstOrThrowArgs>(args?: SelectSubset<T, TipoRolFindFirstOrThrowArgs<ExtArgs>>): Prisma__TipoRolClient<$Result.GetResult<Prisma.$TipoRolPayload<ExtArgs>, T, "findFirstOrThrow">, never, ExtArgs>

    /**
     * Find zero or more TipoRols that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {TipoRolFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all TipoRols
     * const tipoRols = await prisma.tipoRol.findMany()
     * 
     * // Get first 10 TipoRols
     * const tipoRols = await prisma.tipoRol.findMany({ take: 10 })
     * 
     * // Only select the `id_tipo_rol`
     * const tipoRolWithId_tipo_rolOnly = await prisma.tipoRol.findMany({ select: { id_tipo_rol: true } })
     * 
     */
    findMany<T extends TipoRolFindManyArgs>(args?: SelectSubset<T, TipoRolFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$TipoRolPayload<ExtArgs>, T, "findMany">>

    /**
     * Create a TipoRol.
     * @param {TipoRolCreateArgs} args - Arguments to create a TipoRol.
     * @example
     * // Create one TipoRol
     * const TipoRol = await prisma.tipoRol.create({
     *   data: {
     *     // ... data to create a TipoRol
     *   }
     * })
     * 
     */
    create<T extends TipoRolCreateArgs>(args: SelectSubset<T, TipoRolCreateArgs<ExtArgs>>): Prisma__TipoRolClient<$Result.GetResult<Prisma.$TipoRolPayload<ExtArgs>, T, "create">, never, ExtArgs>

    /**
     * Create many TipoRols.
     * @param {TipoRolCreateManyArgs} args - Arguments to create many TipoRols.
     * @example
     * // Create many TipoRols
     * const tipoRol = await prisma.tipoRol.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends TipoRolCreateManyArgs>(args?: SelectSubset<T, TipoRolCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Delete a TipoRol.
     * @param {TipoRolDeleteArgs} args - Arguments to delete one TipoRol.
     * @example
     * // Delete one TipoRol
     * const TipoRol = await prisma.tipoRol.delete({
     *   where: {
     *     // ... filter to delete one TipoRol
     *   }
     * })
     * 
     */
    delete<T extends TipoRolDeleteArgs>(args: SelectSubset<T, TipoRolDeleteArgs<ExtArgs>>): Prisma__TipoRolClient<$Result.GetResult<Prisma.$TipoRolPayload<ExtArgs>, T, "delete">, never, ExtArgs>

    /**
     * Update one TipoRol.
     * @param {TipoRolUpdateArgs} args - Arguments to update one TipoRol.
     * @example
     * // Update one TipoRol
     * const tipoRol = await prisma.tipoRol.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends TipoRolUpdateArgs>(args: SelectSubset<T, TipoRolUpdateArgs<ExtArgs>>): Prisma__TipoRolClient<$Result.GetResult<Prisma.$TipoRolPayload<ExtArgs>, T, "update">, never, ExtArgs>

    /**
     * Delete zero or more TipoRols.
     * @param {TipoRolDeleteManyArgs} args - Arguments to filter TipoRols to delete.
     * @example
     * // Delete a few TipoRols
     * const { count } = await prisma.tipoRol.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends TipoRolDeleteManyArgs>(args?: SelectSubset<T, TipoRolDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more TipoRols.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {TipoRolUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many TipoRols
     * const tipoRol = await prisma.tipoRol.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends TipoRolUpdateManyArgs>(args: SelectSubset<T, TipoRolUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one TipoRol.
     * @param {TipoRolUpsertArgs} args - Arguments to update or create a TipoRol.
     * @example
     * // Update or create a TipoRol
     * const tipoRol = await prisma.tipoRol.upsert({
     *   create: {
     *     // ... data to create a TipoRol
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the TipoRol we want to update
     *   }
     * })
     */
    upsert<T extends TipoRolUpsertArgs>(args: SelectSubset<T, TipoRolUpsertArgs<ExtArgs>>): Prisma__TipoRolClient<$Result.GetResult<Prisma.$TipoRolPayload<ExtArgs>, T, "upsert">, never, ExtArgs>


    /**
     * Count the number of TipoRols.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {TipoRolCountArgs} args - Arguments to filter TipoRols to count.
     * @example
     * // Count the number of TipoRols
     * const count = await prisma.tipoRol.count({
     *   where: {
     *     // ... the filter for the TipoRols we want to count
     *   }
     * })
    **/
    count<T extends TipoRolCountArgs>(
      args?: Subset<T, TipoRolCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], TipoRolCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a TipoRol.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {TipoRolAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends TipoRolAggregateArgs>(args: Subset<T, TipoRolAggregateArgs>): Prisma.PrismaPromise<GetTipoRolAggregateType<T>>

    /**
     * Group by TipoRol.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {TipoRolGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends TipoRolGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: TipoRolGroupByArgs['orderBy'] }
        : { orderBy?: TipoRolGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, TipoRolGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetTipoRolGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the TipoRol model
   */
  readonly fields: TipoRolFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for TipoRol.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__TipoRolClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    usuarios<T extends TipoRol$usuariosArgs<ExtArgs> = {}>(args?: Subset<T, TipoRol$usuariosArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$UsuarioPayload<ExtArgs>, T, "findMany"> | Null>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the TipoRol model
   */ 
  interface TipoRolFieldRefs {
    readonly id_tipo_rol: FieldRef<"TipoRol", 'Int'>
    readonly nombre_rol: FieldRef<"TipoRol", 'String'>
    readonly descripcion: FieldRef<"TipoRol", 'String'>
  }
    

  // Custom InputTypes
  /**
   * TipoRol findUnique
   */
  export type TipoRolFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the TipoRol
     */
    select?: TipoRolSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TipoRolInclude<ExtArgs> | null
    /**
     * Filter, which TipoRol to fetch.
     */
    where: TipoRolWhereUniqueInput
  }

  /**
   * TipoRol findUniqueOrThrow
   */
  export type TipoRolFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the TipoRol
     */
    select?: TipoRolSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TipoRolInclude<ExtArgs> | null
    /**
     * Filter, which TipoRol to fetch.
     */
    where: TipoRolWhereUniqueInput
  }

  /**
   * TipoRol findFirst
   */
  export type TipoRolFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the TipoRol
     */
    select?: TipoRolSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TipoRolInclude<ExtArgs> | null
    /**
     * Filter, which TipoRol to fetch.
     */
    where?: TipoRolWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of TipoRols to fetch.
     */
    orderBy?: TipoRolOrderByWithRelationInput | TipoRolOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for TipoRols.
     */
    cursor?: TipoRolWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` TipoRols from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` TipoRols.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of TipoRols.
     */
    distinct?: TipoRolScalarFieldEnum | TipoRolScalarFieldEnum[]
  }

  /**
   * TipoRol findFirstOrThrow
   */
  export type TipoRolFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the TipoRol
     */
    select?: TipoRolSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TipoRolInclude<ExtArgs> | null
    /**
     * Filter, which TipoRol to fetch.
     */
    where?: TipoRolWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of TipoRols to fetch.
     */
    orderBy?: TipoRolOrderByWithRelationInput | TipoRolOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for TipoRols.
     */
    cursor?: TipoRolWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` TipoRols from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` TipoRols.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of TipoRols.
     */
    distinct?: TipoRolScalarFieldEnum | TipoRolScalarFieldEnum[]
  }

  /**
   * TipoRol findMany
   */
  export type TipoRolFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the TipoRol
     */
    select?: TipoRolSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TipoRolInclude<ExtArgs> | null
    /**
     * Filter, which TipoRols to fetch.
     */
    where?: TipoRolWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of TipoRols to fetch.
     */
    orderBy?: TipoRolOrderByWithRelationInput | TipoRolOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing TipoRols.
     */
    cursor?: TipoRolWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` TipoRols from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` TipoRols.
     */
    skip?: number
    distinct?: TipoRolScalarFieldEnum | TipoRolScalarFieldEnum[]
  }

  /**
   * TipoRol create
   */
  export type TipoRolCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the TipoRol
     */
    select?: TipoRolSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TipoRolInclude<ExtArgs> | null
    /**
     * The data needed to create a TipoRol.
     */
    data: XOR<TipoRolCreateInput, TipoRolUncheckedCreateInput>
  }

  /**
   * TipoRol createMany
   */
  export type TipoRolCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many TipoRols.
     */
    data: TipoRolCreateManyInput | TipoRolCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * TipoRol update
   */
  export type TipoRolUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the TipoRol
     */
    select?: TipoRolSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TipoRolInclude<ExtArgs> | null
    /**
     * The data needed to update a TipoRol.
     */
    data: XOR<TipoRolUpdateInput, TipoRolUncheckedUpdateInput>
    /**
     * Choose, which TipoRol to update.
     */
    where: TipoRolWhereUniqueInput
  }

  /**
   * TipoRol updateMany
   */
  export type TipoRolUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update TipoRols.
     */
    data: XOR<TipoRolUpdateManyMutationInput, TipoRolUncheckedUpdateManyInput>
    /**
     * Filter which TipoRols to update
     */
    where?: TipoRolWhereInput
  }

  /**
   * TipoRol upsert
   */
  export type TipoRolUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the TipoRol
     */
    select?: TipoRolSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TipoRolInclude<ExtArgs> | null
    /**
     * The filter to search for the TipoRol to update in case it exists.
     */
    where: TipoRolWhereUniqueInput
    /**
     * In case the TipoRol found by the `where` argument doesn't exist, create a new TipoRol with this data.
     */
    create: XOR<TipoRolCreateInput, TipoRolUncheckedCreateInput>
    /**
     * In case the TipoRol was found with the provided `where` argument, update it with this data.
     */
    update: XOR<TipoRolUpdateInput, TipoRolUncheckedUpdateInput>
  }

  /**
   * TipoRol delete
   */
  export type TipoRolDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the TipoRol
     */
    select?: TipoRolSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TipoRolInclude<ExtArgs> | null
    /**
     * Filter which TipoRol to delete.
     */
    where: TipoRolWhereUniqueInput
  }

  /**
   * TipoRol deleteMany
   */
  export type TipoRolDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which TipoRols to delete
     */
    where?: TipoRolWhereInput
  }

  /**
   * TipoRol.usuarios
   */
  export type TipoRol$usuariosArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Usuario
     */
    select?: UsuarioSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UsuarioInclude<ExtArgs> | null
    where?: UsuarioWhereInput
    orderBy?: UsuarioOrderByWithRelationInput | UsuarioOrderByWithRelationInput[]
    cursor?: UsuarioWhereUniqueInput
    take?: number
    skip?: number
    distinct?: UsuarioScalarFieldEnum | UsuarioScalarFieldEnum[]
  }

  /**
   * TipoRol without action
   */
  export type TipoRolDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the TipoRol
     */
    select?: TipoRolSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TipoRolInclude<ExtArgs> | null
  }


  /**
   * Model Alerta
   */

  export type AggregateAlerta = {
    _count: AlertaCountAggregateOutputType | null
    _avg: AlertaAvgAggregateOutputType | null
    _sum: AlertaSumAggregateOutputType | null
    _min: AlertaMinAggregateOutputType | null
    _max: AlertaMaxAggregateOutputType | null
  }

  export type AlertaAvgAggregateOutputType = {
    id_alerta: number | null
    id_sensor_instalado: number | null
  }

  export type AlertaSumAggregateOutputType = {
    id_alerta: number | null
    id_sensor_instalado: number | null
  }

  export type AlertaMinAggregateOutputType = {
    id_alerta: number | null
    id_sensor_instalado: number | null
    tipo_alerta: string | null
    mensaje: string | null
    nivel: $Enums.NivelAlerta | null
    fecha_generada: Date | null
    fecha_resuelta: Date | null
    estado: string | null
  }

  export type AlertaMaxAggregateOutputType = {
    id_alerta: number | null
    id_sensor_instalado: number | null
    tipo_alerta: string | null
    mensaje: string | null
    nivel: $Enums.NivelAlerta | null
    fecha_generada: Date | null
    fecha_resuelta: Date | null
    estado: string | null
  }

  export type AlertaCountAggregateOutputType = {
    id_alerta: number
    id_sensor_instalado: number
    tipo_alerta: number
    mensaje: number
    nivel: number
    fecha_generada: number
    fecha_resuelta: number
    estado: number
    _all: number
  }


  export type AlertaAvgAggregateInputType = {
    id_alerta?: true
    id_sensor_instalado?: true
  }

  export type AlertaSumAggregateInputType = {
    id_alerta?: true
    id_sensor_instalado?: true
  }

  export type AlertaMinAggregateInputType = {
    id_alerta?: true
    id_sensor_instalado?: true
    tipo_alerta?: true
    mensaje?: true
    nivel?: true
    fecha_generada?: true
    fecha_resuelta?: true
    estado?: true
  }

  export type AlertaMaxAggregateInputType = {
    id_alerta?: true
    id_sensor_instalado?: true
    tipo_alerta?: true
    mensaje?: true
    nivel?: true
    fecha_generada?: true
    fecha_resuelta?: true
    estado?: true
  }

  export type AlertaCountAggregateInputType = {
    id_alerta?: true
    id_sensor_instalado?: true
    tipo_alerta?: true
    mensaje?: true
    nivel?: true
    fecha_generada?: true
    fecha_resuelta?: true
    estado?: true
    _all?: true
  }

  export type AlertaAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Alerta to aggregate.
     */
    where?: AlertaWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Alertas to fetch.
     */
    orderBy?: AlertaOrderByWithRelationInput | AlertaOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: AlertaWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Alertas from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Alertas.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned Alertas
    **/
    _count?: true | AlertaCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: AlertaAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: AlertaSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: AlertaMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: AlertaMaxAggregateInputType
  }

  export type GetAlertaAggregateType<T extends AlertaAggregateArgs> = {
        [P in keyof T & keyof AggregateAlerta]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateAlerta[P]>
      : GetScalarType<T[P], AggregateAlerta[P]>
  }




  export type AlertaGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: AlertaWhereInput
    orderBy?: AlertaOrderByWithAggregationInput | AlertaOrderByWithAggregationInput[]
    by: AlertaScalarFieldEnum[] | AlertaScalarFieldEnum
    having?: AlertaScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: AlertaCountAggregateInputType | true
    _avg?: AlertaAvgAggregateInputType
    _sum?: AlertaSumAggregateInputType
    _min?: AlertaMinAggregateInputType
    _max?: AlertaMaxAggregateInputType
  }

  export type AlertaGroupByOutputType = {
    id_alerta: number
    id_sensor_instalado: number
    tipo_alerta: string
    mensaje: string
    nivel: $Enums.NivelAlerta
    fecha_generada: Date
    fecha_resuelta: Date | null
    estado: string
    _count: AlertaCountAggregateOutputType | null
    _avg: AlertaAvgAggregateOutputType | null
    _sum: AlertaSumAggregateOutputType | null
    _min: AlertaMinAggregateOutputType | null
    _max: AlertaMaxAggregateOutputType | null
  }

  type GetAlertaGroupByPayload<T extends AlertaGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<AlertaGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof AlertaGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], AlertaGroupByOutputType[P]>
            : GetScalarType<T[P], AlertaGroupByOutputType[P]>
        }
      >
    >


  export type AlertaSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id_alerta?: boolean
    id_sensor_instalado?: boolean
    tipo_alerta?: boolean
    mensaje?: boolean
    nivel?: boolean
    fecha_generada?: boolean
    fecha_resuelta?: boolean
    estado?: boolean
  }, ExtArgs["result"]["alerta"]>


  export type AlertaSelectScalar = {
    id_alerta?: boolean
    id_sensor_instalado?: boolean
    tipo_alerta?: boolean
    mensaje?: boolean
    nivel?: boolean
    fecha_generada?: boolean
    fecha_resuelta?: boolean
    estado?: boolean
  }


  export type $AlertaPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "Alerta"
    objects: {}
    scalars: $Extensions.GetPayloadResult<{
      id_alerta: number
      id_sensor_instalado: number
      tipo_alerta: string
      mensaje: string
      nivel: $Enums.NivelAlerta
      fecha_generada: Date
      fecha_resuelta: Date | null
      estado: string
    }, ExtArgs["result"]["alerta"]>
    composites: {}
  }

  type AlertaGetPayload<S extends boolean | null | undefined | AlertaDefaultArgs> = $Result.GetResult<Prisma.$AlertaPayload, S>

  type AlertaCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = 
    Omit<AlertaFindManyArgs, 'select' | 'include' | 'distinct'> & {
      select?: AlertaCountAggregateInputType | true
    }

  export interface AlertaDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['Alerta'], meta: { name: 'Alerta' } }
    /**
     * Find zero or one Alerta that matches the filter.
     * @param {AlertaFindUniqueArgs} args - Arguments to find a Alerta
     * @example
     * // Get one Alerta
     * const alerta = await prisma.alerta.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends AlertaFindUniqueArgs>(args: SelectSubset<T, AlertaFindUniqueArgs<ExtArgs>>): Prisma__AlertaClient<$Result.GetResult<Prisma.$AlertaPayload<ExtArgs>, T, "findUnique"> | null, null, ExtArgs>

    /**
     * Find one Alerta that matches the filter or throw an error with `error.code='P2025'` 
     * if no matches were found.
     * @param {AlertaFindUniqueOrThrowArgs} args - Arguments to find a Alerta
     * @example
     * // Get one Alerta
     * const alerta = await prisma.alerta.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends AlertaFindUniqueOrThrowArgs>(args: SelectSubset<T, AlertaFindUniqueOrThrowArgs<ExtArgs>>): Prisma__AlertaClient<$Result.GetResult<Prisma.$AlertaPayload<ExtArgs>, T, "findUniqueOrThrow">, never, ExtArgs>

    /**
     * Find the first Alerta that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {AlertaFindFirstArgs} args - Arguments to find a Alerta
     * @example
     * // Get one Alerta
     * const alerta = await prisma.alerta.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends AlertaFindFirstArgs>(args?: SelectSubset<T, AlertaFindFirstArgs<ExtArgs>>): Prisma__AlertaClient<$Result.GetResult<Prisma.$AlertaPayload<ExtArgs>, T, "findFirst"> | null, null, ExtArgs>

    /**
     * Find the first Alerta that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {AlertaFindFirstOrThrowArgs} args - Arguments to find a Alerta
     * @example
     * // Get one Alerta
     * const alerta = await prisma.alerta.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends AlertaFindFirstOrThrowArgs>(args?: SelectSubset<T, AlertaFindFirstOrThrowArgs<ExtArgs>>): Prisma__AlertaClient<$Result.GetResult<Prisma.$AlertaPayload<ExtArgs>, T, "findFirstOrThrow">, never, ExtArgs>

    /**
     * Find zero or more Alertas that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {AlertaFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Alertas
     * const alertas = await prisma.alerta.findMany()
     * 
     * // Get first 10 Alertas
     * const alertas = await prisma.alerta.findMany({ take: 10 })
     * 
     * // Only select the `id_alerta`
     * const alertaWithId_alertaOnly = await prisma.alerta.findMany({ select: { id_alerta: true } })
     * 
     */
    findMany<T extends AlertaFindManyArgs>(args?: SelectSubset<T, AlertaFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$AlertaPayload<ExtArgs>, T, "findMany">>

    /**
     * Create a Alerta.
     * @param {AlertaCreateArgs} args - Arguments to create a Alerta.
     * @example
     * // Create one Alerta
     * const Alerta = await prisma.alerta.create({
     *   data: {
     *     // ... data to create a Alerta
     *   }
     * })
     * 
     */
    create<T extends AlertaCreateArgs>(args: SelectSubset<T, AlertaCreateArgs<ExtArgs>>): Prisma__AlertaClient<$Result.GetResult<Prisma.$AlertaPayload<ExtArgs>, T, "create">, never, ExtArgs>

    /**
     * Create many Alertas.
     * @param {AlertaCreateManyArgs} args - Arguments to create many Alertas.
     * @example
     * // Create many Alertas
     * const alerta = await prisma.alerta.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends AlertaCreateManyArgs>(args?: SelectSubset<T, AlertaCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Delete a Alerta.
     * @param {AlertaDeleteArgs} args - Arguments to delete one Alerta.
     * @example
     * // Delete one Alerta
     * const Alerta = await prisma.alerta.delete({
     *   where: {
     *     // ... filter to delete one Alerta
     *   }
     * })
     * 
     */
    delete<T extends AlertaDeleteArgs>(args: SelectSubset<T, AlertaDeleteArgs<ExtArgs>>): Prisma__AlertaClient<$Result.GetResult<Prisma.$AlertaPayload<ExtArgs>, T, "delete">, never, ExtArgs>

    /**
     * Update one Alerta.
     * @param {AlertaUpdateArgs} args - Arguments to update one Alerta.
     * @example
     * // Update one Alerta
     * const alerta = await prisma.alerta.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends AlertaUpdateArgs>(args: SelectSubset<T, AlertaUpdateArgs<ExtArgs>>): Prisma__AlertaClient<$Result.GetResult<Prisma.$AlertaPayload<ExtArgs>, T, "update">, never, ExtArgs>

    /**
     * Delete zero or more Alertas.
     * @param {AlertaDeleteManyArgs} args - Arguments to filter Alertas to delete.
     * @example
     * // Delete a few Alertas
     * const { count } = await prisma.alerta.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends AlertaDeleteManyArgs>(args?: SelectSubset<T, AlertaDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Alertas.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {AlertaUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Alertas
     * const alerta = await prisma.alerta.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends AlertaUpdateManyArgs>(args: SelectSubset<T, AlertaUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one Alerta.
     * @param {AlertaUpsertArgs} args - Arguments to update or create a Alerta.
     * @example
     * // Update or create a Alerta
     * const alerta = await prisma.alerta.upsert({
     *   create: {
     *     // ... data to create a Alerta
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Alerta we want to update
     *   }
     * })
     */
    upsert<T extends AlertaUpsertArgs>(args: SelectSubset<T, AlertaUpsertArgs<ExtArgs>>): Prisma__AlertaClient<$Result.GetResult<Prisma.$AlertaPayload<ExtArgs>, T, "upsert">, never, ExtArgs>


    /**
     * Count the number of Alertas.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {AlertaCountArgs} args - Arguments to filter Alertas to count.
     * @example
     * // Count the number of Alertas
     * const count = await prisma.alerta.count({
     *   where: {
     *     // ... the filter for the Alertas we want to count
     *   }
     * })
    **/
    count<T extends AlertaCountArgs>(
      args?: Subset<T, AlertaCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], AlertaCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Alerta.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {AlertaAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends AlertaAggregateArgs>(args: Subset<T, AlertaAggregateArgs>): Prisma.PrismaPromise<GetAlertaAggregateType<T>>

    /**
     * Group by Alerta.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {AlertaGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends AlertaGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: AlertaGroupByArgs['orderBy'] }
        : { orderBy?: AlertaGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, AlertaGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetAlertaGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the Alerta model
   */
  readonly fields: AlertaFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for Alerta.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__AlertaClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the Alerta model
   */ 
  interface AlertaFieldRefs {
    readonly id_alerta: FieldRef<"Alerta", 'Int'>
    readonly id_sensor_instalado: FieldRef<"Alerta", 'Int'>
    readonly tipo_alerta: FieldRef<"Alerta", 'String'>
    readonly mensaje: FieldRef<"Alerta", 'String'>
    readonly nivel: FieldRef<"Alerta", 'NivelAlerta'>
    readonly fecha_generada: FieldRef<"Alerta", 'DateTime'>
    readonly fecha_resuelta: FieldRef<"Alerta", 'DateTime'>
    readonly estado: FieldRef<"Alerta", 'String'>
  }
    

  // Custom InputTypes
  /**
   * Alerta findUnique
   */
  export type AlertaFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Alerta
     */
    select?: AlertaSelect<ExtArgs> | null
    /**
     * Filter, which Alerta to fetch.
     */
    where: AlertaWhereUniqueInput
  }

  /**
   * Alerta findUniqueOrThrow
   */
  export type AlertaFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Alerta
     */
    select?: AlertaSelect<ExtArgs> | null
    /**
     * Filter, which Alerta to fetch.
     */
    where: AlertaWhereUniqueInput
  }

  /**
   * Alerta findFirst
   */
  export type AlertaFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Alerta
     */
    select?: AlertaSelect<ExtArgs> | null
    /**
     * Filter, which Alerta to fetch.
     */
    where?: AlertaWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Alertas to fetch.
     */
    orderBy?: AlertaOrderByWithRelationInput | AlertaOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Alertas.
     */
    cursor?: AlertaWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Alertas from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Alertas.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Alertas.
     */
    distinct?: AlertaScalarFieldEnum | AlertaScalarFieldEnum[]
  }

  /**
   * Alerta findFirstOrThrow
   */
  export type AlertaFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Alerta
     */
    select?: AlertaSelect<ExtArgs> | null
    /**
     * Filter, which Alerta to fetch.
     */
    where?: AlertaWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Alertas to fetch.
     */
    orderBy?: AlertaOrderByWithRelationInput | AlertaOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Alertas.
     */
    cursor?: AlertaWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Alertas from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Alertas.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Alertas.
     */
    distinct?: AlertaScalarFieldEnum | AlertaScalarFieldEnum[]
  }

  /**
   * Alerta findMany
   */
  export type AlertaFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Alerta
     */
    select?: AlertaSelect<ExtArgs> | null
    /**
     * Filter, which Alertas to fetch.
     */
    where?: AlertaWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Alertas to fetch.
     */
    orderBy?: AlertaOrderByWithRelationInput | AlertaOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing Alertas.
     */
    cursor?: AlertaWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Alertas from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Alertas.
     */
    skip?: number
    distinct?: AlertaScalarFieldEnum | AlertaScalarFieldEnum[]
  }

  /**
   * Alerta create
   */
  export type AlertaCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Alerta
     */
    select?: AlertaSelect<ExtArgs> | null
    /**
     * The data needed to create a Alerta.
     */
    data: XOR<AlertaCreateInput, AlertaUncheckedCreateInput>
  }

  /**
   * Alerta createMany
   */
  export type AlertaCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many Alertas.
     */
    data: AlertaCreateManyInput | AlertaCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * Alerta update
   */
  export type AlertaUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Alerta
     */
    select?: AlertaSelect<ExtArgs> | null
    /**
     * The data needed to update a Alerta.
     */
    data: XOR<AlertaUpdateInput, AlertaUncheckedUpdateInput>
    /**
     * Choose, which Alerta to update.
     */
    where: AlertaWhereUniqueInput
  }

  /**
   * Alerta updateMany
   */
  export type AlertaUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update Alertas.
     */
    data: XOR<AlertaUpdateManyMutationInput, AlertaUncheckedUpdateManyInput>
    /**
     * Filter which Alertas to update
     */
    where?: AlertaWhereInput
  }

  /**
   * Alerta upsert
   */
  export type AlertaUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Alerta
     */
    select?: AlertaSelect<ExtArgs> | null
    /**
     * The filter to search for the Alerta to update in case it exists.
     */
    where: AlertaWhereUniqueInput
    /**
     * In case the Alerta found by the `where` argument doesn't exist, create a new Alerta with this data.
     */
    create: XOR<AlertaCreateInput, AlertaUncheckedCreateInput>
    /**
     * In case the Alerta was found with the provided `where` argument, update it with this data.
     */
    update: XOR<AlertaUpdateInput, AlertaUncheckedUpdateInput>
  }

  /**
   * Alerta delete
   */
  export type AlertaDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Alerta
     */
    select?: AlertaSelect<ExtArgs> | null
    /**
     * Filter which Alerta to delete.
     */
    where: AlertaWhereUniqueInput
  }

  /**
   * Alerta deleteMany
   */
  export type AlertaDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Alertas to delete
     */
    where?: AlertaWhereInput
  }

  /**
   * Alerta without action
   */
  export type AlertaDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Alerta
     */
    select?: AlertaSelect<ExtArgs> | null
  }


  /**
   * Model Parametro
   */

  export type AggregateParametro = {
    _count: ParametroCountAggregateOutputType | null
    _avg: ParametroAvgAggregateOutputType | null
    _sum: ParametroSumAggregateOutputType | null
    _min: ParametroMinAggregateOutputType | null
    _max: ParametroMaxAggregateOutputType | null
  }

  export type ParametroAvgAggregateOutputType = {
    id_parametro: number | null
    rango_min: Decimal | null
    rango_max: Decimal | null
  }

  export type ParametroSumAggregateOutputType = {
    id_parametro: number | null
    rango_min: Decimal | null
    rango_max: Decimal | null
  }

  export type ParametroMinAggregateOutputType = {
    id_parametro: number | null
    nombre: string | null
    unidad: string | null
    descripcion: string | null
    rango_min: Decimal | null
    rango_max: Decimal | null
  }

  export type ParametroMaxAggregateOutputType = {
    id_parametro: number | null
    nombre: string | null
    unidad: string | null
    descripcion: string | null
    rango_min: Decimal | null
    rango_max: Decimal | null
  }

  export type ParametroCountAggregateOutputType = {
    id_parametro: number
    nombre: number
    unidad: number
    descripcion: number
    rango_min: number
    rango_max: number
    _all: number
  }


  export type ParametroAvgAggregateInputType = {
    id_parametro?: true
    rango_min?: true
    rango_max?: true
  }

  export type ParametroSumAggregateInputType = {
    id_parametro?: true
    rango_min?: true
    rango_max?: true
  }

  export type ParametroMinAggregateInputType = {
    id_parametro?: true
    nombre?: true
    unidad?: true
    descripcion?: true
    rango_min?: true
    rango_max?: true
  }

  export type ParametroMaxAggregateInputType = {
    id_parametro?: true
    nombre?: true
    unidad?: true
    descripcion?: true
    rango_min?: true
    rango_max?: true
  }

  export type ParametroCountAggregateInputType = {
    id_parametro?: true
    nombre?: true
    unidad?: true
    descripcion?: true
    rango_min?: true
    rango_max?: true
    _all?: true
  }

  export type ParametroAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Parametro to aggregate.
     */
    where?: ParametroWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Parametros to fetch.
     */
    orderBy?: ParametroOrderByWithRelationInput | ParametroOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: ParametroWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Parametros from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Parametros.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned Parametros
    **/
    _count?: true | ParametroCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: ParametroAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: ParametroSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: ParametroMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: ParametroMaxAggregateInputType
  }

  export type GetParametroAggregateType<T extends ParametroAggregateArgs> = {
        [P in keyof T & keyof AggregateParametro]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateParametro[P]>
      : GetScalarType<T[P], AggregateParametro[P]>
  }




  export type ParametroGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: ParametroWhereInput
    orderBy?: ParametroOrderByWithAggregationInput | ParametroOrderByWithAggregationInput[]
    by: ParametroScalarFieldEnum[] | ParametroScalarFieldEnum
    having?: ParametroScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: ParametroCountAggregateInputType | true
    _avg?: ParametroAvgAggregateInputType
    _sum?: ParametroSumAggregateInputType
    _min?: ParametroMinAggregateInputType
    _max?: ParametroMaxAggregateInputType
  }

  export type ParametroGroupByOutputType = {
    id_parametro: number
    nombre: string
    unidad: string | null
    descripcion: string | null
    rango_min: Decimal | null
    rango_max: Decimal | null
    _count: ParametroCountAggregateOutputType | null
    _avg: ParametroAvgAggregateOutputType | null
    _sum: ParametroSumAggregateOutputType | null
    _min: ParametroMinAggregateOutputType | null
    _max: ParametroMaxAggregateOutputType | null
  }

  type GetParametroGroupByPayload<T extends ParametroGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<ParametroGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof ParametroGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], ParametroGroupByOutputType[P]>
            : GetScalarType<T[P], ParametroGroupByOutputType[P]>
        }
      >
    >


  export type ParametroSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id_parametro?: boolean
    nombre?: boolean
    unidad?: boolean
    descripcion?: boolean
    rango_min?: boolean
    rango_max?: boolean
    especieParametros?: boolean | Parametro$especieParametrosArgs<ExtArgs>
    _count?: boolean | ParametroCountOutputTypeDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["parametro"]>


  export type ParametroSelectScalar = {
    id_parametro?: boolean
    nombre?: boolean
    unidad?: boolean
    descripcion?: boolean
    rango_min?: boolean
    rango_max?: boolean
  }

  export type ParametroInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    especieParametros?: boolean | Parametro$especieParametrosArgs<ExtArgs>
    _count?: boolean | ParametroCountOutputTypeDefaultArgs<ExtArgs>
  }

  export type $ParametroPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "Parametro"
    objects: {
      especieParametros: Prisma.$EspecieParametroPayload<ExtArgs>[]
    }
    scalars: $Extensions.GetPayloadResult<{
      id_parametro: number
      nombre: string
      unidad: string | null
      descripcion: string | null
      rango_min: Prisma.Decimal | null
      rango_max: Prisma.Decimal | null
    }, ExtArgs["result"]["parametro"]>
    composites: {}
  }

  type ParametroGetPayload<S extends boolean | null | undefined | ParametroDefaultArgs> = $Result.GetResult<Prisma.$ParametroPayload, S>

  type ParametroCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = 
    Omit<ParametroFindManyArgs, 'select' | 'include' | 'distinct'> & {
      select?: ParametroCountAggregateInputType | true
    }

  export interface ParametroDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['Parametro'], meta: { name: 'Parametro' } }
    /**
     * Find zero or one Parametro that matches the filter.
     * @param {ParametroFindUniqueArgs} args - Arguments to find a Parametro
     * @example
     * // Get one Parametro
     * const parametro = await prisma.parametro.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends ParametroFindUniqueArgs>(args: SelectSubset<T, ParametroFindUniqueArgs<ExtArgs>>): Prisma__ParametroClient<$Result.GetResult<Prisma.$ParametroPayload<ExtArgs>, T, "findUnique"> | null, null, ExtArgs>

    /**
     * Find one Parametro that matches the filter or throw an error with `error.code='P2025'` 
     * if no matches were found.
     * @param {ParametroFindUniqueOrThrowArgs} args - Arguments to find a Parametro
     * @example
     * // Get one Parametro
     * const parametro = await prisma.parametro.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends ParametroFindUniqueOrThrowArgs>(args: SelectSubset<T, ParametroFindUniqueOrThrowArgs<ExtArgs>>): Prisma__ParametroClient<$Result.GetResult<Prisma.$ParametroPayload<ExtArgs>, T, "findUniqueOrThrow">, never, ExtArgs>

    /**
     * Find the first Parametro that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ParametroFindFirstArgs} args - Arguments to find a Parametro
     * @example
     * // Get one Parametro
     * const parametro = await prisma.parametro.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends ParametroFindFirstArgs>(args?: SelectSubset<T, ParametroFindFirstArgs<ExtArgs>>): Prisma__ParametroClient<$Result.GetResult<Prisma.$ParametroPayload<ExtArgs>, T, "findFirst"> | null, null, ExtArgs>

    /**
     * Find the first Parametro that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ParametroFindFirstOrThrowArgs} args - Arguments to find a Parametro
     * @example
     * // Get one Parametro
     * const parametro = await prisma.parametro.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends ParametroFindFirstOrThrowArgs>(args?: SelectSubset<T, ParametroFindFirstOrThrowArgs<ExtArgs>>): Prisma__ParametroClient<$Result.GetResult<Prisma.$ParametroPayload<ExtArgs>, T, "findFirstOrThrow">, never, ExtArgs>

    /**
     * Find zero or more Parametros that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ParametroFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Parametros
     * const parametros = await prisma.parametro.findMany()
     * 
     * // Get first 10 Parametros
     * const parametros = await prisma.parametro.findMany({ take: 10 })
     * 
     * // Only select the `id_parametro`
     * const parametroWithId_parametroOnly = await prisma.parametro.findMany({ select: { id_parametro: true } })
     * 
     */
    findMany<T extends ParametroFindManyArgs>(args?: SelectSubset<T, ParametroFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$ParametroPayload<ExtArgs>, T, "findMany">>

    /**
     * Create a Parametro.
     * @param {ParametroCreateArgs} args - Arguments to create a Parametro.
     * @example
     * // Create one Parametro
     * const Parametro = await prisma.parametro.create({
     *   data: {
     *     // ... data to create a Parametro
     *   }
     * })
     * 
     */
    create<T extends ParametroCreateArgs>(args: SelectSubset<T, ParametroCreateArgs<ExtArgs>>): Prisma__ParametroClient<$Result.GetResult<Prisma.$ParametroPayload<ExtArgs>, T, "create">, never, ExtArgs>

    /**
     * Create many Parametros.
     * @param {ParametroCreateManyArgs} args - Arguments to create many Parametros.
     * @example
     * // Create many Parametros
     * const parametro = await prisma.parametro.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends ParametroCreateManyArgs>(args?: SelectSubset<T, ParametroCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Delete a Parametro.
     * @param {ParametroDeleteArgs} args - Arguments to delete one Parametro.
     * @example
     * // Delete one Parametro
     * const Parametro = await prisma.parametro.delete({
     *   where: {
     *     // ... filter to delete one Parametro
     *   }
     * })
     * 
     */
    delete<T extends ParametroDeleteArgs>(args: SelectSubset<T, ParametroDeleteArgs<ExtArgs>>): Prisma__ParametroClient<$Result.GetResult<Prisma.$ParametroPayload<ExtArgs>, T, "delete">, never, ExtArgs>

    /**
     * Update one Parametro.
     * @param {ParametroUpdateArgs} args - Arguments to update one Parametro.
     * @example
     * // Update one Parametro
     * const parametro = await prisma.parametro.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends ParametroUpdateArgs>(args: SelectSubset<T, ParametroUpdateArgs<ExtArgs>>): Prisma__ParametroClient<$Result.GetResult<Prisma.$ParametroPayload<ExtArgs>, T, "update">, never, ExtArgs>

    /**
     * Delete zero or more Parametros.
     * @param {ParametroDeleteManyArgs} args - Arguments to filter Parametros to delete.
     * @example
     * // Delete a few Parametros
     * const { count } = await prisma.parametro.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends ParametroDeleteManyArgs>(args?: SelectSubset<T, ParametroDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Parametros.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ParametroUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Parametros
     * const parametro = await prisma.parametro.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends ParametroUpdateManyArgs>(args: SelectSubset<T, ParametroUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one Parametro.
     * @param {ParametroUpsertArgs} args - Arguments to update or create a Parametro.
     * @example
     * // Update or create a Parametro
     * const parametro = await prisma.parametro.upsert({
     *   create: {
     *     // ... data to create a Parametro
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Parametro we want to update
     *   }
     * })
     */
    upsert<T extends ParametroUpsertArgs>(args: SelectSubset<T, ParametroUpsertArgs<ExtArgs>>): Prisma__ParametroClient<$Result.GetResult<Prisma.$ParametroPayload<ExtArgs>, T, "upsert">, never, ExtArgs>


    /**
     * Count the number of Parametros.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ParametroCountArgs} args - Arguments to filter Parametros to count.
     * @example
     * // Count the number of Parametros
     * const count = await prisma.parametro.count({
     *   where: {
     *     // ... the filter for the Parametros we want to count
     *   }
     * })
    **/
    count<T extends ParametroCountArgs>(
      args?: Subset<T, ParametroCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], ParametroCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Parametro.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ParametroAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends ParametroAggregateArgs>(args: Subset<T, ParametroAggregateArgs>): Prisma.PrismaPromise<GetParametroAggregateType<T>>

    /**
     * Group by Parametro.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ParametroGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends ParametroGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: ParametroGroupByArgs['orderBy'] }
        : { orderBy?: ParametroGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, ParametroGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetParametroGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the Parametro model
   */
  readonly fields: ParametroFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for Parametro.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__ParametroClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    especieParametros<T extends Parametro$especieParametrosArgs<ExtArgs> = {}>(args?: Subset<T, Parametro$especieParametrosArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$EspecieParametroPayload<ExtArgs>, T, "findMany"> | Null>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the Parametro model
   */ 
  interface ParametroFieldRefs {
    readonly id_parametro: FieldRef<"Parametro", 'Int'>
    readonly nombre: FieldRef<"Parametro", 'String'>
    readonly unidad: FieldRef<"Parametro", 'String'>
    readonly descripcion: FieldRef<"Parametro", 'String'>
    readonly rango_min: FieldRef<"Parametro", 'Decimal'>
    readonly rango_max: FieldRef<"Parametro", 'Decimal'>
  }
    

  // Custom InputTypes
  /**
   * Parametro findUnique
   */
  export type ParametroFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Parametro
     */
    select?: ParametroSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ParametroInclude<ExtArgs> | null
    /**
     * Filter, which Parametro to fetch.
     */
    where: ParametroWhereUniqueInput
  }

  /**
   * Parametro findUniqueOrThrow
   */
  export type ParametroFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Parametro
     */
    select?: ParametroSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ParametroInclude<ExtArgs> | null
    /**
     * Filter, which Parametro to fetch.
     */
    where: ParametroWhereUniqueInput
  }

  /**
   * Parametro findFirst
   */
  export type ParametroFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Parametro
     */
    select?: ParametroSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ParametroInclude<ExtArgs> | null
    /**
     * Filter, which Parametro to fetch.
     */
    where?: ParametroWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Parametros to fetch.
     */
    orderBy?: ParametroOrderByWithRelationInput | ParametroOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Parametros.
     */
    cursor?: ParametroWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Parametros from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Parametros.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Parametros.
     */
    distinct?: ParametroScalarFieldEnum | ParametroScalarFieldEnum[]
  }

  /**
   * Parametro findFirstOrThrow
   */
  export type ParametroFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Parametro
     */
    select?: ParametroSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ParametroInclude<ExtArgs> | null
    /**
     * Filter, which Parametro to fetch.
     */
    where?: ParametroWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Parametros to fetch.
     */
    orderBy?: ParametroOrderByWithRelationInput | ParametroOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Parametros.
     */
    cursor?: ParametroWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Parametros from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Parametros.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Parametros.
     */
    distinct?: ParametroScalarFieldEnum | ParametroScalarFieldEnum[]
  }

  /**
   * Parametro findMany
   */
  export type ParametroFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Parametro
     */
    select?: ParametroSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ParametroInclude<ExtArgs> | null
    /**
     * Filter, which Parametros to fetch.
     */
    where?: ParametroWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Parametros to fetch.
     */
    orderBy?: ParametroOrderByWithRelationInput | ParametroOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing Parametros.
     */
    cursor?: ParametroWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Parametros from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Parametros.
     */
    skip?: number
    distinct?: ParametroScalarFieldEnum | ParametroScalarFieldEnum[]
  }

  /**
   * Parametro create
   */
  export type ParametroCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Parametro
     */
    select?: ParametroSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ParametroInclude<ExtArgs> | null
    /**
     * The data needed to create a Parametro.
     */
    data: XOR<ParametroCreateInput, ParametroUncheckedCreateInput>
  }

  /**
   * Parametro createMany
   */
  export type ParametroCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many Parametros.
     */
    data: ParametroCreateManyInput | ParametroCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * Parametro update
   */
  export type ParametroUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Parametro
     */
    select?: ParametroSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ParametroInclude<ExtArgs> | null
    /**
     * The data needed to update a Parametro.
     */
    data: XOR<ParametroUpdateInput, ParametroUncheckedUpdateInput>
    /**
     * Choose, which Parametro to update.
     */
    where: ParametroWhereUniqueInput
  }

  /**
   * Parametro updateMany
   */
  export type ParametroUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update Parametros.
     */
    data: XOR<ParametroUpdateManyMutationInput, ParametroUncheckedUpdateManyInput>
    /**
     * Filter which Parametros to update
     */
    where?: ParametroWhereInput
  }

  /**
   * Parametro upsert
   */
  export type ParametroUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Parametro
     */
    select?: ParametroSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ParametroInclude<ExtArgs> | null
    /**
     * The filter to search for the Parametro to update in case it exists.
     */
    where: ParametroWhereUniqueInput
    /**
     * In case the Parametro found by the `where` argument doesn't exist, create a new Parametro with this data.
     */
    create: XOR<ParametroCreateInput, ParametroUncheckedCreateInput>
    /**
     * In case the Parametro was found with the provided `where` argument, update it with this data.
     */
    update: XOR<ParametroUpdateInput, ParametroUncheckedUpdateInput>
  }

  /**
   * Parametro delete
   */
  export type ParametroDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Parametro
     */
    select?: ParametroSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ParametroInclude<ExtArgs> | null
    /**
     * Filter which Parametro to delete.
     */
    where: ParametroWhereUniqueInput
  }

  /**
   * Parametro deleteMany
   */
  export type ParametroDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Parametros to delete
     */
    where?: ParametroWhereInput
  }

  /**
   * Parametro.especieParametros
   */
  export type Parametro$especieParametrosArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the EspecieParametro
     */
    select?: EspecieParametroSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: EspecieParametroInclude<ExtArgs> | null
    where?: EspecieParametroWhereInput
    orderBy?: EspecieParametroOrderByWithRelationInput | EspecieParametroOrderByWithRelationInput[]
    cursor?: EspecieParametroWhereUniqueInput
    take?: number
    skip?: number
    distinct?: EspecieParametroScalarFieldEnum | EspecieParametroScalarFieldEnum[]
  }

  /**
   * Parametro without action
   */
  export type ParametroDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Parametro
     */
    select?: ParametroSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ParametroInclude<ExtArgs> | null
  }


  /**
   * Model CatalogoEspecie
   */

  export type AggregateCatalogoEspecie = {
    _count: CatalogoEspecieCountAggregateOutputType | null
    _avg: CatalogoEspecieAvgAggregateOutputType | null
    _sum: CatalogoEspecieSumAggregateOutputType | null
    _min: CatalogoEspecieMinAggregateOutputType | null
    _max: CatalogoEspecieMaxAggregateOutputType | null
  }

  export type CatalogoEspecieAvgAggregateOutputType = {
    id_especie: number | null
  }

  export type CatalogoEspecieSumAggregateOutputType = {
    id_especie: number | null
  }

  export type CatalogoEspecieMinAggregateOutputType = {
    id_especie: number | null
    nombre_cientifico: string | null
    nombre_comun: string | null
    tipo: string | null
    descripcion: string | null
  }

  export type CatalogoEspecieMaxAggregateOutputType = {
    id_especie: number | null
    nombre_cientifico: string | null
    nombre_comun: string | null
    tipo: string | null
    descripcion: string | null
  }

  export type CatalogoEspecieCountAggregateOutputType = {
    id_especie: number
    nombre_cientifico: number
    nombre_comun: number
    tipo: number
    descripcion: number
    _all: number
  }


  export type CatalogoEspecieAvgAggregateInputType = {
    id_especie?: true
  }

  export type CatalogoEspecieSumAggregateInputType = {
    id_especie?: true
  }

  export type CatalogoEspecieMinAggregateInputType = {
    id_especie?: true
    nombre_cientifico?: true
    nombre_comun?: true
    tipo?: true
    descripcion?: true
  }

  export type CatalogoEspecieMaxAggregateInputType = {
    id_especie?: true
    nombre_cientifico?: true
    nombre_comun?: true
    tipo?: true
    descripcion?: true
  }

  export type CatalogoEspecieCountAggregateInputType = {
    id_especie?: true
    nombre_cientifico?: true
    nombre_comun?: true
    tipo?: true
    descripcion?: true
    _all?: true
  }

  export type CatalogoEspecieAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which CatalogoEspecie to aggregate.
     */
    where?: CatalogoEspecieWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of CatalogoEspecies to fetch.
     */
    orderBy?: CatalogoEspecieOrderByWithRelationInput | CatalogoEspecieOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: CatalogoEspecieWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` CatalogoEspecies from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` CatalogoEspecies.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned CatalogoEspecies
    **/
    _count?: true | CatalogoEspecieCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: CatalogoEspecieAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: CatalogoEspecieSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: CatalogoEspecieMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: CatalogoEspecieMaxAggregateInputType
  }

  export type GetCatalogoEspecieAggregateType<T extends CatalogoEspecieAggregateArgs> = {
        [P in keyof T & keyof AggregateCatalogoEspecie]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateCatalogoEspecie[P]>
      : GetScalarType<T[P], AggregateCatalogoEspecie[P]>
  }




  export type CatalogoEspecieGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: CatalogoEspecieWhereInput
    orderBy?: CatalogoEspecieOrderByWithAggregationInput | CatalogoEspecieOrderByWithAggregationInput[]
    by: CatalogoEspecieScalarFieldEnum[] | CatalogoEspecieScalarFieldEnum
    having?: CatalogoEspecieScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: CatalogoEspecieCountAggregateInputType | true
    _avg?: CatalogoEspecieAvgAggregateInputType
    _sum?: CatalogoEspecieSumAggregateInputType
    _min?: CatalogoEspecieMinAggregateInputType
    _max?: CatalogoEspecieMaxAggregateInputType
  }

  export type CatalogoEspecieGroupByOutputType = {
    id_especie: number
    nombre_cientifico: string
    nombre_comun: string | null
    tipo: string | null
    descripcion: string | null
    _count: CatalogoEspecieCountAggregateOutputType | null
    _avg: CatalogoEspecieAvgAggregateOutputType | null
    _sum: CatalogoEspecieSumAggregateOutputType | null
    _min: CatalogoEspecieMinAggregateOutputType | null
    _max: CatalogoEspecieMaxAggregateOutputType | null
  }

  type GetCatalogoEspecieGroupByPayload<T extends CatalogoEspecieGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<CatalogoEspecieGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof CatalogoEspecieGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], CatalogoEspecieGroupByOutputType[P]>
            : GetScalarType<T[P], CatalogoEspecieGroupByOutputType[P]>
        }
      >
    >


  export type CatalogoEspecieSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id_especie?: boolean
    nombre_cientifico?: boolean
    nombre_comun?: boolean
    tipo?: boolean
    descripcion?: boolean
    especiesInstaladas?: boolean | CatalogoEspecie$especiesInstaladasArgs<ExtArgs>
    _count?: boolean | CatalogoEspecieCountOutputTypeDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["catalogoEspecie"]>


  export type CatalogoEspecieSelectScalar = {
    id_especie?: boolean
    nombre_cientifico?: boolean
    nombre_comun?: boolean
    tipo?: boolean
    descripcion?: boolean
  }

  export type CatalogoEspecieInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    especiesInstaladas?: boolean | CatalogoEspecie$especiesInstaladasArgs<ExtArgs>
    _count?: boolean | CatalogoEspecieCountOutputTypeDefaultArgs<ExtArgs>
  }

  export type $CatalogoEspeciePayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "CatalogoEspecie"
    objects: {
      especiesInstaladas: Prisma.$EspecieInstaladaPayload<ExtArgs>[]
    }
    scalars: $Extensions.GetPayloadResult<{
      id_especie: number
      nombre_cientifico: string
      nombre_comun: string | null
      tipo: string | null
      descripcion: string | null
    }, ExtArgs["result"]["catalogoEspecie"]>
    composites: {}
  }

  type CatalogoEspecieGetPayload<S extends boolean | null | undefined | CatalogoEspecieDefaultArgs> = $Result.GetResult<Prisma.$CatalogoEspeciePayload, S>

  type CatalogoEspecieCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = 
    Omit<CatalogoEspecieFindManyArgs, 'select' | 'include' | 'distinct'> & {
      select?: CatalogoEspecieCountAggregateInputType | true
    }

  export interface CatalogoEspecieDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['CatalogoEspecie'], meta: { name: 'CatalogoEspecie' } }
    /**
     * Find zero or one CatalogoEspecie that matches the filter.
     * @param {CatalogoEspecieFindUniqueArgs} args - Arguments to find a CatalogoEspecie
     * @example
     * // Get one CatalogoEspecie
     * const catalogoEspecie = await prisma.catalogoEspecie.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends CatalogoEspecieFindUniqueArgs>(args: SelectSubset<T, CatalogoEspecieFindUniqueArgs<ExtArgs>>): Prisma__CatalogoEspecieClient<$Result.GetResult<Prisma.$CatalogoEspeciePayload<ExtArgs>, T, "findUnique"> | null, null, ExtArgs>

    /**
     * Find one CatalogoEspecie that matches the filter or throw an error with `error.code='P2025'` 
     * if no matches were found.
     * @param {CatalogoEspecieFindUniqueOrThrowArgs} args - Arguments to find a CatalogoEspecie
     * @example
     * // Get one CatalogoEspecie
     * const catalogoEspecie = await prisma.catalogoEspecie.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends CatalogoEspecieFindUniqueOrThrowArgs>(args: SelectSubset<T, CatalogoEspecieFindUniqueOrThrowArgs<ExtArgs>>): Prisma__CatalogoEspecieClient<$Result.GetResult<Prisma.$CatalogoEspeciePayload<ExtArgs>, T, "findUniqueOrThrow">, never, ExtArgs>

    /**
     * Find the first CatalogoEspecie that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {CatalogoEspecieFindFirstArgs} args - Arguments to find a CatalogoEspecie
     * @example
     * // Get one CatalogoEspecie
     * const catalogoEspecie = await prisma.catalogoEspecie.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends CatalogoEspecieFindFirstArgs>(args?: SelectSubset<T, CatalogoEspecieFindFirstArgs<ExtArgs>>): Prisma__CatalogoEspecieClient<$Result.GetResult<Prisma.$CatalogoEspeciePayload<ExtArgs>, T, "findFirst"> | null, null, ExtArgs>

    /**
     * Find the first CatalogoEspecie that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {CatalogoEspecieFindFirstOrThrowArgs} args - Arguments to find a CatalogoEspecie
     * @example
     * // Get one CatalogoEspecie
     * const catalogoEspecie = await prisma.catalogoEspecie.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends CatalogoEspecieFindFirstOrThrowArgs>(args?: SelectSubset<T, CatalogoEspecieFindFirstOrThrowArgs<ExtArgs>>): Prisma__CatalogoEspecieClient<$Result.GetResult<Prisma.$CatalogoEspeciePayload<ExtArgs>, T, "findFirstOrThrow">, never, ExtArgs>

    /**
     * Find zero or more CatalogoEspecies that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {CatalogoEspecieFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all CatalogoEspecies
     * const catalogoEspecies = await prisma.catalogoEspecie.findMany()
     * 
     * // Get first 10 CatalogoEspecies
     * const catalogoEspecies = await prisma.catalogoEspecie.findMany({ take: 10 })
     * 
     * // Only select the `id_especie`
     * const catalogoEspecieWithId_especieOnly = await prisma.catalogoEspecie.findMany({ select: { id_especie: true } })
     * 
     */
    findMany<T extends CatalogoEspecieFindManyArgs>(args?: SelectSubset<T, CatalogoEspecieFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$CatalogoEspeciePayload<ExtArgs>, T, "findMany">>

    /**
     * Create a CatalogoEspecie.
     * @param {CatalogoEspecieCreateArgs} args - Arguments to create a CatalogoEspecie.
     * @example
     * // Create one CatalogoEspecie
     * const CatalogoEspecie = await prisma.catalogoEspecie.create({
     *   data: {
     *     // ... data to create a CatalogoEspecie
     *   }
     * })
     * 
     */
    create<T extends CatalogoEspecieCreateArgs>(args: SelectSubset<T, CatalogoEspecieCreateArgs<ExtArgs>>): Prisma__CatalogoEspecieClient<$Result.GetResult<Prisma.$CatalogoEspeciePayload<ExtArgs>, T, "create">, never, ExtArgs>

    /**
     * Create many CatalogoEspecies.
     * @param {CatalogoEspecieCreateManyArgs} args - Arguments to create many CatalogoEspecies.
     * @example
     * // Create many CatalogoEspecies
     * const catalogoEspecie = await prisma.catalogoEspecie.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends CatalogoEspecieCreateManyArgs>(args?: SelectSubset<T, CatalogoEspecieCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Delete a CatalogoEspecie.
     * @param {CatalogoEspecieDeleteArgs} args - Arguments to delete one CatalogoEspecie.
     * @example
     * // Delete one CatalogoEspecie
     * const CatalogoEspecie = await prisma.catalogoEspecie.delete({
     *   where: {
     *     // ... filter to delete one CatalogoEspecie
     *   }
     * })
     * 
     */
    delete<T extends CatalogoEspecieDeleteArgs>(args: SelectSubset<T, CatalogoEspecieDeleteArgs<ExtArgs>>): Prisma__CatalogoEspecieClient<$Result.GetResult<Prisma.$CatalogoEspeciePayload<ExtArgs>, T, "delete">, never, ExtArgs>

    /**
     * Update one CatalogoEspecie.
     * @param {CatalogoEspecieUpdateArgs} args - Arguments to update one CatalogoEspecie.
     * @example
     * // Update one CatalogoEspecie
     * const catalogoEspecie = await prisma.catalogoEspecie.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends CatalogoEspecieUpdateArgs>(args: SelectSubset<T, CatalogoEspecieUpdateArgs<ExtArgs>>): Prisma__CatalogoEspecieClient<$Result.GetResult<Prisma.$CatalogoEspeciePayload<ExtArgs>, T, "update">, never, ExtArgs>

    /**
     * Delete zero or more CatalogoEspecies.
     * @param {CatalogoEspecieDeleteManyArgs} args - Arguments to filter CatalogoEspecies to delete.
     * @example
     * // Delete a few CatalogoEspecies
     * const { count } = await prisma.catalogoEspecie.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends CatalogoEspecieDeleteManyArgs>(args?: SelectSubset<T, CatalogoEspecieDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more CatalogoEspecies.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {CatalogoEspecieUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many CatalogoEspecies
     * const catalogoEspecie = await prisma.catalogoEspecie.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends CatalogoEspecieUpdateManyArgs>(args: SelectSubset<T, CatalogoEspecieUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one CatalogoEspecie.
     * @param {CatalogoEspecieUpsertArgs} args - Arguments to update or create a CatalogoEspecie.
     * @example
     * // Update or create a CatalogoEspecie
     * const catalogoEspecie = await prisma.catalogoEspecie.upsert({
     *   create: {
     *     // ... data to create a CatalogoEspecie
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the CatalogoEspecie we want to update
     *   }
     * })
     */
    upsert<T extends CatalogoEspecieUpsertArgs>(args: SelectSubset<T, CatalogoEspecieUpsertArgs<ExtArgs>>): Prisma__CatalogoEspecieClient<$Result.GetResult<Prisma.$CatalogoEspeciePayload<ExtArgs>, T, "upsert">, never, ExtArgs>


    /**
     * Count the number of CatalogoEspecies.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {CatalogoEspecieCountArgs} args - Arguments to filter CatalogoEspecies to count.
     * @example
     * // Count the number of CatalogoEspecies
     * const count = await prisma.catalogoEspecie.count({
     *   where: {
     *     // ... the filter for the CatalogoEspecies we want to count
     *   }
     * })
    **/
    count<T extends CatalogoEspecieCountArgs>(
      args?: Subset<T, CatalogoEspecieCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], CatalogoEspecieCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a CatalogoEspecie.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {CatalogoEspecieAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends CatalogoEspecieAggregateArgs>(args: Subset<T, CatalogoEspecieAggregateArgs>): Prisma.PrismaPromise<GetCatalogoEspecieAggregateType<T>>

    /**
     * Group by CatalogoEspecie.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {CatalogoEspecieGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends CatalogoEspecieGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: CatalogoEspecieGroupByArgs['orderBy'] }
        : { orderBy?: CatalogoEspecieGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, CatalogoEspecieGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetCatalogoEspecieGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the CatalogoEspecie model
   */
  readonly fields: CatalogoEspecieFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for CatalogoEspecie.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__CatalogoEspecieClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    especiesInstaladas<T extends CatalogoEspecie$especiesInstaladasArgs<ExtArgs> = {}>(args?: Subset<T, CatalogoEspecie$especiesInstaladasArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$EspecieInstaladaPayload<ExtArgs>, T, "findMany"> | Null>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the CatalogoEspecie model
   */ 
  interface CatalogoEspecieFieldRefs {
    readonly id_especie: FieldRef<"CatalogoEspecie", 'Int'>
    readonly nombre_cientifico: FieldRef<"CatalogoEspecie", 'String'>
    readonly nombre_comun: FieldRef<"CatalogoEspecie", 'String'>
    readonly tipo: FieldRef<"CatalogoEspecie", 'String'>
    readonly descripcion: FieldRef<"CatalogoEspecie", 'String'>
  }
    

  // Custom InputTypes
  /**
   * CatalogoEspecie findUnique
   */
  export type CatalogoEspecieFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the CatalogoEspecie
     */
    select?: CatalogoEspecieSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CatalogoEspecieInclude<ExtArgs> | null
    /**
     * Filter, which CatalogoEspecie to fetch.
     */
    where: CatalogoEspecieWhereUniqueInput
  }

  /**
   * CatalogoEspecie findUniqueOrThrow
   */
  export type CatalogoEspecieFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the CatalogoEspecie
     */
    select?: CatalogoEspecieSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CatalogoEspecieInclude<ExtArgs> | null
    /**
     * Filter, which CatalogoEspecie to fetch.
     */
    where: CatalogoEspecieWhereUniqueInput
  }

  /**
   * CatalogoEspecie findFirst
   */
  export type CatalogoEspecieFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the CatalogoEspecie
     */
    select?: CatalogoEspecieSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CatalogoEspecieInclude<ExtArgs> | null
    /**
     * Filter, which CatalogoEspecie to fetch.
     */
    where?: CatalogoEspecieWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of CatalogoEspecies to fetch.
     */
    orderBy?: CatalogoEspecieOrderByWithRelationInput | CatalogoEspecieOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for CatalogoEspecies.
     */
    cursor?: CatalogoEspecieWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` CatalogoEspecies from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` CatalogoEspecies.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of CatalogoEspecies.
     */
    distinct?: CatalogoEspecieScalarFieldEnum | CatalogoEspecieScalarFieldEnum[]
  }

  /**
   * CatalogoEspecie findFirstOrThrow
   */
  export type CatalogoEspecieFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the CatalogoEspecie
     */
    select?: CatalogoEspecieSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CatalogoEspecieInclude<ExtArgs> | null
    /**
     * Filter, which CatalogoEspecie to fetch.
     */
    where?: CatalogoEspecieWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of CatalogoEspecies to fetch.
     */
    orderBy?: CatalogoEspecieOrderByWithRelationInput | CatalogoEspecieOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for CatalogoEspecies.
     */
    cursor?: CatalogoEspecieWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` CatalogoEspecies from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` CatalogoEspecies.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of CatalogoEspecies.
     */
    distinct?: CatalogoEspecieScalarFieldEnum | CatalogoEspecieScalarFieldEnum[]
  }

  /**
   * CatalogoEspecie findMany
   */
  export type CatalogoEspecieFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the CatalogoEspecie
     */
    select?: CatalogoEspecieSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CatalogoEspecieInclude<ExtArgs> | null
    /**
     * Filter, which CatalogoEspecies to fetch.
     */
    where?: CatalogoEspecieWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of CatalogoEspecies to fetch.
     */
    orderBy?: CatalogoEspecieOrderByWithRelationInput | CatalogoEspecieOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing CatalogoEspecies.
     */
    cursor?: CatalogoEspecieWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` CatalogoEspecies from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` CatalogoEspecies.
     */
    skip?: number
    distinct?: CatalogoEspecieScalarFieldEnum | CatalogoEspecieScalarFieldEnum[]
  }

  /**
   * CatalogoEspecie create
   */
  export type CatalogoEspecieCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the CatalogoEspecie
     */
    select?: CatalogoEspecieSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CatalogoEspecieInclude<ExtArgs> | null
    /**
     * The data needed to create a CatalogoEspecie.
     */
    data: XOR<CatalogoEspecieCreateInput, CatalogoEspecieUncheckedCreateInput>
  }

  /**
   * CatalogoEspecie createMany
   */
  export type CatalogoEspecieCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many CatalogoEspecies.
     */
    data: CatalogoEspecieCreateManyInput | CatalogoEspecieCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * CatalogoEspecie update
   */
  export type CatalogoEspecieUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the CatalogoEspecie
     */
    select?: CatalogoEspecieSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CatalogoEspecieInclude<ExtArgs> | null
    /**
     * The data needed to update a CatalogoEspecie.
     */
    data: XOR<CatalogoEspecieUpdateInput, CatalogoEspecieUncheckedUpdateInput>
    /**
     * Choose, which CatalogoEspecie to update.
     */
    where: CatalogoEspecieWhereUniqueInput
  }

  /**
   * CatalogoEspecie updateMany
   */
  export type CatalogoEspecieUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update CatalogoEspecies.
     */
    data: XOR<CatalogoEspecieUpdateManyMutationInput, CatalogoEspecieUncheckedUpdateManyInput>
    /**
     * Filter which CatalogoEspecies to update
     */
    where?: CatalogoEspecieWhereInput
  }

  /**
   * CatalogoEspecie upsert
   */
  export type CatalogoEspecieUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the CatalogoEspecie
     */
    select?: CatalogoEspecieSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CatalogoEspecieInclude<ExtArgs> | null
    /**
     * The filter to search for the CatalogoEspecie to update in case it exists.
     */
    where: CatalogoEspecieWhereUniqueInput
    /**
     * In case the CatalogoEspecie found by the `where` argument doesn't exist, create a new CatalogoEspecie with this data.
     */
    create: XOR<CatalogoEspecieCreateInput, CatalogoEspecieUncheckedCreateInput>
    /**
     * In case the CatalogoEspecie was found with the provided `where` argument, update it with this data.
     */
    update: XOR<CatalogoEspecieUpdateInput, CatalogoEspecieUncheckedUpdateInput>
  }

  /**
   * CatalogoEspecie delete
   */
  export type CatalogoEspecieDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the CatalogoEspecie
     */
    select?: CatalogoEspecieSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CatalogoEspecieInclude<ExtArgs> | null
    /**
     * Filter which CatalogoEspecie to delete.
     */
    where: CatalogoEspecieWhereUniqueInput
  }

  /**
   * CatalogoEspecie deleteMany
   */
  export type CatalogoEspecieDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which CatalogoEspecies to delete
     */
    where?: CatalogoEspecieWhereInput
  }

  /**
   * CatalogoEspecie.especiesInstaladas
   */
  export type CatalogoEspecie$especiesInstaladasArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the EspecieInstalada
     */
    select?: EspecieInstaladaSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: EspecieInstaladaInclude<ExtArgs> | null
    where?: EspecieInstaladaWhereInput
    orderBy?: EspecieInstaladaOrderByWithRelationInput | EspecieInstaladaOrderByWithRelationInput[]
    cursor?: EspecieInstaladaWhereUniqueInput
    take?: number
    skip?: number
    distinct?: EspecieInstaladaScalarFieldEnum | EspecieInstaladaScalarFieldEnum[]
  }

  /**
   * CatalogoEspecie without action
   */
  export type CatalogoEspecieDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the CatalogoEspecie
     */
    select?: CatalogoEspecieSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CatalogoEspecieInclude<ExtArgs> | null
  }


  /**
   * Model EspecieInstalada
   */

  export type AggregateEspecieInstalada = {
    _count: EspecieInstaladaCountAggregateOutputType | null
    _avg: EspecieInstaladaAvgAggregateOutputType | null
    _sum: EspecieInstaladaSumAggregateOutputType | null
    _min: EspecieInstaladaMinAggregateOutputType | null
    _max: EspecieInstaladaMaxAggregateOutputType | null
  }

  export type EspecieInstaladaAvgAggregateOutputType = {
    id_especie_instalada: number | null
    id_instalacion: number | null
    id_especie: number | null
    cantidad_inicial: number | null
  }

  export type EspecieInstaladaSumAggregateOutputType = {
    id_especie_instalada: number | null
    id_instalacion: number | null
    id_especie: number | null
    cantidad_inicial: number | null
  }

  export type EspecieInstaladaMinAggregateOutputType = {
    id_especie_instalada: number | null
    id_instalacion: number | null
    id_especie: number | null
    cantidad_inicial: number | null
    fecha_introduccion: Date | null
    estado: string | null
  }

  export type EspecieInstaladaMaxAggregateOutputType = {
    id_especie_instalada: number | null
    id_instalacion: number | null
    id_especie: number | null
    cantidad_inicial: number | null
    fecha_introduccion: Date | null
    estado: string | null
  }

  export type EspecieInstaladaCountAggregateOutputType = {
    id_especie_instalada: number
    id_instalacion: number
    id_especie: number
    cantidad_inicial: number
    fecha_introduccion: number
    estado: number
    _all: number
  }


  export type EspecieInstaladaAvgAggregateInputType = {
    id_especie_instalada?: true
    id_instalacion?: true
    id_especie?: true
    cantidad_inicial?: true
  }

  export type EspecieInstaladaSumAggregateInputType = {
    id_especie_instalada?: true
    id_instalacion?: true
    id_especie?: true
    cantidad_inicial?: true
  }

  export type EspecieInstaladaMinAggregateInputType = {
    id_especie_instalada?: true
    id_instalacion?: true
    id_especie?: true
    cantidad_inicial?: true
    fecha_introduccion?: true
    estado?: true
  }

  export type EspecieInstaladaMaxAggregateInputType = {
    id_especie_instalada?: true
    id_instalacion?: true
    id_especie?: true
    cantidad_inicial?: true
    fecha_introduccion?: true
    estado?: true
  }

  export type EspecieInstaladaCountAggregateInputType = {
    id_especie_instalada?: true
    id_instalacion?: true
    id_especie?: true
    cantidad_inicial?: true
    fecha_introduccion?: true
    estado?: true
    _all?: true
  }

  export type EspecieInstaladaAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which EspecieInstalada to aggregate.
     */
    where?: EspecieInstaladaWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of EspecieInstaladas to fetch.
     */
    orderBy?: EspecieInstaladaOrderByWithRelationInput | EspecieInstaladaOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: EspecieInstaladaWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` EspecieInstaladas from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` EspecieInstaladas.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned EspecieInstaladas
    **/
    _count?: true | EspecieInstaladaCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: EspecieInstaladaAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: EspecieInstaladaSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: EspecieInstaladaMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: EspecieInstaladaMaxAggregateInputType
  }

  export type GetEspecieInstaladaAggregateType<T extends EspecieInstaladaAggregateArgs> = {
        [P in keyof T & keyof AggregateEspecieInstalada]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateEspecieInstalada[P]>
      : GetScalarType<T[P], AggregateEspecieInstalada[P]>
  }




  export type EspecieInstaladaGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: EspecieInstaladaWhereInput
    orderBy?: EspecieInstaladaOrderByWithAggregationInput | EspecieInstaladaOrderByWithAggregationInput[]
    by: EspecieInstaladaScalarFieldEnum[] | EspecieInstaladaScalarFieldEnum
    having?: EspecieInstaladaScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: EspecieInstaladaCountAggregateInputType | true
    _avg?: EspecieInstaladaAvgAggregateInputType
    _sum?: EspecieInstaladaSumAggregateInputType
    _min?: EspecieInstaladaMinAggregateInputType
    _max?: EspecieInstaladaMaxAggregateInputType
  }

  export type EspecieInstaladaGroupByOutputType = {
    id_especie_instalada: number
    id_instalacion: number
    id_especie: number
    cantidad_inicial: number | null
    fecha_introduccion: Date
    estado: string
    _count: EspecieInstaladaCountAggregateOutputType | null
    _avg: EspecieInstaladaAvgAggregateOutputType | null
    _sum: EspecieInstaladaSumAggregateOutputType | null
    _min: EspecieInstaladaMinAggregateOutputType | null
    _max: EspecieInstaladaMaxAggregateOutputType | null
  }

  type GetEspecieInstaladaGroupByPayload<T extends EspecieInstaladaGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<EspecieInstaladaGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof EspecieInstaladaGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], EspecieInstaladaGroupByOutputType[P]>
            : GetScalarType<T[P], EspecieInstaladaGroupByOutputType[P]>
        }
      >
    >


  export type EspecieInstaladaSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id_especie_instalada?: boolean
    id_instalacion?: boolean
    id_especie?: boolean
    cantidad_inicial?: boolean
    fecha_introduccion?: boolean
    estado?: boolean
    catalogoEspecie?: boolean | CatalogoEspecieDefaultArgs<ExtArgs>
    trackings?: boolean | EspecieInstalada$trackingsArgs<ExtArgs>
    _count?: boolean | EspecieInstaladaCountOutputTypeDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["especieInstalada"]>


  export type EspecieInstaladaSelectScalar = {
    id_especie_instalada?: boolean
    id_instalacion?: boolean
    id_especie?: boolean
    cantidad_inicial?: boolean
    fecha_introduccion?: boolean
    estado?: boolean
  }

  export type EspecieInstaladaInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    catalogoEspecie?: boolean | CatalogoEspecieDefaultArgs<ExtArgs>
    trackings?: boolean | EspecieInstalada$trackingsArgs<ExtArgs>
    _count?: boolean | EspecieInstaladaCountOutputTypeDefaultArgs<ExtArgs>
  }

  export type $EspecieInstaladaPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "EspecieInstalada"
    objects: {
      catalogoEspecie: Prisma.$CatalogoEspeciePayload<ExtArgs>
      trackings: Prisma.$EspecieTrackingPayload<ExtArgs>[]
    }
    scalars: $Extensions.GetPayloadResult<{
      id_especie_instalada: number
      id_instalacion: number
      id_especie: number
      cantidad_inicial: number | null
      fecha_introduccion: Date
      estado: string
    }, ExtArgs["result"]["especieInstalada"]>
    composites: {}
  }

  type EspecieInstaladaGetPayload<S extends boolean | null | undefined | EspecieInstaladaDefaultArgs> = $Result.GetResult<Prisma.$EspecieInstaladaPayload, S>

  type EspecieInstaladaCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = 
    Omit<EspecieInstaladaFindManyArgs, 'select' | 'include' | 'distinct'> & {
      select?: EspecieInstaladaCountAggregateInputType | true
    }

  export interface EspecieInstaladaDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['EspecieInstalada'], meta: { name: 'EspecieInstalada' } }
    /**
     * Find zero or one EspecieInstalada that matches the filter.
     * @param {EspecieInstaladaFindUniqueArgs} args - Arguments to find a EspecieInstalada
     * @example
     * // Get one EspecieInstalada
     * const especieInstalada = await prisma.especieInstalada.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends EspecieInstaladaFindUniqueArgs>(args: SelectSubset<T, EspecieInstaladaFindUniqueArgs<ExtArgs>>): Prisma__EspecieInstaladaClient<$Result.GetResult<Prisma.$EspecieInstaladaPayload<ExtArgs>, T, "findUnique"> | null, null, ExtArgs>

    /**
     * Find one EspecieInstalada that matches the filter or throw an error with `error.code='P2025'` 
     * if no matches were found.
     * @param {EspecieInstaladaFindUniqueOrThrowArgs} args - Arguments to find a EspecieInstalada
     * @example
     * // Get one EspecieInstalada
     * const especieInstalada = await prisma.especieInstalada.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends EspecieInstaladaFindUniqueOrThrowArgs>(args: SelectSubset<T, EspecieInstaladaFindUniqueOrThrowArgs<ExtArgs>>): Prisma__EspecieInstaladaClient<$Result.GetResult<Prisma.$EspecieInstaladaPayload<ExtArgs>, T, "findUniqueOrThrow">, never, ExtArgs>

    /**
     * Find the first EspecieInstalada that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {EspecieInstaladaFindFirstArgs} args - Arguments to find a EspecieInstalada
     * @example
     * // Get one EspecieInstalada
     * const especieInstalada = await prisma.especieInstalada.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends EspecieInstaladaFindFirstArgs>(args?: SelectSubset<T, EspecieInstaladaFindFirstArgs<ExtArgs>>): Prisma__EspecieInstaladaClient<$Result.GetResult<Prisma.$EspecieInstaladaPayload<ExtArgs>, T, "findFirst"> | null, null, ExtArgs>

    /**
     * Find the first EspecieInstalada that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {EspecieInstaladaFindFirstOrThrowArgs} args - Arguments to find a EspecieInstalada
     * @example
     * // Get one EspecieInstalada
     * const especieInstalada = await prisma.especieInstalada.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends EspecieInstaladaFindFirstOrThrowArgs>(args?: SelectSubset<T, EspecieInstaladaFindFirstOrThrowArgs<ExtArgs>>): Prisma__EspecieInstaladaClient<$Result.GetResult<Prisma.$EspecieInstaladaPayload<ExtArgs>, T, "findFirstOrThrow">, never, ExtArgs>

    /**
     * Find zero or more EspecieInstaladas that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {EspecieInstaladaFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all EspecieInstaladas
     * const especieInstaladas = await prisma.especieInstalada.findMany()
     * 
     * // Get first 10 EspecieInstaladas
     * const especieInstaladas = await prisma.especieInstalada.findMany({ take: 10 })
     * 
     * // Only select the `id_especie_instalada`
     * const especieInstaladaWithId_especie_instaladaOnly = await prisma.especieInstalada.findMany({ select: { id_especie_instalada: true } })
     * 
     */
    findMany<T extends EspecieInstaladaFindManyArgs>(args?: SelectSubset<T, EspecieInstaladaFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$EspecieInstaladaPayload<ExtArgs>, T, "findMany">>

    /**
     * Create a EspecieInstalada.
     * @param {EspecieInstaladaCreateArgs} args - Arguments to create a EspecieInstalada.
     * @example
     * // Create one EspecieInstalada
     * const EspecieInstalada = await prisma.especieInstalada.create({
     *   data: {
     *     // ... data to create a EspecieInstalada
     *   }
     * })
     * 
     */
    create<T extends EspecieInstaladaCreateArgs>(args: SelectSubset<T, EspecieInstaladaCreateArgs<ExtArgs>>): Prisma__EspecieInstaladaClient<$Result.GetResult<Prisma.$EspecieInstaladaPayload<ExtArgs>, T, "create">, never, ExtArgs>

    /**
     * Create many EspecieInstaladas.
     * @param {EspecieInstaladaCreateManyArgs} args - Arguments to create many EspecieInstaladas.
     * @example
     * // Create many EspecieInstaladas
     * const especieInstalada = await prisma.especieInstalada.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends EspecieInstaladaCreateManyArgs>(args?: SelectSubset<T, EspecieInstaladaCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Delete a EspecieInstalada.
     * @param {EspecieInstaladaDeleteArgs} args - Arguments to delete one EspecieInstalada.
     * @example
     * // Delete one EspecieInstalada
     * const EspecieInstalada = await prisma.especieInstalada.delete({
     *   where: {
     *     // ... filter to delete one EspecieInstalada
     *   }
     * })
     * 
     */
    delete<T extends EspecieInstaladaDeleteArgs>(args: SelectSubset<T, EspecieInstaladaDeleteArgs<ExtArgs>>): Prisma__EspecieInstaladaClient<$Result.GetResult<Prisma.$EspecieInstaladaPayload<ExtArgs>, T, "delete">, never, ExtArgs>

    /**
     * Update one EspecieInstalada.
     * @param {EspecieInstaladaUpdateArgs} args - Arguments to update one EspecieInstalada.
     * @example
     * // Update one EspecieInstalada
     * const especieInstalada = await prisma.especieInstalada.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends EspecieInstaladaUpdateArgs>(args: SelectSubset<T, EspecieInstaladaUpdateArgs<ExtArgs>>): Prisma__EspecieInstaladaClient<$Result.GetResult<Prisma.$EspecieInstaladaPayload<ExtArgs>, T, "update">, never, ExtArgs>

    /**
     * Delete zero or more EspecieInstaladas.
     * @param {EspecieInstaladaDeleteManyArgs} args - Arguments to filter EspecieInstaladas to delete.
     * @example
     * // Delete a few EspecieInstaladas
     * const { count } = await prisma.especieInstalada.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends EspecieInstaladaDeleteManyArgs>(args?: SelectSubset<T, EspecieInstaladaDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more EspecieInstaladas.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {EspecieInstaladaUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many EspecieInstaladas
     * const especieInstalada = await prisma.especieInstalada.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends EspecieInstaladaUpdateManyArgs>(args: SelectSubset<T, EspecieInstaladaUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one EspecieInstalada.
     * @param {EspecieInstaladaUpsertArgs} args - Arguments to update or create a EspecieInstalada.
     * @example
     * // Update or create a EspecieInstalada
     * const especieInstalada = await prisma.especieInstalada.upsert({
     *   create: {
     *     // ... data to create a EspecieInstalada
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the EspecieInstalada we want to update
     *   }
     * })
     */
    upsert<T extends EspecieInstaladaUpsertArgs>(args: SelectSubset<T, EspecieInstaladaUpsertArgs<ExtArgs>>): Prisma__EspecieInstaladaClient<$Result.GetResult<Prisma.$EspecieInstaladaPayload<ExtArgs>, T, "upsert">, never, ExtArgs>


    /**
     * Count the number of EspecieInstaladas.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {EspecieInstaladaCountArgs} args - Arguments to filter EspecieInstaladas to count.
     * @example
     * // Count the number of EspecieInstaladas
     * const count = await prisma.especieInstalada.count({
     *   where: {
     *     // ... the filter for the EspecieInstaladas we want to count
     *   }
     * })
    **/
    count<T extends EspecieInstaladaCountArgs>(
      args?: Subset<T, EspecieInstaladaCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], EspecieInstaladaCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a EspecieInstalada.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {EspecieInstaladaAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends EspecieInstaladaAggregateArgs>(args: Subset<T, EspecieInstaladaAggregateArgs>): Prisma.PrismaPromise<GetEspecieInstaladaAggregateType<T>>

    /**
     * Group by EspecieInstalada.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {EspecieInstaladaGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends EspecieInstaladaGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: EspecieInstaladaGroupByArgs['orderBy'] }
        : { orderBy?: EspecieInstaladaGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, EspecieInstaladaGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetEspecieInstaladaGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the EspecieInstalada model
   */
  readonly fields: EspecieInstaladaFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for EspecieInstalada.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__EspecieInstaladaClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    catalogoEspecie<T extends CatalogoEspecieDefaultArgs<ExtArgs> = {}>(args?: Subset<T, CatalogoEspecieDefaultArgs<ExtArgs>>): Prisma__CatalogoEspecieClient<$Result.GetResult<Prisma.$CatalogoEspeciePayload<ExtArgs>, T, "findUniqueOrThrow"> | Null, Null, ExtArgs>
    trackings<T extends EspecieInstalada$trackingsArgs<ExtArgs> = {}>(args?: Subset<T, EspecieInstalada$trackingsArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$EspecieTrackingPayload<ExtArgs>, T, "findMany"> | Null>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the EspecieInstalada model
   */ 
  interface EspecieInstaladaFieldRefs {
    readonly id_especie_instalada: FieldRef<"EspecieInstalada", 'Int'>
    readonly id_instalacion: FieldRef<"EspecieInstalada", 'Int'>
    readonly id_especie: FieldRef<"EspecieInstalada", 'Int'>
    readonly cantidad_inicial: FieldRef<"EspecieInstalada", 'Int'>
    readonly fecha_introduccion: FieldRef<"EspecieInstalada", 'DateTime'>
    readonly estado: FieldRef<"EspecieInstalada", 'String'>
  }
    

  // Custom InputTypes
  /**
   * EspecieInstalada findUnique
   */
  export type EspecieInstaladaFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the EspecieInstalada
     */
    select?: EspecieInstaladaSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: EspecieInstaladaInclude<ExtArgs> | null
    /**
     * Filter, which EspecieInstalada to fetch.
     */
    where: EspecieInstaladaWhereUniqueInput
  }

  /**
   * EspecieInstalada findUniqueOrThrow
   */
  export type EspecieInstaladaFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the EspecieInstalada
     */
    select?: EspecieInstaladaSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: EspecieInstaladaInclude<ExtArgs> | null
    /**
     * Filter, which EspecieInstalada to fetch.
     */
    where: EspecieInstaladaWhereUniqueInput
  }

  /**
   * EspecieInstalada findFirst
   */
  export type EspecieInstaladaFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the EspecieInstalada
     */
    select?: EspecieInstaladaSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: EspecieInstaladaInclude<ExtArgs> | null
    /**
     * Filter, which EspecieInstalada to fetch.
     */
    where?: EspecieInstaladaWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of EspecieInstaladas to fetch.
     */
    orderBy?: EspecieInstaladaOrderByWithRelationInput | EspecieInstaladaOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for EspecieInstaladas.
     */
    cursor?: EspecieInstaladaWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` EspecieInstaladas from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` EspecieInstaladas.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of EspecieInstaladas.
     */
    distinct?: EspecieInstaladaScalarFieldEnum | EspecieInstaladaScalarFieldEnum[]
  }

  /**
   * EspecieInstalada findFirstOrThrow
   */
  export type EspecieInstaladaFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the EspecieInstalada
     */
    select?: EspecieInstaladaSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: EspecieInstaladaInclude<ExtArgs> | null
    /**
     * Filter, which EspecieInstalada to fetch.
     */
    where?: EspecieInstaladaWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of EspecieInstaladas to fetch.
     */
    orderBy?: EspecieInstaladaOrderByWithRelationInput | EspecieInstaladaOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for EspecieInstaladas.
     */
    cursor?: EspecieInstaladaWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` EspecieInstaladas from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` EspecieInstaladas.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of EspecieInstaladas.
     */
    distinct?: EspecieInstaladaScalarFieldEnum | EspecieInstaladaScalarFieldEnum[]
  }

  /**
   * EspecieInstalada findMany
   */
  export type EspecieInstaladaFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the EspecieInstalada
     */
    select?: EspecieInstaladaSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: EspecieInstaladaInclude<ExtArgs> | null
    /**
     * Filter, which EspecieInstaladas to fetch.
     */
    where?: EspecieInstaladaWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of EspecieInstaladas to fetch.
     */
    orderBy?: EspecieInstaladaOrderByWithRelationInput | EspecieInstaladaOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing EspecieInstaladas.
     */
    cursor?: EspecieInstaladaWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` EspecieInstaladas from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` EspecieInstaladas.
     */
    skip?: number
    distinct?: EspecieInstaladaScalarFieldEnum | EspecieInstaladaScalarFieldEnum[]
  }

  /**
   * EspecieInstalada create
   */
  export type EspecieInstaladaCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the EspecieInstalada
     */
    select?: EspecieInstaladaSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: EspecieInstaladaInclude<ExtArgs> | null
    /**
     * The data needed to create a EspecieInstalada.
     */
    data: XOR<EspecieInstaladaCreateInput, EspecieInstaladaUncheckedCreateInput>
  }

  /**
   * EspecieInstalada createMany
   */
  export type EspecieInstaladaCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many EspecieInstaladas.
     */
    data: EspecieInstaladaCreateManyInput | EspecieInstaladaCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * EspecieInstalada update
   */
  export type EspecieInstaladaUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the EspecieInstalada
     */
    select?: EspecieInstaladaSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: EspecieInstaladaInclude<ExtArgs> | null
    /**
     * The data needed to update a EspecieInstalada.
     */
    data: XOR<EspecieInstaladaUpdateInput, EspecieInstaladaUncheckedUpdateInput>
    /**
     * Choose, which EspecieInstalada to update.
     */
    where: EspecieInstaladaWhereUniqueInput
  }

  /**
   * EspecieInstalada updateMany
   */
  export type EspecieInstaladaUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update EspecieInstaladas.
     */
    data: XOR<EspecieInstaladaUpdateManyMutationInput, EspecieInstaladaUncheckedUpdateManyInput>
    /**
     * Filter which EspecieInstaladas to update
     */
    where?: EspecieInstaladaWhereInput
  }

  /**
   * EspecieInstalada upsert
   */
  export type EspecieInstaladaUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the EspecieInstalada
     */
    select?: EspecieInstaladaSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: EspecieInstaladaInclude<ExtArgs> | null
    /**
     * The filter to search for the EspecieInstalada to update in case it exists.
     */
    where: EspecieInstaladaWhereUniqueInput
    /**
     * In case the EspecieInstalada found by the `where` argument doesn't exist, create a new EspecieInstalada with this data.
     */
    create: XOR<EspecieInstaladaCreateInput, EspecieInstaladaUncheckedCreateInput>
    /**
     * In case the EspecieInstalada was found with the provided `where` argument, update it with this data.
     */
    update: XOR<EspecieInstaladaUpdateInput, EspecieInstaladaUncheckedUpdateInput>
  }

  /**
   * EspecieInstalada delete
   */
  export type EspecieInstaladaDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the EspecieInstalada
     */
    select?: EspecieInstaladaSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: EspecieInstaladaInclude<ExtArgs> | null
    /**
     * Filter which EspecieInstalada to delete.
     */
    where: EspecieInstaladaWhereUniqueInput
  }

  /**
   * EspecieInstalada deleteMany
   */
  export type EspecieInstaladaDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which EspecieInstaladas to delete
     */
    where?: EspecieInstaladaWhereInput
  }

  /**
   * EspecieInstalada.trackings
   */
  export type EspecieInstalada$trackingsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the EspecieTracking
     */
    select?: EspecieTrackingSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: EspecieTrackingInclude<ExtArgs> | null
    where?: EspecieTrackingWhereInput
    orderBy?: EspecieTrackingOrderByWithRelationInput | EspecieTrackingOrderByWithRelationInput[]
    cursor?: EspecieTrackingWhereUniqueInput
    take?: number
    skip?: number
    distinct?: EspecieTrackingScalarFieldEnum | EspecieTrackingScalarFieldEnum[]
  }

  /**
   * EspecieInstalada without action
   */
  export type EspecieInstaladaDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the EspecieInstalada
     */
    select?: EspecieInstaladaSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: EspecieInstaladaInclude<ExtArgs> | null
  }


  /**
   * Model EspecieTracking
   */

  export type AggregateEspecieTracking = {
    _count: EspecieTrackingCountAggregateOutputType | null
    _avg: EspecieTrackingAvgAggregateOutputType | null
    _sum: EspecieTrackingSumAggregateOutputType | null
    _min: EspecieTrackingMinAggregateOutputType | null
    _max: EspecieTrackingMaxAggregateOutputType | null
  }

  export type EspecieTrackingAvgAggregateOutputType = {
    id_tracking: number | null
    id_especie_instalada: number | null
    cantidad_actual: number | null
  }

  export type EspecieTrackingSumAggregateOutputType = {
    id_tracking: number | null
    id_especie_instalada: number | null
    cantidad_actual: number | null
  }

  export type EspecieTrackingMinAggregateOutputType = {
    id_tracking: number | null
    id_especie_instalada: number | null
    fecha_registro: Date | null
    cantidad_actual: number | null
    observaciones: string | null
  }

  export type EspecieTrackingMaxAggregateOutputType = {
    id_tracking: number | null
    id_especie_instalada: number | null
    fecha_registro: Date | null
    cantidad_actual: number | null
    observaciones: string | null
  }

  export type EspecieTrackingCountAggregateOutputType = {
    id_tracking: number
    id_especie_instalada: number
    fecha_registro: number
    cantidad_actual: number
    observaciones: number
    _all: number
  }


  export type EspecieTrackingAvgAggregateInputType = {
    id_tracking?: true
    id_especie_instalada?: true
    cantidad_actual?: true
  }

  export type EspecieTrackingSumAggregateInputType = {
    id_tracking?: true
    id_especie_instalada?: true
    cantidad_actual?: true
  }

  export type EspecieTrackingMinAggregateInputType = {
    id_tracking?: true
    id_especie_instalada?: true
    fecha_registro?: true
    cantidad_actual?: true
    observaciones?: true
  }

  export type EspecieTrackingMaxAggregateInputType = {
    id_tracking?: true
    id_especie_instalada?: true
    fecha_registro?: true
    cantidad_actual?: true
    observaciones?: true
  }

  export type EspecieTrackingCountAggregateInputType = {
    id_tracking?: true
    id_especie_instalada?: true
    fecha_registro?: true
    cantidad_actual?: true
    observaciones?: true
    _all?: true
  }

  export type EspecieTrackingAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which EspecieTracking to aggregate.
     */
    where?: EspecieTrackingWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of EspecieTrackings to fetch.
     */
    orderBy?: EspecieTrackingOrderByWithRelationInput | EspecieTrackingOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: EspecieTrackingWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` EspecieTrackings from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` EspecieTrackings.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned EspecieTrackings
    **/
    _count?: true | EspecieTrackingCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: EspecieTrackingAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: EspecieTrackingSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: EspecieTrackingMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: EspecieTrackingMaxAggregateInputType
  }

  export type GetEspecieTrackingAggregateType<T extends EspecieTrackingAggregateArgs> = {
        [P in keyof T & keyof AggregateEspecieTracking]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateEspecieTracking[P]>
      : GetScalarType<T[P], AggregateEspecieTracking[P]>
  }




  export type EspecieTrackingGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: EspecieTrackingWhereInput
    orderBy?: EspecieTrackingOrderByWithAggregationInput | EspecieTrackingOrderByWithAggregationInput[]
    by: EspecieTrackingScalarFieldEnum[] | EspecieTrackingScalarFieldEnum
    having?: EspecieTrackingScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: EspecieTrackingCountAggregateInputType | true
    _avg?: EspecieTrackingAvgAggregateInputType
    _sum?: EspecieTrackingSumAggregateInputType
    _min?: EspecieTrackingMinAggregateInputType
    _max?: EspecieTrackingMaxAggregateInputType
  }

  export type EspecieTrackingGroupByOutputType = {
    id_tracking: number
    id_especie_instalada: number
    fecha_registro: Date
    cantidad_actual: number
    observaciones: string | null
    _count: EspecieTrackingCountAggregateOutputType | null
    _avg: EspecieTrackingAvgAggregateOutputType | null
    _sum: EspecieTrackingSumAggregateOutputType | null
    _min: EspecieTrackingMinAggregateOutputType | null
    _max: EspecieTrackingMaxAggregateOutputType | null
  }

  type GetEspecieTrackingGroupByPayload<T extends EspecieTrackingGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<EspecieTrackingGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof EspecieTrackingGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], EspecieTrackingGroupByOutputType[P]>
            : GetScalarType<T[P], EspecieTrackingGroupByOutputType[P]>
        }
      >
    >


  export type EspecieTrackingSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id_tracking?: boolean
    id_especie_instalada?: boolean
    fecha_registro?: boolean
    cantidad_actual?: boolean
    observaciones?: boolean
    especieInstalada?: boolean | EspecieInstaladaDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["especieTracking"]>


  export type EspecieTrackingSelectScalar = {
    id_tracking?: boolean
    id_especie_instalada?: boolean
    fecha_registro?: boolean
    cantidad_actual?: boolean
    observaciones?: boolean
  }

  export type EspecieTrackingInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    especieInstalada?: boolean | EspecieInstaladaDefaultArgs<ExtArgs>
  }

  export type $EspecieTrackingPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "EspecieTracking"
    objects: {
      especieInstalada: Prisma.$EspecieInstaladaPayload<ExtArgs>
    }
    scalars: $Extensions.GetPayloadResult<{
      id_tracking: number
      id_especie_instalada: number
      fecha_registro: Date
      cantidad_actual: number
      observaciones: string | null
    }, ExtArgs["result"]["especieTracking"]>
    composites: {}
  }

  type EspecieTrackingGetPayload<S extends boolean | null | undefined | EspecieTrackingDefaultArgs> = $Result.GetResult<Prisma.$EspecieTrackingPayload, S>

  type EspecieTrackingCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = 
    Omit<EspecieTrackingFindManyArgs, 'select' | 'include' | 'distinct'> & {
      select?: EspecieTrackingCountAggregateInputType | true
    }

  export interface EspecieTrackingDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['EspecieTracking'], meta: { name: 'EspecieTracking' } }
    /**
     * Find zero or one EspecieTracking that matches the filter.
     * @param {EspecieTrackingFindUniqueArgs} args - Arguments to find a EspecieTracking
     * @example
     * // Get one EspecieTracking
     * const especieTracking = await prisma.especieTracking.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends EspecieTrackingFindUniqueArgs>(args: SelectSubset<T, EspecieTrackingFindUniqueArgs<ExtArgs>>): Prisma__EspecieTrackingClient<$Result.GetResult<Prisma.$EspecieTrackingPayload<ExtArgs>, T, "findUnique"> | null, null, ExtArgs>

    /**
     * Find one EspecieTracking that matches the filter or throw an error with `error.code='P2025'` 
     * if no matches were found.
     * @param {EspecieTrackingFindUniqueOrThrowArgs} args - Arguments to find a EspecieTracking
     * @example
     * // Get one EspecieTracking
     * const especieTracking = await prisma.especieTracking.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends EspecieTrackingFindUniqueOrThrowArgs>(args: SelectSubset<T, EspecieTrackingFindUniqueOrThrowArgs<ExtArgs>>): Prisma__EspecieTrackingClient<$Result.GetResult<Prisma.$EspecieTrackingPayload<ExtArgs>, T, "findUniqueOrThrow">, never, ExtArgs>

    /**
     * Find the first EspecieTracking that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {EspecieTrackingFindFirstArgs} args - Arguments to find a EspecieTracking
     * @example
     * // Get one EspecieTracking
     * const especieTracking = await prisma.especieTracking.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends EspecieTrackingFindFirstArgs>(args?: SelectSubset<T, EspecieTrackingFindFirstArgs<ExtArgs>>): Prisma__EspecieTrackingClient<$Result.GetResult<Prisma.$EspecieTrackingPayload<ExtArgs>, T, "findFirst"> | null, null, ExtArgs>

    /**
     * Find the first EspecieTracking that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {EspecieTrackingFindFirstOrThrowArgs} args - Arguments to find a EspecieTracking
     * @example
     * // Get one EspecieTracking
     * const especieTracking = await prisma.especieTracking.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends EspecieTrackingFindFirstOrThrowArgs>(args?: SelectSubset<T, EspecieTrackingFindFirstOrThrowArgs<ExtArgs>>): Prisma__EspecieTrackingClient<$Result.GetResult<Prisma.$EspecieTrackingPayload<ExtArgs>, T, "findFirstOrThrow">, never, ExtArgs>

    /**
     * Find zero or more EspecieTrackings that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {EspecieTrackingFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all EspecieTrackings
     * const especieTrackings = await prisma.especieTracking.findMany()
     * 
     * // Get first 10 EspecieTrackings
     * const especieTrackings = await prisma.especieTracking.findMany({ take: 10 })
     * 
     * // Only select the `id_tracking`
     * const especieTrackingWithId_trackingOnly = await prisma.especieTracking.findMany({ select: { id_tracking: true } })
     * 
     */
    findMany<T extends EspecieTrackingFindManyArgs>(args?: SelectSubset<T, EspecieTrackingFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$EspecieTrackingPayload<ExtArgs>, T, "findMany">>

    /**
     * Create a EspecieTracking.
     * @param {EspecieTrackingCreateArgs} args - Arguments to create a EspecieTracking.
     * @example
     * // Create one EspecieTracking
     * const EspecieTracking = await prisma.especieTracking.create({
     *   data: {
     *     // ... data to create a EspecieTracking
     *   }
     * })
     * 
     */
    create<T extends EspecieTrackingCreateArgs>(args: SelectSubset<T, EspecieTrackingCreateArgs<ExtArgs>>): Prisma__EspecieTrackingClient<$Result.GetResult<Prisma.$EspecieTrackingPayload<ExtArgs>, T, "create">, never, ExtArgs>

    /**
     * Create many EspecieTrackings.
     * @param {EspecieTrackingCreateManyArgs} args - Arguments to create many EspecieTrackings.
     * @example
     * // Create many EspecieTrackings
     * const especieTracking = await prisma.especieTracking.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends EspecieTrackingCreateManyArgs>(args?: SelectSubset<T, EspecieTrackingCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Delete a EspecieTracking.
     * @param {EspecieTrackingDeleteArgs} args - Arguments to delete one EspecieTracking.
     * @example
     * // Delete one EspecieTracking
     * const EspecieTracking = await prisma.especieTracking.delete({
     *   where: {
     *     // ... filter to delete one EspecieTracking
     *   }
     * })
     * 
     */
    delete<T extends EspecieTrackingDeleteArgs>(args: SelectSubset<T, EspecieTrackingDeleteArgs<ExtArgs>>): Prisma__EspecieTrackingClient<$Result.GetResult<Prisma.$EspecieTrackingPayload<ExtArgs>, T, "delete">, never, ExtArgs>

    /**
     * Update one EspecieTracking.
     * @param {EspecieTrackingUpdateArgs} args - Arguments to update one EspecieTracking.
     * @example
     * // Update one EspecieTracking
     * const especieTracking = await prisma.especieTracking.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends EspecieTrackingUpdateArgs>(args: SelectSubset<T, EspecieTrackingUpdateArgs<ExtArgs>>): Prisma__EspecieTrackingClient<$Result.GetResult<Prisma.$EspecieTrackingPayload<ExtArgs>, T, "update">, never, ExtArgs>

    /**
     * Delete zero or more EspecieTrackings.
     * @param {EspecieTrackingDeleteManyArgs} args - Arguments to filter EspecieTrackings to delete.
     * @example
     * // Delete a few EspecieTrackings
     * const { count } = await prisma.especieTracking.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends EspecieTrackingDeleteManyArgs>(args?: SelectSubset<T, EspecieTrackingDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more EspecieTrackings.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {EspecieTrackingUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many EspecieTrackings
     * const especieTracking = await prisma.especieTracking.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends EspecieTrackingUpdateManyArgs>(args: SelectSubset<T, EspecieTrackingUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one EspecieTracking.
     * @param {EspecieTrackingUpsertArgs} args - Arguments to update or create a EspecieTracking.
     * @example
     * // Update or create a EspecieTracking
     * const especieTracking = await prisma.especieTracking.upsert({
     *   create: {
     *     // ... data to create a EspecieTracking
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the EspecieTracking we want to update
     *   }
     * })
     */
    upsert<T extends EspecieTrackingUpsertArgs>(args: SelectSubset<T, EspecieTrackingUpsertArgs<ExtArgs>>): Prisma__EspecieTrackingClient<$Result.GetResult<Prisma.$EspecieTrackingPayload<ExtArgs>, T, "upsert">, never, ExtArgs>


    /**
     * Count the number of EspecieTrackings.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {EspecieTrackingCountArgs} args - Arguments to filter EspecieTrackings to count.
     * @example
     * // Count the number of EspecieTrackings
     * const count = await prisma.especieTracking.count({
     *   where: {
     *     // ... the filter for the EspecieTrackings we want to count
     *   }
     * })
    **/
    count<T extends EspecieTrackingCountArgs>(
      args?: Subset<T, EspecieTrackingCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], EspecieTrackingCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a EspecieTracking.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {EspecieTrackingAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends EspecieTrackingAggregateArgs>(args: Subset<T, EspecieTrackingAggregateArgs>): Prisma.PrismaPromise<GetEspecieTrackingAggregateType<T>>

    /**
     * Group by EspecieTracking.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {EspecieTrackingGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends EspecieTrackingGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: EspecieTrackingGroupByArgs['orderBy'] }
        : { orderBy?: EspecieTrackingGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, EspecieTrackingGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetEspecieTrackingGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the EspecieTracking model
   */
  readonly fields: EspecieTrackingFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for EspecieTracking.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__EspecieTrackingClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    especieInstalada<T extends EspecieInstaladaDefaultArgs<ExtArgs> = {}>(args?: Subset<T, EspecieInstaladaDefaultArgs<ExtArgs>>): Prisma__EspecieInstaladaClient<$Result.GetResult<Prisma.$EspecieInstaladaPayload<ExtArgs>, T, "findUniqueOrThrow"> | Null, Null, ExtArgs>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the EspecieTracking model
   */ 
  interface EspecieTrackingFieldRefs {
    readonly id_tracking: FieldRef<"EspecieTracking", 'Int'>
    readonly id_especie_instalada: FieldRef<"EspecieTracking", 'Int'>
    readonly fecha_registro: FieldRef<"EspecieTracking", 'DateTime'>
    readonly cantidad_actual: FieldRef<"EspecieTracking", 'Int'>
    readonly observaciones: FieldRef<"EspecieTracking", 'String'>
  }
    

  // Custom InputTypes
  /**
   * EspecieTracking findUnique
   */
  export type EspecieTrackingFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the EspecieTracking
     */
    select?: EspecieTrackingSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: EspecieTrackingInclude<ExtArgs> | null
    /**
     * Filter, which EspecieTracking to fetch.
     */
    where: EspecieTrackingWhereUniqueInput
  }

  /**
   * EspecieTracking findUniqueOrThrow
   */
  export type EspecieTrackingFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the EspecieTracking
     */
    select?: EspecieTrackingSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: EspecieTrackingInclude<ExtArgs> | null
    /**
     * Filter, which EspecieTracking to fetch.
     */
    where: EspecieTrackingWhereUniqueInput
  }

  /**
   * EspecieTracking findFirst
   */
  export type EspecieTrackingFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the EspecieTracking
     */
    select?: EspecieTrackingSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: EspecieTrackingInclude<ExtArgs> | null
    /**
     * Filter, which EspecieTracking to fetch.
     */
    where?: EspecieTrackingWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of EspecieTrackings to fetch.
     */
    orderBy?: EspecieTrackingOrderByWithRelationInput | EspecieTrackingOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for EspecieTrackings.
     */
    cursor?: EspecieTrackingWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` EspecieTrackings from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` EspecieTrackings.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of EspecieTrackings.
     */
    distinct?: EspecieTrackingScalarFieldEnum | EspecieTrackingScalarFieldEnum[]
  }

  /**
   * EspecieTracking findFirstOrThrow
   */
  export type EspecieTrackingFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the EspecieTracking
     */
    select?: EspecieTrackingSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: EspecieTrackingInclude<ExtArgs> | null
    /**
     * Filter, which EspecieTracking to fetch.
     */
    where?: EspecieTrackingWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of EspecieTrackings to fetch.
     */
    orderBy?: EspecieTrackingOrderByWithRelationInput | EspecieTrackingOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for EspecieTrackings.
     */
    cursor?: EspecieTrackingWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` EspecieTrackings from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` EspecieTrackings.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of EspecieTrackings.
     */
    distinct?: EspecieTrackingScalarFieldEnum | EspecieTrackingScalarFieldEnum[]
  }

  /**
   * EspecieTracking findMany
   */
  export type EspecieTrackingFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the EspecieTracking
     */
    select?: EspecieTrackingSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: EspecieTrackingInclude<ExtArgs> | null
    /**
     * Filter, which EspecieTrackings to fetch.
     */
    where?: EspecieTrackingWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of EspecieTrackings to fetch.
     */
    orderBy?: EspecieTrackingOrderByWithRelationInput | EspecieTrackingOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing EspecieTrackings.
     */
    cursor?: EspecieTrackingWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` EspecieTrackings from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` EspecieTrackings.
     */
    skip?: number
    distinct?: EspecieTrackingScalarFieldEnum | EspecieTrackingScalarFieldEnum[]
  }

  /**
   * EspecieTracking create
   */
  export type EspecieTrackingCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the EspecieTracking
     */
    select?: EspecieTrackingSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: EspecieTrackingInclude<ExtArgs> | null
    /**
     * The data needed to create a EspecieTracking.
     */
    data: XOR<EspecieTrackingCreateInput, EspecieTrackingUncheckedCreateInput>
  }

  /**
   * EspecieTracking createMany
   */
  export type EspecieTrackingCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many EspecieTrackings.
     */
    data: EspecieTrackingCreateManyInput | EspecieTrackingCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * EspecieTracking update
   */
  export type EspecieTrackingUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the EspecieTracking
     */
    select?: EspecieTrackingSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: EspecieTrackingInclude<ExtArgs> | null
    /**
     * The data needed to update a EspecieTracking.
     */
    data: XOR<EspecieTrackingUpdateInput, EspecieTrackingUncheckedUpdateInput>
    /**
     * Choose, which EspecieTracking to update.
     */
    where: EspecieTrackingWhereUniqueInput
  }

  /**
   * EspecieTracking updateMany
   */
  export type EspecieTrackingUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update EspecieTrackings.
     */
    data: XOR<EspecieTrackingUpdateManyMutationInput, EspecieTrackingUncheckedUpdateManyInput>
    /**
     * Filter which EspecieTrackings to update
     */
    where?: EspecieTrackingWhereInput
  }

  /**
   * EspecieTracking upsert
   */
  export type EspecieTrackingUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the EspecieTracking
     */
    select?: EspecieTrackingSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: EspecieTrackingInclude<ExtArgs> | null
    /**
     * The filter to search for the EspecieTracking to update in case it exists.
     */
    where: EspecieTrackingWhereUniqueInput
    /**
     * In case the EspecieTracking found by the `where` argument doesn't exist, create a new EspecieTracking with this data.
     */
    create: XOR<EspecieTrackingCreateInput, EspecieTrackingUncheckedCreateInput>
    /**
     * In case the EspecieTracking was found with the provided `where` argument, update it with this data.
     */
    update: XOR<EspecieTrackingUpdateInput, EspecieTrackingUncheckedUpdateInput>
  }

  /**
   * EspecieTracking delete
   */
  export type EspecieTrackingDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the EspecieTracking
     */
    select?: EspecieTrackingSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: EspecieTrackingInclude<ExtArgs> | null
    /**
     * Filter which EspecieTracking to delete.
     */
    where: EspecieTrackingWhereUniqueInput
  }

  /**
   * EspecieTracking deleteMany
   */
  export type EspecieTrackingDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which EspecieTrackings to delete
     */
    where?: EspecieTrackingWhereInput
  }

  /**
   * EspecieTracking without action
   */
  export type EspecieTrackingDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the EspecieTracking
     */
    select?: EspecieTrackingSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: EspecieTrackingInclude<ExtArgs> | null
  }


  /**
   * Model EspecieParametro
   */

  export type AggregateEspecieParametro = {
    _count: EspecieParametroCountAggregateOutputType | null
    _avg: EspecieParametroAvgAggregateOutputType | null
    _sum: EspecieParametroSumAggregateOutputType | null
    _min: EspecieParametroMinAggregateOutputType | null
    _max: EspecieParametroMaxAggregateOutputType | null
  }

  export type EspecieParametroAvgAggregateOutputType = {
    id_especie_parametro: number | null
    id_especie: number | null
    id_parametro: number | null
    valor_optimo_min: Decimal | null
    valor_optimo_max: Decimal | null
  }

  export type EspecieParametroSumAggregateOutputType = {
    id_especie_parametro: number | null
    id_especie: number | null
    id_parametro: number | null
    valor_optimo_min: Decimal | null
    valor_optimo_max: Decimal | null
  }

  export type EspecieParametroMinAggregateOutputType = {
    id_especie_parametro: number | null
    id_especie: number | null
    id_parametro: number | null
    valor_optimo_min: Decimal | null
    valor_optimo_max: Decimal | null
  }

  export type EspecieParametroMaxAggregateOutputType = {
    id_especie_parametro: number | null
    id_especie: number | null
    id_parametro: number | null
    valor_optimo_min: Decimal | null
    valor_optimo_max: Decimal | null
  }

  export type EspecieParametroCountAggregateOutputType = {
    id_especie_parametro: number
    id_especie: number
    id_parametro: number
    valor_optimo_min: number
    valor_optimo_max: number
    _all: number
  }


  export type EspecieParametroAvgAggregateInputType = {
    id_especie_parametro?: true
    id_especie?: true
    id_parametro?: true
    valor_optimo_min?: true
    valor_optimo_max?: true
  }

  export type EspecieParametroSumAggregateInputType = {
    id_especie_parametro?: true
    id_especie?: true
    id_parametro?: true
    valor_optimo_min?: true
    valor_optimo_max?: true
  }

  export type EspecieParametroMinAggregateInputType = {
    id_especie_parametro?: true
    id_especie?: true
    id_parametro?: true
    valor_optimo_min?: true
    valor_optimo_max?: true
  }

  export type EspecieParametroMaxAggregateInputType = {
    id_especie_parametro?: true
    id_especie?: true
    id_parametro?: true
    valor_optimo_min?: true
    valor_optimo_max?: true
  }

  export type EspecieParametroCountAggregateInputType = {
    id_especie_parametro?: true
    id_especie?: true
    id_parametro?: true
    valor_optimo_min?: true
    valor_optimo_max?: true
    _all?: true
  }

  export type EspecieParametroAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which EspecieParametro to aggregate.
     */
    where?: EspecieParametroWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of EspecieParametros to fetch.
     */
    orderBy?: EspecieParametroOrderByWithRelationInput | EspecieParametroOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: EspecieParametroWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` EspecieParametros from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` EspecieParametros.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned EspecieParametros
    **/
    _count?: true | EspecieParametroCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: EspecieParametroAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: EspecieParametroSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: EspecieParametroMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: EspecieParametroMaxAggregateInputType
  }

  export type GetEspecieParametroAggregateType<T extends EspecieParametroAggregateArgs> = {
        [P in keyof T & keyof AggregateEspecieParametro]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateEspecieParametro[P]>
      : GetScalarType<T[P], AggregateEspecieParametro[P]>
  }




  export type EspecieParametroGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: EspecieParametroWhereInput
    orderBy?: EspecieParametroOrderByWithAggregationInput | EspecieParametroOrderByWithAggregationInput[]
    by: EspecieParametroScalarFieldEnum[] | EspecieParametroScalarFieldEnum
    having?: EspecieParametroScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: EspecieParametroCountAggregateInputType | true
    _avg?: EspecieParametroAvgAggregateInputType
    _sum?: EspecieParametroSumAggregateInputType
    _min?: EspecieParametroMinAggregateInputType
    _max?: EspecieParametroMaxAggregateInputType
  }

  export type EspecieParametroGroupByOutputType = {
    id_especie_parametro: number
    id_especie: number
    id_parametro: number
    valor_optimo_min: Decimal | null
    valor_optimo_max: Decimal | null
    _count: EspecieParametroCountAggregateOutputType | null
    _avg: EspecieParametroAvgAggregateOutputType | null
    _sum: EspecieParametroSumAggregateOutputType | null
    _min: EspecieParametroMinAggregateOutputType | null
    _max: EspecieParametroMaxAggregateOutputType | null
  }

  type GetEspecieParametroGroupByPayload<T extends EspecieParametroGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<EspecieParametroGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof EspecieParametroGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], EspecieParametroGroupByOutputType[P]>
            : GetScalarType<T[P], EspecieParametroGroupByOutputType[P]>
        }
      >
    >


  export type EspecieParametroSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id_especie_parametro?: boolean
    id_especie?: boolean
    id_parametro?: boolean
    valor_optimo_min?: boolean
    valor_optimo_max?: boolean
    parametro?: boolean | ParametroDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["especieParametro"]>


  export type EspecieParametroSelectScalar = {
    id_especie_parametro?: boolean
    id_especie?: boolean
    id_parametro?: boolean
    valor_optimo_min?: boolean
    valor_optimo_max?: boolean
  }

  export type EspecieParametroInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    parametro?: boolean | ParametroDefaultArgs<ExtArgs>
  }

  export type $EspecieParametroPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "EspecieParametro"
    objects: {
      parametro: Prisma.$ParametroPayload<ExtArgs>
    }
    scalars: $Extensions.GetPayloadResult<{
      id_especie_parametro: number
      id_especie: number
      id_parametro: number
      valor_optimo_min: Prisma.Decimal | null
      valor_optimo_max: Prisma.Decimal | null
    }, ExtArgs["result"]["especieParametro"]>
    composites: {}
  }

  type EspecieParametroGetPayload<S extends boolean | null | undefined | EspecieParametroDefaultArgs> = $Result.GetResult<Prisma.$EspecieParametroPayload, S>

  type EspecieParametroCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = 
    Omit<EspecieParametroFindManyArgs, 'select' | 'include' | 'distinct'> & {
      select?: EspecieParametroCountAggregateInputType | true
    }

  export interface EspecieParametroDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['EspecieParametro'], meta: { name: 'EspecieParametro' } }
    /**
     * Find zero or one EspecieParametro that matches the filter.
     * @param {EspecieParametroFindUniqueArgs} args - Arguments to find a EspecieParametro
     * @example
     * // Get one EspecieParametro
     * const especieParametro = await prisma.especieParametro.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends EspecieParametroFindUniqueArgs>(args: SelectSubset<T, EspecieParametroFindUniqueArgs<ExtArgs>>): Prisma__EspecieParametroClient<$Result.GetResult<Prisma.$EspecieParametroPayload<ExtArgs>, T, "findUnique"> | null, null, ExtArgs>

    /**
     * Find one EspecieParametro that matches the filter or throw an error with `error.code='P2025'` 
     * if no matches were found.
     * @param {EspecieParametroFindUniqueOrThrowArgs} args - Arguments to find a EspecieParametro
     * @example
     * // Get one EspecieParametro
     * const especieParametro = await prisma.especieParametro.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends EspecieParametroFindUniqueOrThrowArgs>(args: SelectSubset<T, EspecieParametroFindUniqueOrThrowArgs<ExtArgs>>): Prisma__EspecieParametroClient<$Result.GetResult<Prisma.$EspecieParametroPayload<ExtArgs>, T, "findUniqueOrThrow">, never, ExtArgs>

    /**
     * Find the first EspecieParametro that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {EspecieParametroFindFirstArgs} args - Arguments to find a EspecieParametro
     * @example
     * // Get one EspecieParametro
     * const especieParametro = await prisma.especieParametro.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends EspecieParametroFindFirstArgs>(args?: SelectSubset<T, EspecieParametroFindFirstArgs<ExtArgs>>): Prisma__EspecieParametroClient<$Result.GetResult<Prisma.$EspecieParametroPayload<ExtArgs>, T, "findFirst"> | null, null, ExtArgs>

    /**
     * Find the first EspecieParametro that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {EspecieParametroFindFirstOrThrowArgs} args - Arguments to find a EspecieParametro
     * @example
     * // Get one EspecieParametro
     * const especieParametro = await prisma.especieParametro.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends EspecieParametroFindFirstOrThrowArgs>(args?: SelectSubset<T, EspecieParametroFindFirstOrThrowArgs<ExtArgs>>): Prisma__EspecieParametroClient<$Result.GetResult<Prisma.$EspecieParametroPayload<ExtArgs>, T, "findFirstOrThrow">, never, ExtArgs>

    /**
     * Find zero or more EspecieParametros that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {EspecieParametroFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all EspecieParametros
     * const especieParametros = await prisma.especieParametro.findMany()
     * 
     * // Get first 10 EspecieParametros
     * const especieParametros = await prisma.especieParametro.findMany({ take: 10 })
     * 
     * // Only select the `id_especie_parametro`
     * const especieParametroWithId_especie_parametroOnly = await prisma.especieParametro.findMany({ select: { id_especie_parametro: true } })
     * 
     */
    findMany<T extends EspecieParametroFindManyArgs>(args?: SelectSubset<T, EspecieParametroFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$EspecieParametroPayload<ExtArgs>, T, "findMany">>

    /**
     * Create a EspecieParametro.
     * @param {EspecieParametroCreateArgs} args - Arguments to create a EspecieParametro.
     * @example
     * // Create one EspecieParametro
     * const EspecieParametro = await prisma.especieParametro.create({
     *   data: {
     *     // ... data to create a EspecieParametro
     *   }
     * })
     * 
     */
    create<T extends EspecieParametroCreateArgs>(args: SelectSubset<T, EspecieParametroCreateArgs<ExtArgs>>): Prisma__EspecieParametroClient<$Result.GetResult<Prisma.$EspecieParametroPayload<ExtArgs>, T, "create">, never, ExtArgs>

    /**
     * Create many EspecieParametros.
     * @param {EspecieParametroCreateManyArgs} args - Arguments to create many EspecieParametros.
     * @example
     * // Create many EspecieParametros
     * const especieParametro = await prisma.especieParametro.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends EspecieParametroCreateManyArgs>(args?: SelectSubset<T, EspecieParametroCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Delete a EspecieParametro.
     * @param {EspecieParametroDeleteArgs} args - Arguments to delete one EspecieParametro.
     * @example
     * // Delete one EspecieParametro
     * const EspecieParametro = await prisma.especieParametro.delete({
     *   where: {
     *     // ... filter to delete one EspecieParametro
     *   }
     * })
     * 
     */
    delete<T extends EspecieParametroDeleteArgs>(args: SelectSubset<T, EspecieParametroDeleteArgs<ExtArgs>>): Prisma__EspecieParametroClient<$Result.GetResult<Prisma.$EspecieParametroPayload<ExtArgs>, T, "delete">, never, ExtArgs>

    /**
     * Update one EspecieParametro.
     * @param {EspecieParametroUpdateArgs} args - Arguments to update one EspecieParametro.
     * @example
     * // Update one EspecieParametro
     * const especieParametro = await prisma.especieParametro.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends EspecieParametroUpdateArgs>(args: SelectSubset<T, EspecieParametroUpdateArgs<ExtArgs>>): Prisma__EspecieParametroClient<$Result.GetResult<Prisma.$EspecieParametroPayload<ExtArgs>, T, "update">, never, ExtArgs>

    /**
     * Delete zero or more EspecieParametros.
     * @param {EspecieParametroDeleteManyArgs} args - Arguments to filter EspecieParametros to delete.
     * @example
     * // Delete a few EspecieParametros
     * const { count } = await prisma.especieParametro.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends EspecieParametroDeleteManyArgs>(args?: SelectSubset<T, EspecieParametroDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more EspecieParametros.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {EspecieParametroUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many EspecieParametros
     * const especieParametro = await prisma.especieParametro.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends EspecieParametroUpdateManyArgs>(args: SelectSubset<T, EspecieParametroUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one EspecieParametro.
     * @param {EspecieParametroUpsertArgs} args - Arguments to update or create a EspecieParametro.
     * @example
     * // Update or create a EspecieParametro
     * const especieParametro = await prisma.especieParametro.upsert({
     *   create: {
     *     // ... data to create a EspecieParametro
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the EspecieParametro we want to update
     *   }
     * })
     */
    upsert<T extends EspecieParametroUpsertArgs>(args: SelectSubset<T, EspecieParametroUpsertArgs<ExtArgs>>): Prisma__EspecieParametroClient<$Result.GetResult<Prisma.$EspecieParametroPayload<ExtArgs>, T, "upsert">, never, ExtArgs>


    /**
     * Count the number of EspecieParametros.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {EspecieParametroCountArgs} args - Arguments to filter EspecieParametros to count.
     * @example
     * // Count the number of EspecieParametros
     * const count = await prisma.especieParametro.count({
     *   where: {
     *     // ... the filter for the EspecieParametros we want to count
     *   }
     * })
    **/
    count<T extends EspecieParametroCountArgs>(
      args?: Subset<T, EspecieParametroCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], EspecieParametroCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a EspecieParametro.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {EspecieParametroAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends EspecieParametroAggregateArgs>(args: Subset<T, EspecieParametroAggregateArgs>): Prisma.PrismaPromise<GetEspecieParametroAggregateType<T>>

    /**
     * Group by EspecieParametro.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {EspecieParametroGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends EspecieParametroGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: EspecieParametroGroupByArgs['orderBy'] }
        : { orderBy?: EspecieParametroGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, EspecieParametroGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetEspecieParametroGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the EspecieParametro model
   */
  readonly fields: EspecieParametroFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for EspecieParametro.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__EspecieParametroClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    parametro<T extends ParametroDefaultArgs<ExtArgs> = {}>(args?: Subset<T, ParametroDefaultArgs<ExtArgs>>): Prisma__ParametroClient<$Result.GetResult<Prisma.$ParametroPayload<ExtArgs>, T, "findUniqueOrThrow"> | Null, Null, ExtArgs>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the EspecieParametro model
   */ 
  interface EspecieParametroFieldRefs {
    readonly id_especie_parametro: FieldRef<"EspecieParametro", 'Int'>
    readonly id_especie: FieldRef<"EspecieParametro", 'Int'>
    readonly id_parametro: FieldRef<"EspecieParametro", 'Int'>
    readonly valor_optimo_min: FieldRef<"EspecieParametro", 'Decimal'>
    readonly valor_optimo_max: FieldRef<"EspecieParametro", 'Decimal'>
  }
    

  // Custom InputTypes
  /**
   * EspecieParametro findUnique
   */
  export type EspecieParametroFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the EspecieParametro
     */
    select?: EspecieParametroSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: EspecieParametroInclude<ExtArgs> | null
    /**
     * Filter, which EspecieParametro to fetch.
     */
    where: EspecieParametroWhereUniqueInput
  }

  /**
   * EspecieParametro findUniqueOrThrow
   */
  export type EspecieParametroFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the EspecieParametro
     */
    select?: EspecieParametroSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: EspecieParametroInclude<ExtArgs> | null
    /**
     * Filter, which EspecieParametro to fetch.
     */
    where: EspecieParametroWhereUniqueInput
  }

  /**
   * EspecieParametro findFirst
   */
  export type EspecieParametroFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the EspecieParametro
     */
    select?: EspecieParametroSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: EspecieParametroInclude<ExtArgs> | null
    /**
     * Filter, which EspecieParametro to fetch.
     */
    where?: EspecieParametroWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of EspecieParametros to fetch.
     */
    orderBy?: EspecieParametroOrderByWithRelationInput | EspecieParametroOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for EspecieParametros.
     */
    cursor?: EspecieParametroWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` EspecieParametros from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` EspecieParametros.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of EspecieParametros.
     */
    distinct?: EspecieParametroScalarFieldEnum | EspecieParametroScalarFieldEnum[]
  }

  /**
   * EspecieParametro findFirstOrThrow
   */
  export type EspecieParametroFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the EspecieParametro
     */
    select?: EspecieParametroSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: EspecieParametroInclude<ExtArgs> | null
    /**
     * Filter, which EspecieParametro to fetch.
     */
    where?: EspecieParametroWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of EspecieParametros to fetch.
     */
    orderBy?: EspecieParametroOrderByWithRelationInput | EspecieParametroOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for EspecieParametros.
     */
    cursor?: EspecieParametroWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` EspecieParametros from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` EspecieParametros.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of EspecieParametros.
     */
    distinct?: EspecieParametroScalarFieldEnum | EspecieParametroScalarFieldEnum[]
  }

  /**
   * EspecieParametro findMany
   */
  export type EspecieParametroFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the EspecieParametro
     */
    select?: EspecieParametroSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: EspecieParametroInclude<ExtArgs> | null
    /**
     * Filter, which EspecieParametros to fetch.
     */
    where?: EspecieParametroWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of EspecieParametros to fetch.
     */
    orderBy?: EspecieParametroOrderByWithRelationInput | EspecieParametroOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing EspecieParametros.
     */
    cursor?: EspecieParametroWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` EspecieParametros from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` EspecieParametros.
     */
    skip?: number
    distinct?: EspecieParametroScalarFieldEnum | EspecieParametroScalarFieldEnum[]
  }

  /**
   * EspecieParametro create
   */
  export type EspecieParametroCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the EspecieParametro
     */
    select?: EspecieParametroSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: EspecieParametroInclude<ExtArgs> | null
    /**
     * The data needed to create a EspecieParametro.
     */
    data: XOR<EspecieParametroCreateInput, EspecieParametroUncheckedCreateInput>
  }

  /**
   * EspecieParametro createMany
   */
  export type EspecieParametroCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many EspecieParametros.
     */
    data: EspecieParametroCreateManyInput | EspecieParametroCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * EspecieParametro update
   */
  export type EspecieParametroUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the EspecieParametro
     */
    select?: EspecieParametroSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: EspecieParametroInclude<ExtArgs> | null
    /**
     * The data needed to update a EspecieParametro.
     */
    data: XOR<EspecieParametroUpdateInput, EspecieParametroUncheckedUpdateInput>
    /**
     * Choose, which EspecieParametro to update.
     */
    where: EspecieParametroWhereUniqueInput
  }

  /**
   * EspecieParametro updateMany
   */
  export type EspecieParametroUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update EspecieParametros.
     */
    data: XOR<EspecieParametroUpdateManyMutationInput, EspecieParametroUncheckedUpdateManyInput>
    /**
     * Filter which EspecieParametros to update
     */
    where?: EspecieParametroWhereInput
  }

  /**
   * EspecieParametro upsert
   */
  export type EspecieParametroUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the EspecieParametro
     */
    select?: EspecieParametroSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: EspecieParametroInclude<ExtArgs> | null
    /**
     * The filter to search for the EspecieParametro to update in case it exists.
     */
    where: EspecieParametroWhereUniqueInput
    /**
     * In case the EspecieParametro found by the `where` argument doesn't exist, create a new EspecieParametro with this data.
     */
    create: XOR<EspecieParametroCreateInput, EspecieParametroUncheckedCreateInput>
    /**
     * In case the EspecieParametro was found with the provided `where` argument, update it with this data.
     */
    update: XOR<EspecieParametroUpdateInput, EspecieParametroUncheckedUpdateInput>
  }

  /**
   * EspecieParametro delete
   */
  export type EspecieParametroDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the EspecieParametro
     */
    select?: EspecieParametroSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: EspecieParametroInclude<ExtArgs> | null
    /**
     * Filter which EspecieParametro to delete.
     */
    where: EspecieParametroWhereUniqueInput
  }

  /**
   * EspecieParametro deleteMany
   */
  export type EspecieParametroDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which EspecieParametros to delete
     */
    where?: EspecieParametroWhereInput
  }

  /**
   * EspecieParametro without action
   */
  export type EspecieParametroDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the EspecieParametro
     */
    select?: EspecieParametroSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: EspecieParametroInclude<ExtArgs> | null
  }


  /**
   * Model Proceso
   */

  export type AggregateProceso = {
    _count: ProcesoCountAggregateOutputType | null
    _avg: ProcesoAvgAggregateOutputType | null
    _sum: ProcesoSumAggregateOutputType | null
    _min: ProcesoMinAggregateOutputType | null
    _max: ProcesoMaxAggregateOutputType | null
  }

  export type ProcesoAvgAggregateOutputType = {
    id_proceso: number | null
    id_instalacion: number | null
  }

  export type ProcesoSumAggregateOutputType = {
    id_proceso: number | null
    id_instalacion: number | null
  }

  export type ProcesoMinAggregateOutputType = {
    id_proceso: number | null
    id_instalacion: number | null
    nombre_proceso: string | null
    descripcion: string | null
    fecha_inicio: Date | null
    fecha_fin: Date | null
    estado: string | null
  }

  export type ProcesoMaxAggregateOutputType = {
    id_proceso: number | null
    id_instalacion: number | null
    nombre_proceso: string | null
    descripcion: string | null
    fecha_inicio: Date | null
    fecha_fin: Date | null
    estado: string | null
  }

  export type ProcesoCountAggregateOutputType = {
    id_proceso: number
    id_instalacion: number
    nombre_proceso: number
    descripcion: number
    fecha_inicio: number
    fecha_fin: number
    estado: number
    _all: number
  }


  export type ProcesoAvgAggregateInputType = {
    id_proceso?: true
    id_instalacion?: true
  }

  export type ProcesoSumAggregateInputType = {
    id_proceso?: true
    id_instalacion?: true
  }

  export type ProcesoMinAggregateInputType = {
    id_proceso?: true
    id_instalacion?: true
    nombre_proceso?: true
    descripcion?: true
    fecha_inicio?: true
    fecha_fin?: true
    estado?: true
  }

  export type ProcesoMaxAggregateInputType = {
    id_proceso?: true
    id_instalacion?: true
    nombre_proceso?: true
    descripcion?: true
    fecha_inicio?: true
    fecha_fin?: true
    estado?: true
  }

  export type ProcesoCountAggregateInputType = {
    id_proceso?: true
    id_instalacion?: true
    nombre_proceso?: true
    descripcion?: true
    fecha_inicio?: true
    fecha_fin?: true
    estado?: true
    _all?: true
  }

  export type ProcesoAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Proceso to aggregate.
     */
    where?: ProcesoWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Procesos to fetch.
     */
    orderBy?: ProcesoOrderByWithRelationInput | ProcesoOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: ProcesoWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Procesos from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Procesos.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned Procesos
    **/
    _count?: true | ProcesoCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: ProcesoAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: ProcesoSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: ProcesoMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: ProcesoMaxAggregateInputType
  }

  export type GetProcesoAggregateType<T extends ProcesoAggregateArgs> = {
        [P in keyof T & keyof AggregateProceso]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateProceso[P]>
      : GetScalarType<T[P], AggregateProceso[P]>
  }




  export type ProcesoGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: ProcesoWhereInput
    orderBy?: ProcesoOrderByWithAggregationInput | ProcesoOrderByWithAggregationInput[]
    by: ProcesoScalarFieldEnum[] | ProcesoScalarFieldEnum
    having?: ProcesoScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: ProcesoCountAggregateInputType | true
    _avg?: ProcesoAvgAggregateInputType
    _sum?: ProcesoSumAggregateInputType
    _min?: ProcesoMinAggregateInputType
    _max?: ProcesoMaxAggregateInputType
  }

  export type ProcesoGroupByOutputType = {
    id_proceso: number
    id_instalacion: number
    nombre_proceso: string
    descripcion: string | null
    fecha_inicio: Date
    fecha_fin: Date | null
    estado: string
    _count: ProcesoCountAggregateOutputType | null
    _avg: ProcesoAvgAggregateOutputType | null
    _sum: ProcesoSumAggregateOutputType | null
    _min: ProcesoMinAggregateOutputType | null
    _max: ProcesoMaxAggregateOutputType | null
  }

  type GetProcesoGroupByPayload<T extends ProcesoGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<ProcesoGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof ProcesoGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], ProcesoGroupByOutputType[P]>
            : GetScalarType<T[P], ProcesoGroupByOutputType[P]>
        }
      >
    >


  export type ProcesoSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id_proceso?: boolean
    id_instalacion?: boolean
    nombre_proceso?: boolean
    descripcion?: boolean
    fecha_inicio?: boolean
    fecha_fin?: boolean
    estado?: boolean
  }, ExtArgs["result"]["proceso"]>


  export type ProcesoSelectScalar = {
    id_proceso?: boolean
    id_instalacion?: boolean
    nombre_proceso?: boolean
    descripcion?: boolean
    fecha_inicio?: boolean
    fecha_fin?: boolean
    estado?: boolean
  }


  export type $ProcesoPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "Proceso"
    objects: {}
    scalars: $Extensions.GetPayloadResult<{
      id_proceso: number
      id_instalacion: number
      nombre_proceso: string
      descripcion: string | null
      fecha_inicio: Date
      fecha_fin: Date | null
      estado: string
    }, ExtArgs["result"]["proceso"]>
    composites: {}
  }

  type ProcesoGetPayload<S extends boolean | null | undefined | ProcesoDefaultArgs> = $Result.GetResult<Prisma.$ProcesoPayload, S>

  type ProcesoCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = 
    Omit<ProcesoFindManyArgs, 'select' | 'include' | 'distinct'> & {
      select?: ProcesoCountAggregateInputType | true
    }

  export interface ProcesoDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['Proceso'], meta: { name: 'Proceso' } }
    /**
     * Find zero or one Proceso that matches the filter.
     * @param {ProcesoFindUniqueArgs} args - Arguments to find a Proceso
     * @example
     * // Get one Proceso
     * const proceso = await prisma.proceso.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends ProcesoFindUniqueArgs>(args: SelectSubset<T, ProcesoFindUniqueArgs<ExtArgs>>): Prisma__ProcesoClient<$Result.GetResult<Prisma.$ProcesoPayload<ExtArgs>, T, "findUnique"> | null, null, ExtArgs>

    /**
     * Find one Proceso that matches the filter or throw an error with `error.code='P2025'` 
     * if no matches were found.
     * @param {ProcesoFindUniqueOrThrowArgs} args - Arguments to find a Proceso
     * @example
     * // Get one Proceso
     * const proceso = await prisma.proceso.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends ProcesoFindUniqueOrThrowArgs>(args: SelectSubset<T, ProcesoFindUniqueOrThrowArgs<ExtArgs>>): Prisma__ProcesoClient<$Result.GetResult<Prisma.$ProcesoPayload<ExtArgs>, T, "findUniqueOrThrow">, never, ExtArgs>

    /**
     * Find the first Proceso that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ProcesoFindFirstArgs} args - Arguments to find a Proceso
     * @example
     * // Get one Proceso
     * const proceso = await prisma.proceso.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends ProcesoFindFirstArgs>(args?: SelectSubset<T, ProcesoFindFirstArgs<ExtArgs>>): Prisma__ProcesoClient<$Result.GetResult<Prisma.$ProcesoPayload<ExtArgs>, T, "findFirst"> | null, null, ExtArgs>

    /**
     * Find the first Proceso that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ProcesoFindFirstOrThrowArgs} args - Arguments to find a Proceso
     * @example
     * // Get one Proceso
     * const proceso = await prisma.proceso.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends ProcesoFindFirstOrThrowArgs>(args?: SelectSubset<T, ProcesoFindFirstOrThrowArgs<ExtArgs>>): Prisma__ProcesoClient<$Result.GetResult<Prisma.$ProcesoPayload<ExtArgs>, T, "findFirstOrThrow">, never, ExtArgs>

    /**
     * Find zero or more Procesos that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ProcesoFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Procesos
     * const procesos = await prisma.proceso.findMany()
     * 
     * // Get first 10 Procesos
     * const procesos = await prisma.proceso.findMany({ take: 10 })
     * 
     * // Only select the `id_proceso`
     * const procesoWithId_procesoOnly = await prisma.proceso.findMany({ select: { id_proceso: true } })
     * 
     */
    findMany<T extends ProcesoFindManyArgs>(args?: SelectSubset<T, ProcesoFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$ProcesoPayload<ExtArgs>, T, "findMany">>

    /**
     * Create a Proceso.
     * @param {ProcesoCreateArgs} args - Arguments to create a Proceso.
     * @example
     * // Create one Proceso
     * const Proceso = await prisma.proceso.create({
     *   data: {
     *     // ... data to create a Proceso
     *   }
     * })
     * 
     */
    create<T extends ProcesoCreateArgs>(args: SelectSubset<T, ProcesoCreateArgs<ExtArgs>>): Prisma__ProcesoClient<$Result.GetResult<Prisma.$ProcesoPayload<ExtArgs>, T, "create">, never, ExtArgs>

    /**
     * Create many Procesos.
     * @param {ProcesoCreateManyArgs} args - Arguments to create many Procesos.
     * @example
     * // Create many Procesos
     * const proceso = await prisma.proceso.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends ProcesoCreateManyArgs>(args?: SelectSubset<T, ProcesoCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Delete a Proceso.
     * @param {ProcesoDeleteArgs} args - Arguments to delete one Proceso.
     * @example
     * // Delete one Proceso
     * const Proceso = await prisma.proceso.delete({
     *   where: {
     *     // ... filter to delete one Proceso
     *   }
     * })
     * 
     */
    delete<T extends ProcesoDeleteArgs>(args: SelectSubset<T, ProcesoDeleteArgs<ExtArgs>>): Prisma__ProcesoClient<$Result.GetResult<Prisma.$ProcesoPayload<ExtArgs>, T, "delete">, never, ExtArgs>

    /**
     * Update one Proceso.
     * @param {ProcesoUpdateArgs} args - Arguments to update one Proceso.
     * @example
     * // Update one Proceso
     * const proceso = await prisma.proceso.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends ProcesoUpdateArgs>(args: SelectSubset<T, ProcesoUpdateArgs<ExtArgs>>): Prisma__ProcesoClient<$Result.GetResult<Prisma.$ProcesoPayload<ExtArgs>, T, "update">, never, ExtArgs>

    /**
     * Delete zero or more Procesos.
     * @param {ProcesoDeleteManyArgs} args - Arguments to filter Procesos to delete.
     * @example
     * // Delete a few Procesos
     * const { count } = await prisma.proceso.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends ProcesoDeleteManyArgs>(args?: SelectSubset<T, ProcesoDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Procesos.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ProcesoUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Procesos
     * const proceso = await prisma.proceso.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends ProcesoUpdateManyArgs>(args: SelectSubset<T, ProcesoUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one Proceso.
     * @param {ProcesoUpsertArgs} args - Arguments to update or create a Proceso.
     * @example
     * // Update or create a Proceso
     * const proceso = await prisma.proceso.upsert({
     *   create: {
     *     // ... data to create a Proceso
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Proceso we want to update
     *   }
     * })
     */
    upsert<T extends ProcesoUpsertArgs>(args: SelectSubset<T, ProcesoUpsertArgs<ExtArgs>>): Prisma__ProcesoClient<$Result.GetResult<Prisma.$ProcesoPayload<ExtArgs>, T, "upsert">, never, ExtArgs>


    /**
     * Count the number of Procesos.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ProcesoCountArgs} args - Arguments to filter Procesos to count.
     * @example
     * // Count the number of Procesos
     * const count = await prisma.proceso.count({
     *   where: {
     *     // ... the filter for the Procesos we want to count
     *   }
     * })
    **/
    count<T extends ProcesoCountArgs>(
      args?: Subset<T, ProcesoCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], ProcesoCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Proceso.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ProcesoAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends ProcesoAggregateArgs>(args: Subset<T, ProcesoAggregateArgs>): Prisma.PrismaPromise<GetProcesoAggregateType<T>>

    /**
     * Group by Proceso.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ProcesoGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends ProcesoGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: ProcesoGroupByArgs['orderBy'] }
        : { orderBy?: ProcesoGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, ProcesoGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetProcesoGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the Proceso model
   */
  readonly fields: ProcesoFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for Proceso.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__ProcesoClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the Proceso model
   */ 
  interface ProcesoFieldRefs {
    readonly id_proceso: FieldRef<"Proceso", 'Int'>
    readonly id_instalacion: FieldRef<"Proceso", 'Int'>
    readonly nombre_proceso: FieldRef<"Proceso", 'String'>
    readonly descripcion: FieldRef<"Proceso", 'String'>
    readonly fecha_inicio: FieldRef<"Proceso", 'DateTime'>
    readonly fecha_fin: FieldRef<"Proceso", 'DateTime'>
    readonly estado: FieldRef<"Proceso", 'String'>
  }
    

  // Custom InputTypes
  /**
   * Proceso findUnique
   */
  export type ProcesoFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Proceso
     */
    select?: ProcesoSelect<ExtArgs> | null
    /**
     * Filter, which Proceso to fetch.
     */
    where: ProcesoWhereUniqueInput
  }

  /**
   * Proceso findUniqueOrThrow
   */
  export type ProcesoFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Proceso
     */
    select?: ProcesoSelect<ExtArgs> | null
    /**
     * Filter, which Proceso to fetch.
     */
    where: ProcesoWhereUniqueInput
  }

  /**
   * Proceso findFirst
   */
  export type ProcesoFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Proceso
     */
    select?: ProcesoSelect<ExtArgs> | null
    /**
     * Filter, which Proceso to fetch.
     */
    where?: ProcesoWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Procesos to fetch.
     */
    orderBy?: ProcesoOrderByWithRelationInput | ProcesoOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Procesos.
     */
    cursor?: ProcesoWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Procesos from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Procesos.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Procesos.
     */
    distinct?: ProcesoScalarFieldEnum | ProcesoScalarFieldEnum[]
  }

  /**
   * Proceso findFirstOrThrow
   */
  export type ProcesoFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Proceso
     */
    select?: ProcesoSelect<ExtArgs> | null
    /**
     * Filter, which Proceso to fetch.
     */
    where?: ProcesoWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Procesos to fetch.
     */
    orderBy?: ProcesoOrderByWithRelationInput | ProcesoOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Procesos.
     */
    cursor?: ProcesoWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Procesos from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Procesos.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Procesos.
     */
    distinct?: ProcesoScalarFieldEnum | ProcesoScalarFieldEnum[]
  }

  /**
   * Proceso findMany
   */
  export type ProcesoFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Proceso
     */
    select?: ProcesoSelect<ExtArgs> | null
    /**
     * Filter, which Procesos to fetch.
     */
    where?: ProcesoWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Procesos to fetch.
     */
    orderBy?: ProcesoOrderByWithRelationInput | ProcesoOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing Procesos.
     */
    cursor?: ProcesoWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Procesos from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Procesos.
     */
    skip?: number
    distinct?: ProcesoScalarFieldEnum | ProcesoScalarFieldEnum[]
  }

  /**
   * Proceso create
   */
  export type ProcesoCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Proceso
     */
    select?: ProcesoSelect<ExtArgs> | null
    /**
     * The data needed to create a Proceso.
     */
    data: XOR<ProcesoCreateInput, ProcesoUncheckedCreateInput>
  }

  /**
   * Proceso createMany
   */
  export type ProcesoCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many Procesos.
     */
    data: ProcesoCreateManyInput | ProcesoCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * Proceso update
   */
  export type ProcesoUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Proceso
     */
    select?: ProcesoSelect<ExtArgs> | null
    /**
     * The data needed to update a Proceso.
     */
    data: XOR<ProcesoUpdateInput, ProcesoUncheckedUpdateInput>
    /**
     * Choose, which Proceso to update.
     */
    where: ProcesoWhereUniqueInput
  }

  /**
   * Proceso updateMany
   */
  export type ProcesoUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update Procesos.
     */
    data: XOR<ProcesoUpdateManyMutationInput, ProcesoUncheckedUpdateManyInput>
    /**
     * Filter which Procesos to update
     */
    where?: ProcesoWhereInput
  }

  /**
   * Proceso upsert
   */
  export type ProcesoUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Proceso
     */
    select?: ProcesoSelect<ExtArgs> | null
    /**
     * The filter to search for the Proceso to update in case it exists.
     */
    where: ProcesoWhereUniqueInput
    /**
     * In case the Proceso found by the `where` argument doesn't exist, create a new Proceso with this data.
     */
    create: XOR<ProcesoCreateInput, ProcesoUncheckedCreateInput>
    /**
     * In case the Proceso was found with the provided `where` argument, update it with this data.
     */
    update: XOR<ProcesoUpdateInput, ProcesoUncheckedUpdateInput>
  }

  /**
   * Proceso delete
   */
  export type ProcesoDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Proceso
     */
    select?: ProcesoSelect<ExtArgs> | null
    /**
     * Filter which Proceso to delete.
     */
    where: ProcesoWhereUniqueInput
  }

  /**
   * Proceso deleteMany
   */
  export type ProcesoDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Procesos to delete
     */
    where?: ProcesoWhereInput
  }

  /**
   * Proceso without action
   */
  export type ProcesoDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Proceso
     */
    select?: ProcesoSelect<ExtArgs> | null
  }


  /**
   * Enums
   */

  export const TransactionIsolationLevel: {
    ReadUncommitted: 'ReadUncommitted',
    ReadCommitted: 'ReadCommitted',
    RepeatableRead: 'RepeatableRead',
    Serializable: 'Serializable'
  };

  export type TransactionIsolationLevel = (typeof TransactionIsolationLevel)[keyof typeof TransactionIsolationLevel]


  export const OrganizacionScalarFieldEnum: {
    id_organizacion: 'id_organizacion',
    nombre: 'nombre',
    estado: 'estado',
    fecha_creacion: 'fecha_creacion'
  };

  export type OrganizacionScalarFieldEnum = (typeof OrganizacionScalarFieldEnum)[keyof typeof OrganizacionScalarFieldEnum]


  export const OrganizacionSucursalScalarFieldEnum: {
    id_organizacion_sucursal: 'id_organizacion_sucursal',
    id_organizacion: 'id_organizacion',
    nombre_sucursal: 'nombre_sucursal',
    estado: 'estado',
    fecha_creacion: 'fecha_creacion'
  };

  export type OrganizacionSucursalScalarFieldEnum = (typeof OrganizacionSucursalScalarFieldEnum)[keyof typeof OrganizacionSucursalScalarFieldEnum]


  export const InstalacionScalarFieldEnum: {
    id_instalacion: 'id_instalacion',
    id_organizacion_sucursal: 'id_organizacion_sucursal',
    nombre_instalacion: 'nombre_instalacion',
    fecha_creacion: 'fecha_creacion'
  };

  export type InstalacionScalarFieldEnum = (typeof InstalacionScalarFieldEnum)[keyof typeof InstalacionScalarFieldEnum]


  export const CatalogoSensorScalarFieldEnum: {
    id_sensor: 'id_sensor',
    nombre: 'nombre',
    unidad: 'unidad',
    tipo_medida: 'tipo_medida',
    rango_min: 'rango_min',
    rango_max: 'rango_max'
  };

  export type CatalogoSensorScalarFieldEnum = (typeof CatalogoSensorScalarFieldEnum)[keyof typeof CatalogoSensorScalarFieldEnum]


  export const SensorInstaladoScalarFieldEnum: {
    id_sensor_instalado: 'id_sensor_instalado',
    id_instalacion: 'id_instalacion',
    id_sensor: 'id_sensor',
    descripcion: 'descripcion',
    fecha_instalada: 'fecha_instalada'
  };

  export type SensorInstaladoScalarFieldEnum = (typeof SensorInstaladoScalarFieldEnum)[keyof typeof SensorInstaladoScalarFieldEnum]


  export const LecturaScalarFieldEnum: {
    id_lectura: 'id_lectura',
    id_sensor_instalado: 'id_sensor_instalado',
    valor: 'valor',
    tomada_en: 'tomada_en'
  };

  export type LecturaScalarFieldEnum = (typeof LecturaScalarFieldEnum)[keyof typeof LecturaScalarFieldEnum]


  export const ResumenLecturaHorariaScalarFieldEnum: {
    id_sensor_instalado: 'id_sensor_instalado',
    fecha_hora: 'fecha_hora',
    min_val: 'min_val',
    max_val: 'max_val',
    avg_val: 'avg_val',
    cnt: 'cnt'
  };

  export type ResumenLecturaHorariaScalarFieldEnum = (typeof ResumenLecturaHorariaScalarFieldEnum)[keyof typeof ResumenLecturaHorariaScalarFieldEnum]


  export const Promedio15minScalarFieldEnum: {
    id_sensor_instalado: 'id_sensor_instalado',
    fecha: 'fecha',
    hora: 'hora',
    promedio: 'promedio',
    fecha_actualizacion: 'fecha_actualizacion'
  };

  export type Promedio15minScalarFieldEnum = (typeof Promedio15minScalarFieldEnum)[keyof typeof Promedio15minScalarFieldEnum]


  export const EstadoScalarFieldEnum: {
    id_estado: 'id_estado',
    nombre: 'nombre',
    codigo: 'codigo'
  };

  export type EstadoScalarFieldEnum = (typeof EstadoScalarFieldEnum)[keyof typeof EstadoScalarFieldEnum]


  export const MunicipioScalarFieldEnum: {
    id_municipio: 'id_municipio',
    id_estado: 'id_estado',
    nombre: 'nombre'
  };

  export type MunicipioScalarFieldEnum = (typeof MunicipioScalarFieldEnum)[keyof typeof MunicipioScalarFieldEnum]


  export const CodigoPostalScalarFieldEnum: {
    id_codigo_postal: 'id_codigo_postal',
    id_municipio: 'id_municipio',
    codigo_postal: 'codigo_postal'
  };

  export type CodigoPostalScalarFieldEnum = (typeof CodigoPostalScalarFieldEnum)[keyof typeof CodigoPostalScalarFieldEnum]


  export const ColoniaScalarFieldEnum: {
    id_colonia: 'id_colonia',
    id_codigo_postal: 'id_codigo_postal',
    nombre: 'nombre'
  };

  export type ColoniaScalarFieldEnum = (typeof ColoniaScalarFieldEnum)[keyof typeof ColoniaScalarFieldEnum]


  export const UsuarioScalarFieldEnum: {
    id_usuario: 'id_usuario',
    nombre: 'nombre',
    email: 'email',
    password_hash: 'password_hash',
    id_tipo_rol: 'id_tipo_rol',
    activo: 'activo',
    fecha_creacion: 'fecha_creacion'
  };

  export type UsuarioScalarFieldEnum = (typeof UsuarioScalarFieldEnum)[keyof typeof UsuarioScalarFieldEnum]


  export const TipoRolScalarFieldEnum: {
    id_tipo_rol: 'id_tipo_rol',
    nombre_rol: 'nombre_rol',
    descripcion: 'descripcion'
  };

  export type TipoRolScalarFieldEnum = (typeof TipoRolScalarFieldEnum)[keyof typeof TipoRolScalarFieldEnum]


  export const AlertaScalarFieldEnum: {
    id_alerta: 'id_alerta',
    id_sensor_instalado: 'id_sensor_instalado',
    tipo_alerta: 'tipo_alerta',
    mensaje: 'mensaje',
    nivel: 'nivel',
    fecha_generada: 'fecha_generada',
    fecha_resuelta: 'fecha_resuelta',
    estado: 'estado'
  };

  export type AlertaScalarFieldEnum = (typeof AlertaScalarFieldEnum)[keyof typeof AlertaScalarFieldEnum]


  export const ParametroScalarFieldEnum: {
    id_parametro: 'id_parametro',
    nombre: 'nombre',
    unidad: 'unidad',
    descripcion: 'descripcion',
    rango_min: 'rango_min',
    rango_max: 'rango_max'
  };

  export type ParametroScalarFieldEnum = (typeof ParametroScalarFieldEnum)[keyof typeof ParametroScalarFieldEnum]


  export const CatalogoEspecieScalarFieldEnum: {
    id_especie: 'id_especie',
    nombre_cientifico: 'nombre_cientifico',
    nombre_comun: 'nombre_comun',
    tipo: 'tipo',
    descripcion: 'descripcion'
  };

  export type CatalogoEspecieScalarFieldEnum = (typeof CatalogoEspecieScalarFieldEnum)[keyof typeof CatalogoEspecieScalarFieldEnum]


  export const EspecieInstaladaScalarFieldEnum: {
    id_especie_instalada: 'id_especie_instalada',
    id_instalacion: 'id_instalacion',
    id_especie: 'id_especie',
    cantidad_inicial: 'cantidad_inicial',
    fecha_introduccion: 'fecha_introduccion',
    estado: 'estado'
  };

  export type EspecieInstaladaScalarFieldEnum = (typeof EspecieInstaladaScalarFieldEnum)[keyof typeof EspecieInstaladaScalarFieldEnum]


  export const EspecieTrackingScalarFieldEnum: {
    id_tracking: 'id_tracking',
    id_especie_instalada: 'id_especie_instalada',
    fecha_registro: 'fecha_registro',
    cantidad_actual: 'cantidad_actual',
    observaciones: 'observaciones'
  };

  export type EspecieTrackingScalarFieldEnum = (typeof EspecieTrackingScalarFieldEnum)[keyof typeof EspecieTrackingScalarFieldEnum]


  export const EspecieParametroScalarFieldEnum: {
    id_especie_parametro: 'id_especie_parametro',
    id_especie: 'id_especie',
    id_parametro: 'id_parametro',
    valor_optimo_min: 'valor_optimo_min',
    valor_optimo_max: 'valor_optimo_max'
  };

  export type EspecieParametroScalarFieldEnum = (typeof EspecieParametroScalarFieldEnum)[keyof typeof EspecieParametroScalarFieldEnum]


  export const ProcesoScalarFieldEnum: {
    id_proceso: 'id_proceso',
    id_instalacion: 'id_instalacion',
    nombre_proceso: 'nombre_proceso',
    descripcion: 'descripcion',
    fecha_inicio: 'fecha_inicio',
    fecha_fin: 'fecha_fin',
    estado: 'estado'
  };

  export type ProcesoScalarFieldEnum = (typeof ProcesoScalarFieldEnum)[keyof typeof ProcesoScalarFieldEnum]


  export const SortOrder: {
    asc: 'asc',
    desc: 'desc'
  };

  export type SortOrder = (typeof SortOrder)[keyof typeof SortOrder]


  export const NullsOrder: {
    first: 'first',
    last: 'last'
  };

  export type NullsOrder = (typeof NullsOrder)[keyof typeof NullsOrder]


  /**
   * Field references 
   */


  /**
   * Reference to a field of type 'Int'
   */
  export type IntFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'Int'>
    


  /**
   * Reference to a field of type 'String'
   */
  export type StringFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'String'>
    


  /**
   * Reference to a field of type 'DateTime'
   */
  export type DateTimeFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'DateTime'>
    


  /**
   * Reference to a field of type 'TipoMedida'
   */
  export type EnumTipoMedidaFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'TipoMedida'>
    


  /**
   * Reference to a field of type 'Decimal'
   */
  export type DecimalFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'Decimal'>
    


  /**
   * Reference to a field of type 'BigInt'
   */
  export type BigIntFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'BigInt'>
    


  /**
   * Reference to a field of type 'Boolean'
   */
  export type BooleanFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'Boolean'>
    


  /**
   * Reference to a field of type 'NivelAlerta'
   */
  export type EnumNivelAlertaFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'NivelAlerta'>
    


  /**
   * Reference to a field of type 'Float'
   */
  export type FloatFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'Float'>
    
  /**
   * Deep Input Types
   */


  export type OrganizacionWhereInput = {
    AND?: OrganizacionWhereInput | OrganizacionWhereInput[]
    OR?: OrganizacionWhereInput[]
    NOT?: OrganizacionWhereInput | OrganizacionWhereInput[]
    id_organizacion?: IntFilter<"Organizacion"> | number
    nombre?: StringFilter<"Organizacion"> | string
    estado?: StringFilter<"Organizacion"> | string
    fecha_creacion?: DateTimeFilter<"Organizacion"> | Date | string
    sucursales?: OrganizacionSucursalListRelationFilter
  }

  export type OrganizacionOrderByWithRelationInput = {
    id_organizacion?: SortOrder
    nombre?: SortOrder
    estado?: SortOrder
    fecha_creacion?: SortOrder
    sucursales?: OrganizacionSucursalOrderByRelationAggregateInput
  }

  export type OrganizacionWhereUniqueInput = Prisma.AtLeast<{
    id_organizacion?: number
    nombre?: string
    AND?: OrganizacionWhereInput | OrganizacionWhereInput[]
    OR?: OrganizacionWhereInput[]
    NOT?: OrganizacionWhereInput | OrganizacionWhereInput[]
    estado?: StringFilter<"Organizacion"> | string
    fecha_creacion?: DateTimeFilter<"Organizacion"> | Date | string
    sucursales?: OrganizacionSucursalListRelationFilter
  }, "id_organizacion" | "nombre">

  export type OrganizacionOrderByWithAggregationInput = {
    id_organizacion?: SortOrder
    nombre?: SortOrder
    estado?: SortOrder
    fecha_creacion?: SortOrder
    _count?: OrganizacionCountOrderByAggregateInput
    _avg?: OrganizacionAvgOrderByAggregateInput
    _max?: OrganizacionMaxOrderByAggregateInput
    _min?: OrganizacionMinOrderByAggregateInput
    _sum?: OrganizacionSumOrderByAggregateInput
  }

  export type OrganizacionScalarWhereWithAggregatesInput = {
    AND?: OrganizacionScalarWhereWithAggregatesInput | OrganizacionScalarWhereWithAggregatesInput[]
    OR?: OrganizacionScalarWhereWithAggregatesInput[]
    NOT?: OrganizacionScalarWhereWithAggregatesInput | OrganizacionScalarWhereWithAggregatesInput[]
    id_organizacion?: IntWithAggregatesFilter<"Organizacion"> | number
    nombre?: StringWithAggregatesFilter<"Organizacion"> | string
    estado?: StringWithAggregatesFilter<"Organizacion"> | string
    fecha_creacion?: DateTimeWithAggregatesFilter<"Organizacion"> | Date | string
  }

  export type OrganizacionSucursalWhereInput = {
    AND?: OrganizacionSucursalWhereInput | OrganizacionSucursalWhereInput[]
    OR?: OrganizacionSucursalWhereInput[]
    NOT?: OrganizacionSucursalWhereInput | OrganizacionSucursalWhereInput[]
    id_organizacion_sucursal?: IntFilter<"OrganizacionSucursal"> | number
    id_organizacion?: IntFilter<"OrganizacionSucursal"> | number
    nombre_sucursal?: StringFilter<"OrganizacionSucursal"> | string
    estado?: StringFilter<"OrganizacionSucursal"> | string
    fecha_creacion?: DateTimeFilter<"OrganizacionSucursal"> | Date | string
    organizacion?: XOR<OrganizacionRelationFilter, OrganizacionWhereInput>
    instalaciones?: InstalacionListRelationFilter
  }

  export type OrganizacionSucursalOrderByWithRelationInput = {
    id_organizacion_sucursal?: SortOrder
    id_organizacion?: SortOrder
    nombre_sucursal?: SortOrder
    estado?: SortOrder
    fecha_creacion?: SortOrder
    organizacion?: OrganizacionOrderByWithRelationInput
    instalaciones?: InstalacionOrderByRelationAggregateInput
  }

  export type OrganizacionSucursalWhereUniqueInput = Prisma.AtLeast<{
    id_organizacion_sucursal?: number
    AND?: OrganizacionSucursalWhereInput | OrganizacionSucursalWhereInput[]
    OR?: OrganizacionSucursalWhereInput[]
    NOT?: OrganizacionSucursalWhereInput | OrganizacionSucursalWhereInput[]
    id_organizacion?: IntFilter<"OrganizacionSucursal"> | number
    nombre_sucursal?: StringFilter<"OrganizacionSucursal"> | string
    estado?: StringFilter<"OrganizacionSucursal"> | string
    fecha_creacion?: DateTimeFilter<"OrganizacionSucursal"> | Date | string
    organizacion?: XOR<OrganizacionRelationFilter, OrganizacionWhereInput>
    instalaciones?: InstalacionListRelationFilter
  }, "id_organizacion_sucursal">

  export type OrganizacionSucursalOrderByWithAggregationInput = {
    id_organizacion_sucursal?: SortOrder
    id_organizacion?: SortOrder
    nombre_sucursal?: SortOrder
    estado?: SortOrder
    fecha_creacion?: SortOrder
    _count?: OrganizacionSucursalCountOrderByAggregateInput
    _avg?: OrganizacionSucursalAvgOrderByAggregateInput
    _max?: OrganizacionSucursalMaxOrderByAggregateInput
    _min?: OrganizacionSucursalMinOrderByAggregateInput
    _sum?: OrganizacionSucursalSumOrderByAggregateInput
  }

  export type OrganizacionSucursalScalarWhereWithAggregatesInput = {
    AND?: OrganizacionSucursalScalarWhereWithAggregatesInput | OrganizacionSucursalScalarWhereWithAggregatesInput[]
    OR?: OrganizacionSucursalScalarWhereWithAggregatesInput[]
    NOT?: OrganizacionSucursalScalarWhereWithAggregatesInput | OrganizacionSucursalScalarWhereWithAggregatesInput[]
    id_organizacion_sucursal?: IntWithAggregatesFilter<"OrganizacionSucursal"> | number
    id_organizacion?: IntWithAggregatesFilter<"OrganizacionSucursal"> | number
    nombre_sucursal?: StringWithAggregatesFilter<"OrganizacionSucursal"> | string
    estado?: StringWithAggregatesFilter<"OrganizacionSucursal"> | string
    fecha_creacion?: DateTimeWithAggregatesFilter<"OrganizacionSucursal"> | Date | string
  }

  export type InstalacionWhereInput = {
    AND?: InstalacionWhereInput | InstalacionWhereInput[]
    OR?: InstalacionWhereInput[]
    NOT?: InstalacionWhereInput | InstalacionWhereInput[]
    id_instalacion?: IntFilter<"Instalacion"> | number
    id_organizacion_sucursal?: IntFilter<"Instalacion"> | number
    nombre_instalacion?: StringFilter<"Instalacion"> | string
    fecha_creacion?: DateTimeFilter<"Instalacion"> | Date | string
    sucursal?: XOR<OrganizacionSucursalRelationFilter, OrganizacionSucursalWhereInput>
    sensores?: SensorInstaladoListRelationFilter
  }

  export type InstalacionOrderByWithRelationInput = {
    id_instalacion?: SortOrder
    id_organizacion_sucursal?: SortOrder
    nombre_instalacion?: SortOrder
    fecha_creacion?: SortOrder
    sucursal?: OrganizacionSucursalOrderByWithRelationInput
    sensores?: SensorInstaladoOrderByRelationAggregateInput
  }

  export type InstalacionWhereUniqueInput = Prisma.AtLeast<{
    id_instalacion?: number
    AND?: InstalacionWhereInput | InstalacionWhereInput[]
    OR?: InstalacionWhereInput[]
    NOT?: InstalacionWhereInput | InstalacionWhereInput[]
    id_organizacion_sucursal?: IntFilter<"Instalacion"> | number
    nombre_instalacion?: StringFilter<"Instalacion"> | string
    fecha_creacion?: DateTimeFilter<"Instalacion"> | Date | string
    sucursal?: XOR<OrganizacionSucursalRelationFilter, OrganizacionSucursalWhereInput>
    sensores?: SensorInstaladoListRelationFilter
  }, "id_instalacion">

  export type InstalacionOrderByWithAggregationInput = {
    id_instalacion?: SortOrder
    id_organizacion_sucursal?: SortOrder
    nombre_instalacion?: SortOrder
    fecha_creacion?: SortOrder
    _count?: InstalacionCountOrderByAggregateInput
    _avg?: InstalacionAvgOrderByAggregateInput
    _max?: InstalacionMaxOrderByAggregateInput
    _min?: InstalacionMinOrderByAggregateInput
    _sum?: InstalacionSumOrderByAggregateInput
  }

  export type InstalacionScalarWhereWithAggregatesInput = {
    AND?: InstalacionScalarWhereWithAggregatesInput | InstalacionScalarWhereWithAggregatesInput[]
    OR?: InstalacionScalarWhereWithAggregatesInput[]
    NOT?: InstalacionScalarWhereWithAggregatesInput | InstalacionScalarWhereWithAggregatesInput[]
    id_instalacion?: IntWithAggregatesFilter<"Instalacion"> | number
    id_organizacion_sucursal?: IntWithAggregatesFilter<"Instalacion"> | number
    nombre_instalacion?: StringWithAggregatesFilter<"Instalacion"> | string
    fecha_creacion?: DateTimeWithAggregatesFilter<"Instalacion"> | Date | string
  }

  export type CatalogoSensorWhereInput = {
    AND?: CatalogoSensorWhereInput | CatalogoSensorWhereInput[]
    OR?: CatalogoSensorWhereInput[]
    NOT?: CatalogoSensorWhereInput | CatalogoSensorWhereInput[]
    id_sensor?: IntFilter<"CatalogoSensor"> | number
    nombre?: StringFilter<"CatalogoSensor"> | string
    unidad?: StringNullableFilter<"CatalogoSensor"> | string | null
    tipo_medida?: EnumTipoMedidaNullableFilter<"CatalogoSensor"> | $Enums.TipoMedida | null
    rango_min?: DecimalNullableFilter<"CatalogoSensor"> | Decimal | DecimalJsLike | number | string | null
    rango_max?: DecimalNullableFilter<"CatalogoSensor"> | Decimal | DecimalJsLike | number | string | null
    sensoresInstalados?: SensorInstaladoListRelationFilter
  }

  export type CatalogoSensorOrderByWithRelationInput = {
    id_sensor?: SortOrder
    nombre?: SortOrder
    unidad?: SortOrderInput | SortOrder
    tipo_medida?: SortOrderInput | SortOrder
    rango_min?: SortOrderInput | SortOrder
    rango_max?: SortOrderInput | SortOrder
    sensoresInstalados?: SensorInstaladoOrderByRelationAggregateInput
  }

  export type CatalogoSensorWhereUniqueInput = Prisma.AtLeast<{
    id_sensor?: number
    nombre?: string
    AND?: CatalogoSensorWhereInput | CatalogoSensorWhereInput[]
    OR?: CatalogoSensorWhereInput[]
    NOT?: CatalogoSensorWhereInput | CatalogoSensorWhereInput[]
    unidad?: StringNullableFilter<"CatalogoSensor"> | string | null
    tipo_medida?: EnumTipoMedidaNullableFilter<"CatalogoSensor"> | $Enums.TipoMedida | null
    rango_min?: DecimalNullableFilter<"CatalogoSensor"> | Decimal | DecimalJsLike | number | string | null
    rango_max?: DecimalNullableFilter<"CatalogoSensor"> | Decimal | DecimalJsLike | number | string | null
    sensoresInstalados?: SensorInstaladoListRelationFilter
  }, "id_sensor" | "nombre">

  export type CatalogoSensorOrderByWithAggregationInput = {
    id_sensor?: SortOrder
    nombre?: SortOrder
    unidad?: SortOrderInput | SortOrder
    tipo_medida?: SortOrderInput | SortOrder
    rango_min?: SortOrderInput | SortOrder
    rango_max?: SortOrderInput | SortOrder
    _count?: CatalogoSensorCountOrderByAggregateInput
    _avg?: CatalogoSensorAvgOrderByAggregateInput
    _max?: CatalogoSensorMaxOrderByAggregateInput
    _min?: CatalogoSensorMinOrderByAggregateInput
    _sum?: CatalogoSensorSumOrderByAggregateInput
  }

  export type CatalogoSensorScalarWhereWithAggregatesInput = {
    AND?: CatalogoSensorScalarWhereWithAggregatesInput | CatalogoSensorScalarWhereWithAggregatesInput[]
    OR?: CatalogoSensorScalarWhereWithAggregatesInput[]
    NOT?: CatalogoSensorScalarWhereWithAggregatesInput | CatalogoSensorScalarWhereWithAggregatesInput[]
    id_sensor?: IntWithAggregatesFilter<"CatalogoSensor"> | number
    nombre?: StringWithAggregatesFilter<"CatalogoSensor"> | string
    unidad?: StringNullableWithAggregatesFilter<"CatalogoSensor"> | string | null
    tipo_medida?: EnumTipoMedidaNullableWithAggregatesFilter<"CatalogoSensor"> | $Enums.TipoMedida | null
    rango_min?: DecimalNullableWithAggregatesFilter<"CatalogoSensor"> | Decimal | DecimalJsLike | number | string | null
    rango_max?: DecimalNullableWithAggregatesFilter<"CatalogoSensor"> | Decimal | DecimalJsLike | number | string | null
  }

  export type SensorInstaladoWhereInput = {
    AND?: SensorInstaladoWhereInput | SensorInstaladoWhereInput[]
    OR?: SensorInstaladoWhereInput[]
    NOT?: SensorInstaladoWhereInput | SensorInstaladoWhereInput[]
    id_sensor_instalado?: IntFilter<"SensorInstalado"> | number
    id_instalacion?: IntFilter<"SensorInstalado"> | number
    id_sensor?: IntFilter<"SensorInstalado"> | number
    descripcion?: StringNullableFilter<"SensorInstalado"> | string | null
    fecha_instalada?: DateTimeNullableFilter<"SensorInstalado"> | Date | string | null
    instalacion?: XOR<InstalacionRelationFilter, InstalacionWhereInput>
    catalogo?: XOR<CatalogoSensorRelationFilter, CatalogoSensorWhereInput>
    lecturas?: LecturaListRelationFilter
  }

  export type SensorInstaladoOrderByWithRelationInput = {
    id_sensor_instalado?: SortOrder
    id_instalacion?: SortOrder
    id_sensor?: SortOrder
    descripcion?: SortOrderInput | SortOrder
    fecha_instalada?: SortOrderInput | SortOrder
    instalacion?: InstalacionOrderByWithRelationInput
    catalogo?: CatalogoSensorOrderByWithRelationInput
    lecturas?: LecturaOrderByRelationAggregateInput
  }

  export type SensorInstaladoWhereUniqueInput = Prisma.AtLeast<{
    id_sensor_instalado?: number
    AND?: SensorInstaladoWhereInput | SensorInstaladoWhereInput[]
    OR?: SensorInstaladoWhereInput[]
    NOT?: SensorInstaladoWhereInput | SensorInstaladoWhereInput[]
    id_instalacion?: IntFilter<"SensorInstalado"> | number
    id_sensor?: IntFilter<"SensorInstalado"> | number
    descripcion?: StringNullableFilter<"SensorInstalado"> | string | null
    fecha_instalada?: DateTimeNullableFilter<"SensorInstalado"> | Date | string | null
    instalacion?: XOR<InstalacionRelationFilter, InstalacionWhereInput>
    catalogo?: XOR<CatalogoSensorRelationFilter, CatalogoSensorWhereInput>
    lecturas?: LecturaListRelationFilter
  }, "id_sensor_instalado">

  export type SensorInstaladoOrderByWithAggregationInput = {
    id_sensor_instalado?: SortOrder
    id_instalacion?: SortOrder
    id_sensor?: SortOrder
    descripcion?: SortOrderInput | SortOrder
    fecha_instalada?: SortOrderInput | SortOrder
    _count?: SensorInstaladoCountOrderByAggregateInput
    _avg?: SensorInstaladoAvgOrderByAggregateInput
    _max?: SensorInstaladoMaxOrderByAggregateInput
    _min?: SensorInstaladoMinOrderByAggregateInput
    _sum?: SensorInstaladoSumOrderByAggregateInput
  }

  export type SensorInstaladoScalarWhereWithAggregatesInput = {
    AND?: SensorInstaladoScalarWhereWithAggregatesInput | SensorInstaladoScalarWhereWithAggregatesInput[]
    OR?: SensorInstaladoScalarWhereWithAggregatesInput[]
    NOT?: SensorInstaladoScalarWhereWithAggregatesInput | SensorInstaladoScalarWhereWithAggregatesInput[]
    id_sensor_instalado?: IntWithAggregatesFilter<"SensorInstalado"> | number
    id_instalacion?: IntWithAggregatesFilter<"SensorInstalado"> | number
    id_sensor?: IntWithAggregatesFilter<"SensorInstalado"> | number
    descripcion?: StringNullableWithAggregatesFilter<"SensorInstalado"> | string | null
    fecha_instalada?: DateTimeNullableWithAggregatesFilter<"SensorInstalado"> | Date | string | null
  }

  export type LecturaWhereInput = {
    AND?: LecturaWhereInput | LecturaWhereInput[]
    OR?: LecturaWhereInput[]
    NOT?: LecturaWhereInput | LecturaWhereInput[]
    id_lectura?: BigIntFilter<"Lectura"> | bigint | number
    id_sensor_instalado?: IntFilter<"Lectura"> | number
    valor?: DecimalFilter<"Lectura"> | Decimal | DecimalJsLike | number | string
    tomada_en?: DateTimeFilter<"Lectura"> | Date | string
    sensor?: XOR<SensorInstaladoRelationFilter, SensorInstaladoWhereInput>
  }

  export type LecturaOrderByWithRelationInput = {
    id_lectura?: SortOrder
    id_sensor_instalado?: SortOrder
    valor?: SortOrder
    tomada_en?: SortOrder
    sensor?: SensorInstaladoOrderByWithRelationInput
  }

  export type LecturaWhereUniqueInput = Prisma.AtLeast<{
    id_lectura?: bigint | number
    AND?: LecturaWhereInput | LecturaWhereInput[]
    OR?: LecturaWhereInput[]
    NOT?: LecturaWhereInput | LecturaWhereInput[]
    id_sensor_instalado?: IntFilter<"Lectura"> | number
    valor?: DecimalFilter<"Lectura"> | Decimal | DecimalJsLike | number | string
    tomada_en?: DateTimeFilter<"Lectura"> | Date | string
    sensor?: XOR<SensorInstaladoRelationFilter, SensorInstaladoWhereInput>
  }, "id_lectura">

  export type LecturaOrderByWithAggregationInput = {
    id_lectura?: SortOrder
    id_sensor_instalado?: SortOrder
    valor?: SortOrder
    tomada_en?: SortOrder
    _count?: LecturaCountOrderByAggregateInput
    _avg?: LecturaAvgOrderByAggregateInput
    _max?: LecturaMaxOrderByAggregateInput
    _min?: LecturaMinOrderByAggregateInput
    _sum?: LecturaSumOrderByAggregateInput
  }

  export type LecturaScalarWhereWithAggregatesInput = {
    AND?: LecturaScalarWhereWithAggregatesInput | LecturaScalarWhereWithAggregatesInput[]
    OR?: LecturaScalarWhereWithAggregatesInput[]
    NOT?: LecturaScalarWhereWithAggregatesInput | LecturaScalarWhereWithAggregatesInput[]
    id_lectura?: BigIntWithAggregatesFilter<"Lectura"> | bigint | number
    id_sensor_instalado?: IntWithAggregatesFilter<"Lectura"> | number
    valor?: DecimalWithAggregatesFilter<"Lectura"> | Decimal | DecimalJsLike | number | string
    tomada_en?: DateTimeWithAggregatesFilter<"Lectura"> | Date | string
  }

  export type ResumenLecturaHorariaWhereInput = {
    AND?: ResumenLecturaHorariaWhereInput | ResumenLecturaHorariaWhereInput[]
    OR?: ResumenLecturaHorariaWhereInput[]
    NOT?: ResumenLecturaHorariaWhereInput | ResumenLecturaHorariaWhereInput[]
    id_sensor_instalado?: IntFilter<"ResumenLecturaHoraria"> | number
    fecha_hora?: DateTimeFilter<"ResumenLecturaHoraria"> | Date | string
    min_val?: DecimalFilter<"ResumenLecturaHoraria"> | Decimal | DecimalJsLike | number | string
    max_val?: DecimalFilter<"ResumenLecturaHoraria"> | Decimal | DecimalJsLike | number | string
    avg_val?: DecimalFilter<"ResumenLecturaHoraria"> | Decimal | DecimalJsLike | number | string
    cnt?: IntFilter<"ResumenLecturaHoraria"> | number
  }

  export type ResumenLecturaHorariaOrderByWithRelationInput = {
    id_sensor_instalado?: SortOrder
    fecha_hora?: SortOrder
    min_val?: SortOrder
    max_val?: SortOrder
    avg_val?: SortOrder
    cnt?: SortOrder
  }

  export type ResumenLecturaHorariaWhereUniqueInput = Prisma.AtLeast<{
    id_sensor_instalado_fecha_hora?: ResumenLecturaHorariaId_sensor_instaladoFecha_horaCompoundUniqueInput
    AND?: ResumenLecturaHorariaWhereInput | ResumenLecturaHorariaWhereInput[]
    OR?: ResumenLecturaHorariaWhereInput[]
    NOT?: ResumenLecturaHorariaWhereInput | ResumenLecturaHorariaWhereInput[]
    id_sensor_instalado?: IntFilter<"ResumenLecturaHoraria"> | number
    fecha_hora?: DateTimeFilter<"ResumenLecturaHoraria"> | Date | string
    min_val?: DecimalFilter<"ResumenLecturaHoraria"> | Decimal | DecimalJsLike | number | string
    max_val?: DecimalFilter<"ResumenLecturaHoraria"> | Decimal | DecimalJsLike | number | string
    avg_val?: DecimalFilter<"ResumenLecturaHoraria"> | Decimal | DecimalJsLike | number | string
    cnt?: IntFilter<"ResumenLecturaHoraria"> | number
  }, "id_sensor_instalado_fecha_hora">

  export type ResumenLecturaHorariaOrderByWithAggregationInput = {
    id_sensor_instalado?: SortOrder
    fecha_hora?: SortOrder
    min_val?: SortOrder
    max_val?: SortOrder
    avg_val?: SortOrder
    cnt?: SortOrder
    _count?: ResumenLecturaHorariaCountOrderByAggregateInput
    _avg?: ResumenLecturaHorariaAvgOrderByAggregateInput
    _max?: ResumenLecturaHorariaMaxOrderByAggregateInput
    _min?: ResumenLecturaHorariaMinOrderByAggregateInput
    _sum?: ResumenLecturaHorariaSumOrderByAggregateInput
  }

  export type ResumenLecturaHorariaScalarWhereWithAggregatesInput = {
    AND?: ResumenLecturaHorariaScalarWhereWithAggregatesInput | ResumenLecturaHorariaScalarWhereWithAggregatesInput[]
    OR?: ResumenLecturaHorariaScalarWhereWithAggregatesInput[]
    NOT?: ResumenLecturaHorariaScalarWhereWithAggregatesInput | ResumenLecturaHorariaScalarWhereWithAggregatesInput[]
    id_sensor_instalado?: IntWithAggregatesFilter<"ResumenLecturaHoraria"> | number
    fecha_hora?: DateTimeWithAggregatesFilter<"ResumenLecturaHoraria"> | Date | string
    min_val?: DecimalWithAggregatesFilter<"ResumenLecturaHoraria"> | Decimal | DecimalJsLike | number | string
    max_val?: DecimalWithAggregatesFilter<"ResumenLecturaHoraria"> | Decimal | DecimalJsLike | number | string
    avg_val?: DecimalWithAggregatesFilter<"ResumenLecturaHoraria"> | Decimal | DecimalJsLike | number | string
    cnt?: IntWithAggregatesFilter<"ResumenLecturaHoraria"> | number
  }

  export type Promedio15minWhereInput = {
    AND?: Promedio15minWhereInput | Promedio15minWhereInput[]
    OR?: Promedio15minWhereInput[]
    NOT?: Promedio15minWhereInput | Promedio15minWhereInput[]
    id_sensor_instalado?: IntFilter<"Promedio15min"> | number
    fecha?: DateTimeFilter<"Promedio15min"> | Date | string
    hora?: DateTimeFilter<"Promedio15min"> | Date | string
    promedio?: DecimalFilter<"Promedio15min"> | Decimal | DecimalJsLike | number | string
    fecha_actualizacion?: DateTimeFilter<"Promedio15min"> | Date | string
  }

  export type Promedio15minOrderByWithRelationInput = {
    id_sensor_instalado?: SortOrder
    fecha?: SortOrder
    hora?: SortOrder
    promedio?: SortOrder
    fecha_actualizacion?: SortOrder
  }

  export type Promedio15minWhereUniqueInput = Prisma.AtLeast<{
    id_sensor_instalado_fecha_hora?: Promedio15minId_sensor_instaladoFechaHoraCompoundUniqueInput
    AND?: Promedio15minWhereInput | Promedio15minWhereInput[]
    OR?: Promedio15minWhereInput[]
    NOT?: Promedio15minWhereInput | Promedio15minWhereInput[]
    id_sensor_instalado?: IntFilter<"Promedio15min"> | number
    fecha?: DateTimeFilter<"Promedio15min"> | Date | string
    hora?: DateTimeFilter<"Promedio15min"> | Date | string
    promedio?: DecimalFilter<"Promedio15min"> | Decimal | DecimalJsLike | number | string
    fecha_actualizacion?: DateTimeFilter<"Promedio15min"> | Date | string
  }, "id_sensor_instalado_fecha_hora">

  export type Promedio15minOrderByWithAggregationInput = {
    id_sensor_instalado?: SortOrder
    fecha?: SortOrder
    hora?: SortOrder
    promedio?: SortOrder
    fecha_actualizacion?: SortOrder
    _count?: Promedio15minCountOrderByAggregateInput
    _avg?: Promedio15minAvgOrderByAggregateInput
    _max?: Promedio15minMaxOrderByAggregateInput
    _min?: Promedio15minMinOrderByAggregateInput
    _sum?: Promedio15minSumOrderByAggregateInput
  }

  export type Promedio15minScalarWhereWithAggregatesInput = {
    AND?: Promedio15minScalarWhereWithAggregatesInput | Promedio15minScalarWhereWithAggregatesInput[]
    OR?: Promedio15minScalarWhereWithAggregatesInput[]
    NOT?: Promedio15minScalarWhereWithAggregatesInput | Promedio15minScalarWhereWithAggregatesInput[]
    id_sensor_instalado?: IntWithAggregatesFilter<"Promedio15min"> | number
    fecha?: DateTimeWithAggregatesFilter<"Promedio15min"> | Date | string
    hora?: DateTimeWithAggregatesFilter<"Promedio15min"> | Date | string
    promedio?: DecimalWithAggregatesFilter<"Promedio15min"> | Decimal | DecimalJsLike | number | string
    fecha_actualizacion?: DateTimeWithAggregatesFilter<"Promedio15min"> | Date | string
  }

  export type EstadoWhereInput = {
    AND?: EstadoWhereInput | EstadoWhereInput[]
    OR?: EstadoWhereInput[]
    NOT?: EstadoWhereInput | EstadoWhereInput[]
    id_estado?: IntFilter<"Estado"> | number
    nombre?: StringFilter<"Estado"> | string
    codigo?: StringFilter<"Estado"> | string
    municipios?: MunicipioListRelationFilter
  }

  export type EstadoOrderByWithRelationInput = {
    id_estado?: SortOrder
    nombre?: SortOrder
    codigo?: SortOrder
    municipios?: MunicipioOrderByRelationAggregateInput
  }

  export type EstadoWhereUniqueInput = Prisma.AtLeast<{
    id_estado?: number
    codigo?: string
    AND?: EstadoWhereInput | EstadoWhereInput[]
    OR?: EstadoWhereInput[]
    NOT?: EstadoWhereInput | EstadoWhereInput[]
    nombre?: StringFilter<"Estado"> | string
    municipios?: MunicipioListRelationFilter
  }, "id_estado" | "codigo">

  export type EstadoOrderByWithAggregationInput = {
    id_estado?: SortOrder
    nombre?: SortOrder
    codigo?: SortOrder
    _count?: EstadoCountOrderByAggregateInput
    _avg?: EstadoAvgOrderByAggregateInput
    _max?: EstadoMaxOrderByAggregateInput
    _min?: EstadoMinOrderByAggregateInput
    _sum?: EstadoSumOrderByAggregateInput
  }

  export type EstadoScalarWhereWithAggregatesInput = {
    AND?: EstadoScalarWhereWithAggregatesInput | EstadoScalarWhereWithAggregatesInput[]
    OR?: EstadoScalarWhereWithAggregatesInput[]
    NOT?: EstadoScalarWhereWithAggregatesInput | EstadoScalarWhereWithAggregatesInput[]
    id_estado?: IntWithAggregatesFilter<"Estado"> | number
    nombre?: StringWithAggregatesFilter<"Estado"> | string
    codigo?: StringWithAggregatesFilter<"Estado"> | string
  }

  export type MunicipioWhereInput = {
    AND?: MunicipioWhereInput | MunicipioWhereInput[]
    OR?: MunicipioWhereInput[]
    NOT?: MunicipioWhereInput | MunicipioWhereInput[]
    id_municipio?: IntFilter<"Municipio"> | number
    id_estado?: IntFilter<"Municipio"> | number
    nombre?: StringFilter<"Municipio"> | string
    estado?: XOR<EstadoRelationFilter, EstadoWhereInput>
    codigosPostales?: CodigoPostalListRelationFilter
  }

  export type MunicipioOrderByWithRelationInput = {
    id_municipio?: SortOrder
    id_estado?: SortOrder
    nombre?: SortOrder
    estado?: EstadoOrderByWithRelationInput
    codigosPostales?: CodigoPostalOrderByRelationAggregateInput
  }

  export type MunicipioWhereUniqueInput = Prisma.AtLeast<{
    id_municipio?: number
    AND?: MunicipioWhereInput | MunicipioWhereInput[]
    OR?: MunicipioWhereInput[]
    NOT?: MunicipioWhereInput | MunicipioWhereInput[]
    id_estado?: IntFilter<"Municipio"> | number
    nombre?: StringFilter<"Municipio"> | string
    estado?: XOR<EstadoRelationFilter, EstadoWhereInput>
    codigosPostales?: CodigoPostalListRelationFilter
  }, "id_municipio">

  export type MunicipioOrderByWithAggregationInput = {
    id_municipio?: SortOrder
    id_estado?: SortOrder
    nombre?: SortOrder
    _count?: MunicipioCountOrderByAggregateInput
    _avg?: MunicipioAvgOrderByAggregateInput
    _max?: MunicipioMaxOrderByAggregateInput
    _min?: MunicipioMinOrderByAggregateInput
    _sum?: MunicipioSumOrderByAggregateInput
  }

  export type MunicipioScalarWhereWithAggregatesInput = {
    AND?: MunicipioScalarWhereWithAggregatesInput | MunicipioScalarWhereWithAggregatesInput[]
    OR?: MunicipioScalarWhereWithAggregatesInput[]
    NOT?: MunicipioScalarWhereWithAggregatesInput | MunicipioScalarWhereWithAggregatesInput[]
    id_municipio?: IntWithAggregatesFilter<"Municipio"> | number
    id_estado?: IntWithAggregatesFilter<"Municipio"> | number
    nombre?: StringWithAggregatesFilter<"Municipio"> | string
  }

  export type CodigoPostalWhereInput = {
    AND?: CodigoPostalWhereInput | CodigoPostalWhereInput[]
    OR?: CodigoPostalWhereInput[]
    NOT?: CodigoPostalWhereInput | CodigoPostalWhereInput[]
    id_codigo_postal?: IntFilter<"CodigoPostal"> | number
    id_municipio?: IntFilter<"CodigoPostal"> | number
    codigo_postal?: StringFilter<"CodigoPostal"> | string
    municipio?: XOR<MunicipioRelationFilter, MunicipioWhereInput>
    colonias?: ColoniaListRelationFilter
  }

  export type CodigoPostalOrderByWithRelationInput = {
    id_codigo_postal?: SortOrder
    id_municipio?: SortOrder
    codigo_postal?: SortOrder
    municipio?: MunicipioOrderByWithRelationInput
    colonias?: ColoniaOrderByRelationAggregateInput
  }

  export type CodigoPostalWhereUniqueInput = Prisma.AtLeast<{
    id_codigo_postal?: number
    codigo_postal?: string
    AND?: CodigoPostalWhereInput | CodigoPostalWhereInput[]
    OR?: CodigoPostalWhereInput[]
    NOT?: CodigoPostalWhereInput | CodigoPostalWhereInput[]
    id_municipio?: IntFilter<"CodigoPostal"> | number
    municipio?: XOR<MunicipioRelationFilter, MunicipioWhereInput>
    colonias?: ColoniaListRelationFilter
  }, "id_codigo_postal" | "codigo_postal">

  export type CodigoPostalOrderByWithAggregationInput = {
    id_codigo_postal?: SortOrder
    id_municipio?: SortOrder
    codigo_postal?: SortOrder
    _count?: CodigoPostalCountOrderByAggregateInput
    _avg?: CodigoPostalAvgOrderByAggregateInput
    _max?: CodigoPostalMaxOrderByAggregateInput
    _min?: CodigoPostalMinOrderByAggregateInput
    _sum?: CodigoPostalSumOrderByAggregateInput
  }

  export type CodigoPostalScalarWhereWithAggregatesInput = {
    AND?: CodigoPostalScalarWhereWithAggregatesInput | CodigoPostalScalarWhereWithAggregatesInput[]
    OR?: CodigoPostalScalarWhereWithAggregatesInput[]
    NOT?: CodigoPostalScalarWhereWithAggregatesInput | CodigoPostalScalarWhereWithAggregatesInput[]
    id_codigo_postal?: IntWithAggregatesFilter<"CodigoPostal"> | number
    id_municipio?: IntWithAggregatesFilter<"CodigoPostal"> | number
    codigo_postal?: StringWithAggregatesFilter<"CodigoPostal"> | string
  }

  export type ColoniaWhereInput = {
    AND?: ColoniaWhereInput | ColoniaWhereInput[]
    OR?: ColoniaWhereInput[]
    NOT?: ColoniaWhereInput | ColoniaWhereInput[]
    id_colonia?: IntFilter<"Colonia"> | number
    id_codigo_postal?: IntFilter<"Colonia"> | number
    nombre?: StringFilter<"Colonia"> | string
    codigoPostal?: XOR<CodigoPostalRelationFilter, CodigoPostalWhereInput>
  }

  export type ColoniaOrderByWithRelationInput = {
    id_colonia?: SortOrder
    id_codigo_postal?: SortOrder
    nombre?: SortOrder
    codigoPostal?: CodigoPostalOrderByWithRelationInput
  }

  export type ColoniaWhereUniqueInput = Prisma.AtLeast<{
    id_colonia?: number
    AND?: ColoniaWhereInput | ColoniaWhereInput[]
    OR?: ColoniaWhereInput[]
    NOT?: ColoniaWhereInput | ColoniaWhereInput[]
    id_codigo_postal?: IntFilter<"Colonia"> | number
    nombre?: StringFilter<"Colonia"> | string
    codigoPostal?: XOR<CodigoPostalRelationFilter, CodigoPostalWhereInput>
  }, "id_colonia">

  export type ColoniaOrderByWithAggregationInput = {
    id_colonia?: SortOrder
    id_codigo_postal?: SortOrder
    nombre?: SortOrder
    _count?: ColoniaCountOrderByAggregateInput
    _avg?: ColoniaAvgOrderByAggregateInput
    _max?: ColoniaMaxOrderByAggregateInput
    _min?: ColoniaMinOrderByAggregateInput
    _sum?: ColoniaSumOrderByAggregateInput
  }

  export type ColoniaScalarWhereWithAggregatesInput = {
    AND?: ColoniaScalarWhereWithAggregatesInput | ColoniaScalarWhereWithAggregatesInput[]
    OR?: ColoniaScalarWhereWithAggregatesInput[]
    NOT?: ColoniaScalarWhereWithAggregatesInput | ColoniaScalarWhereWithAggregatesInput[]
    id_colonia?: IntWithAggregatesFilter<"Colonia"> | number
    id_codigo_postal?: IntWithAggregatesFilter<"Colonia"> | number
    nombre?: StringWithAggregatesFilter<"Colonia"> | string
  }

  export type UsuarioWhereInput = {
    AND?: UsuarioWhereInput | UsuarioWhereInput[]
    OR?: UsuarioWhereInput[]
    NOT?: UsuarioWhereInput | UsuarioWhereInput[]
    id_usuario?: IntFilter<"Usuario"> | number
    nombre?: StringFilter<"Usuario"> | string
    email?: StringFilter<"Usuario"> | string
    password_hash?: StringFilter<"Usuario"> | string
    id_tipo_rol?: IntFilter<"Usuario"> | number
    activo?: BoolFilter<"Usuario"> | boolean
    fecha_creacion?: DateTimeFilter<"Usuario"> | Date | string
    tipoRol?: XOR<TipoRolRelationFilter, TipoRolWhereInput>
  }

  export type UsuarioOrderByWithRelationInput = {
    id_usuario?: SortOrder
    nombre?: SortOrder
    email?: SortOrder
    password_hash?: SortOrder
    id_tipo_rol?: SortOrder
    activo?: SortOrder
    fecha_creacion?: SortOrder
    tipoRol?: TipoRolOrderByWithRelationInput
  }

  export type UsuarioWhereUniqueInput = Prisma.AtLeast<{
    id_usuario?: number
    email?: string
    AND?: UsuarioWhereInput | UsuarioWhereInput[]
    OR?: UsuarioWhereInput[]
    NOT?: UsuarioWhereInput | UsuarioWhereInput[]
    nombre?: StringFilter<"Usuario"> | string
    password_hash?: StringFilter<"Usuario"> | string
    id_tipo_rol?: IntFilter<"Usuario"> | number
    activo?: BoolFilter<"Usuario"> | boolean
    fecha_creacion?: DateTimeFilter<"Usuario"> | Date | string
    tipoRol?: XOR<TipoRolRelationFilter, TipoRolWhereInput>
  }, "id_usuario" | "email">

  export type UsuarioOrderByWithAggregationInput = {
    id_usuario?: SortOrder
    nombre?: SortOrder
    email?: SortOrder
    password_hash?: SortOrder
    id_tipo_rol?: SortOrder
    activo?: SortOrder
    fecha_creacion?: SortOrder
    _count?: UsuarioCountOrderByAggregateInput
    _avg?: UsuarioAvgOrderByAggregateInput
    _max?: UsuarioMaxOrderByAggregateInput
    _min?: UsuarioMinOrderByAggregateInput
    _sum?: UsuarioSumOrderByAggregateInput
  }

  export type UsuarioScalarWhereWithAggregatesInput = {
    AND?: UsuarioScalarWhereWithAggregatesInput | UsuarioScalarWhereWithAggregatesInput[]
    OR?: UsuarioScalarWhereWithAggregatesInput[]
    NOT?: UsuarioScalarWhereWithAggregatesInput | UsuarioScalarWhereWithAggregatesInput[]
    id_usuario?: IntWithAggregatesFilter<"Usuario"> | number
    nombre?: StringWithAggregatesFilter<"Usuario"> | string
    email?: StringWithAggregatesFilter<"Usuario"> | string
    password_hash?: StringWithAggregatesFilter<"Usuario"> | string
    id_tipo_rol?: IntWithAggregatesFilter<"Usuario"> | number
    activo?: BoolWithAggregatesFilter<"Usuario"> | boolean
    fecha_creacion?: DateTimeWithAggregatesFilter<"Usuario"> | Date | string
  }

  export type TipoRolWhereInput = {
    AND?: TipoRolWhereInput | TipoRolWhereInput[]
    OR?: TipoRolWhereInput[]
    NOT?: TipoRolWhereInput | TipoRolWhereInput[]
    id_tipo_rol?: IntFilter<"TipoRol"> | number
    nombre_rol?: StringFilter<"TipoRol"> | string
    descripcion?: StringNullableFilter<"TipoRol"> | string | null
    usuarios?: UsuarioListRelationFilter
  }

  export type TipoRolOrderByWithRelationInput = {
    id_tipo_rol?: SortOrder
    nombre_rol?: SortOrder
    descripcion?: SortOrderInput | SortOrder
    usuarios?: UsuarioOrderByRelationAggregateInput
  }

  export type TipoRolWhereUniqueInput = Prisma.AtLeast<{
    id_tipo_rol?: number
    nombre_rol?: string
    AND?: TipoRolWhereInput | TipoRolWhereInput[]
    OR?: TipoRolWhereInput[]
    NOT?: TipoRolWhereInput | TipoRolWhereInput[]
    descripcion?: StringNullableFilter<"TipoRol"> | string | null
    usuarios?: UsuarioListRelationFilter
  }, "id_tipo_rol" | "nombre_rol">

  export type TipoRolOrderByWithAggregationInput = {
    id_tipo_rol?: SortOrder
    nombre_rol?: SortOrder
    descripcion?: SortOrderInput | SortOrder
    _count?: TipoRolCountOrderByAggregateInput
    _avg?: TipoRolAvgOrderByAggregateInput
    _max?: TipoRolMaxOrderByAggregateInput
    _min?: TipoRolMinOrderByAggregateInput
    _sum?: TipoRolSumOrderByAggregateInput
  }

  export type TipoRolScalarWhereWithAggregatesInput = {
    AND?: TipoRolScalarWhereWithAggregatesInput | TipoRolScalarWhereWithAggregatesInput[]
    OR?: TipoRolScalarWhereWithAggregatesInput[]
    NOT?: TipoRolScalarWhereWithAggregatesInput | TipoRolScalarWhereWithAggregatesInput[]
    id_tipo_rol?: IntWithAggregatesFilter<"TipoRol"> | number
    nombre_rol?: StringWithAggregatesFilter<"TipoRol"> | string
    descripcion?: StringNullableWithAggregatesFilter<"TipoRol"> | string | null
  }

  export type AlertaWhereInput = {
    AND?: AlertaWhereInput | AlertaWhereInput[]
    OR?: AlertaWhereInput[]
    NOT?: AlertaWhereInput | AlertaWhereInput[]
    id_alerta?: IntFilter<"Alerta"> | number
    id_sensor_instalado?: IntFilter<"Alerta"> | number
    tipo_alerta?: StringFilter<"Alerta"> | string
    mensaje?: StringFilter<"Alerta"> | string
    nivel?: EnumNivelAlertaFilter<"Alerta"> | $Enums.NivelAlerta
    fecha_generada?: DateTimeFilter<"Alerta"> | Date | string
    fecha_resuelta?: DateTimeNullableFilter<"Alerta"> | Date | string | null
    estado?: StringFilter<"Alerta"> | string
  }

  export type AlertaOrderByWithRelationInput = {
    id_alerta?: SortOrder
    id_sensor_instalado?: SortOrder
    tipo_alerta?: SortOrder
    mensaje?: SortOrder
    nivel?: SortOrder
    fecha_generada?: SortOrder
    fecha_resuelta?: SortOrderInput | SortOrder
    estado?: SortOrder
  }

  export type AlertaWhereUniqueInput = Prisma.AtLeast<{
    id_alerta?: number
    AND?: AlertaWhereInput | AlertaWhereInput[]
    OR?: AlertaWhereInput[]
    NOT?: AlertaWhereInput | AlertaWhereInput[]
    id_sensor_instalado?: IntFilter<"Alerta"> | number
    tipo_alerta?: StringFilter<"Alerta"> | string
    mensaje?: StringFilter<"Alerta"> | string
    nivel?: EnumNivelAlertaFilter<"Alerta"> | $Enums.NivelAlerta
    fecha_generada?: DateTimeFilter<"Alerta"> | Date | string
    fecha_resuelta?: DateTimeNullableFilter<"Alerta"> | Date | string | null
    estado?: StringFilter<"Alerta"> | string
  }, "id_alerta">

  export type AlertaOrderByWithAggregationInput = {
    id_alerta?: SortOrder
    id_sensor_instalado?: SortOrder
    tipo_alerta?: SortOrder
    mensaje?: SortOrder
    nivel?: SortOrder
    fecha_generada?: SortOrder
    fecha_resuelta?: SortOrderInput | SortOrder
    estado?: SortOrder
    _count?: AlertaCountOrderByAggregateInput
    _avg?: AlertaAvgOrderByAggregateInput
    _max?: AlertaMaxOrderByAggregateInput
    _min?: AlertaMinOrderByAggregateInput
    _sum?: AlertaSumOrderByAggregateInput
  }

  export type AlertaScalarWhereWithAggregatesInput = {
    AND?: AlertaScalarWhereWithAggregatesInput | AlertaScalarWhereWithAggregatesInput[]
    OR?: AlertaScalarWhereWithAggregatesInput[]
    NOT?: AlertaScalarWhereWithAggregatesInput | AlertaScalarWhereWithAggregatesInput[]
    id_alerta?: IntWithAggregatesFilter<"Alerta"> | number
    id_sensor_instalado?: IntWithAggregatesFilter<"Alerta"> | number
    tipo_alerta?: StringWithAggregatesFilter<"Alerta"> | string
    mensaje?: StringWithAggregatesFilter<"Alerta"> | string
    nivel?: EnumNivelAlertaWithAggregatesFilter<"Alerta"> | $Enums.NivelAlerta
    fecha_generada?: DateTimeWithAggregatesFilter<"Alerta"> | Date | string
    fecha_resuelta?: DateTimeNullableWithAggregatesFilter<"Alerta"> | Date | string | null
    estado?: StringWithAggregatesFilter<"Alerta"> | string
  }

  export type ParametroWhereInput = {
    AND?: ParametroWhereInput | ParametroWhereInput[]
    OR?: ParametroWhereInput[]
    NOT?: ParametroWhereInput | ParametroWhereInput[]
    id_parametro?: IntFilter<"Parametro"> | number
    nombre?: StringFilter<"Parametro"> | string
    unidad?: StringNullableFilter<"Parametro"> | string | null
    descripcion?: StringNullableFilter<"Parametro"> | string | null
    rango_min?: DecimalNullableFilter<"Parametro"> | Decimal | DecimalJsLike | number | string | null
    rango_max?: DecimalNullableFilter<"Parametro"> | Decimal | DecimalJsLike | number | string | null
    especieParametros?: EspecieParametroListRelationFilter
  }

  export type ParametroOrderByWithRelationInput = {
    id_parametro?: SortOrder
    nombre?: SortOrder
    unidad?: SortOrderInput | SortOrder
    descripcion?: SortOrderInput | SortOrder
    rango_min?: SortOrderInput | SortOrder
    rango_max?: SortOrderInput | SortOrder
    especieParametros?: EspecieParametroOrderByRelationAggregateInput
  }

  export type ParametroWhereUniqueInput = Prisma.AtLeast<{
    id_parametro?: number
    nombre?: string
    AND?: ParametroWhereInput | ParametroWhereInput[]
    OR?: ParametroWhereInput[]
    NOT?: ParametroWhereInput | ParametroWhereInput[]
    unidad?: StringNullableFilter<"Parametro"> | string | null
    descripcion?: StringNullableFilter<"Parametro"> | string | null
    rango_min?: DecimalNullableFilter<"Parametro"> | Decimal | DecimalJsLike | number | string | null
    rango_max?: DecimalNullableFilter<"Parametro"> | Decimal | DecimalJsLike | number | string | null
    especieParametros?: EspecieParametroListRelationFilter
  }, "id_parametro" | "nombre">

  export type ParametroOrderByWithAggregationInput = {
    id_parametro?: SortOrder
    nombre?: SortOrder
    unidad?: SortOrderInput | SortOrder
    descripcion?: SortOrderInput | SortOrder
    rango_min?: SortOrderInput | SortOrder
    rango_max?: SortOrderInput | SortOrder
    _count?: ParametroCountOrderByAggregateInput
    _avg?: ParametroAvgOrderByAggregateInput
    _max?: ParametroMaxOrderByAggregateInput
    _min?: ParametroMinOrderByAggregateInput
    _sum?: ParametroSumOrderByAggregateInput
  }

  export type ParametroScalarWhereWithAggregatesInput = {
    AND?: ParametroScalarWhereWithAggregatesInput | ParametroScalarWhereWithAggregatesInput[]
    OR?: ParametroScalarWhereWithAggregatesInput[]
    NOT?: ParametroScalarWhereWithAggregatesInput | ParametroScalarWhereWithAggregatesInput[]
    id_parametro?: IntWithAggregatesFilter<"Parametro"> | number
    nombre?: StringWithAggregatesFilter<"Parametro"> | string
    unidad?: StringNullableWithAggregatesFilter<"Parametro"> | string | null
    descripcion?: StringNullableWithAggregatesFilter<"Parametro"> | string | null
    rango_min?: DecimalNullableWithAggregatesFilter<"Parametro"> | Decimal | DecimalJsLike | number | string | null
    rango_max?: DecimalNullableWithAggregatesFilter<"Parametro"> | Decimal | DecimalJsLike | number | string | null
  }

  export type CatalogoEspecieWhereInput = {
    AND?: CatalogoEspecieWhereInput | CatalogoEspecieWhereInput[]
    OR?: CatalogoEspecieWhereInput[]
    NOT?: CatalogoEspecieWhereInput | CatalogoEspecieWhereInput[]
    id_especie?: IntFilter<"CatalogoEspecie"> | number
    nombre_cientifico?: StringFilter<"CatalogoEspecie"> | string
    nombre_comun?: StringNullableFilter<"CatalogoEspecie"> | string | null
    tipo?: StringNullableFilter<"CatalogoEspecie"> | string | null
    descripcion?: StringNullableFilter<"CatalogoEspecie"> | string | null
    especiesInstaladas?: EspecieInstaladaListRelationFilter
  }

  export type CatalogoEspecieOrderByWithRelationInput = {
    id_especie?: SortOrder
    nombre_cientifico?: SortOrder
    nombre_comun?: SortOrderInput | SortOrder
    tipo?: SortOrderInput | SortOrder
    descripcion?: SortOrderInput | SortOrder
    especiesInstaladas?: EspecieInstaladaOrderByRelationAggregateInput
  }

  export type CatalogoEspecieWhereUniqueInput = Prisma.AtLeast<{
    id_especie?: number
    nombre_cientifico?: string
    AND?: CatalogoEspecieWhereInput | CatalogoEspecieWhereInput[]
    OR?: CatalogoEspecieWhereInput[]
    NOT?: CatalogoEspecieWhereInput | CatalogoEspecieWhereInput[]
    nombre_comun?: StringNullableFilter<"CatalogoEspecie"> | string | null
    tipo?: StringNullableFilter<"CatalogoEspecie"> | string | null
    descripcion?: StringNullableFilter<"CatalogoEspecie"> | string | null
    especiesInstaladas?: EspecieInstaladaListRelationFilter
  }, "id_especie" | "nombre_cientifico">

  export type CatalogoEspecieOrderByWithAggregationInput = {
    id_especie?: SortOrder
    nombre_cientifico?: SortOrder
    nombre_comun?: SortOrderInput | SortOrder
    tipo?: SortOrderInput | SortOrder
    descripcion?: SortOrderInput | SortOrder
    _count?: CatalogoEspecieCountOrderByAggregateInput
    _avg?: CatalogoEspecieAvgOrderByAggregateInput
    _max?: CatalogoEspecieMaxOrderByAggregateInput
    _min?: CatalogoEspecieMinOrderByAggregateInput
    _sum?: CatalogoEspecieSumOrderByAggregateInput
  }

  export type CatalogoEspecieScalarWhereWithAggregatesInput = {
    AND?: CatalogoEspecieScalarWhereWithAggregatesInput | CatalogoEspecieScalarWhereWithAggregatesInput[]
    OR?: CatalogoEspecieScalarWhereWithAggregatesInput[]
    NOT?: CatalogoEspecieScalarWhereWithAggregatesInput | CatalogoEspecieScalarWhereWithAggregatesInput[]
    id_especie?: IntWithAggregatesFilter<"CatalogoEspecie"> | number
    nombre_cientifico?: StringWithAggregatesFilter<"CatalogoEspecie"> | string
    nombre_comun?: StringNullableWithAggregatesFilter<"CatalogoEspecie"> | string | null
    tipo?: StringNullableWithAggregatesFilter<"CatalogoEspecie"> | string | null
    descripcion?: StringNullableWithAggregatesFilter<"CatalogoEspecie"> | string | null
  }

  export type EspecieInstaladaWhereInput = {
    AND?: EspecieInstaladaWhereInput | EspecieInstaladaWhereInput[]
    OR?: EspecieInstaladaWhereInput[]
    NOT?: EspecieInstaladaWhereInput | EspecieInstaladaWhereInput[]
    id_especie_instalada?: IntFilter<"EspecieInstalada"> | number
    id_instalacion?: IntFilter<"EspecieInstalada"> | number
    id_especie?: IntFilter<"EspecieInstalada"> | number
    cantidad_inicial?: IntNullableFilter<"EspecieInstalada"> | number | null
    fecha_introduccion?: DateTimeFilter<"EspecieInstalada"> | Date | string
    estado?: StringFilter<"EspecieInstalada"> | string
    catalogoEspecie?: XOR<CatalogoEspecieRelationFilter, CatalogoEspecieWhereInput>
    trackings?: EspecieTrackingListRelationFilter
  }

  export type EspecieInstaladaOrderByWithRelationInput = {
    id_especie_instalada?: SortOrder
    id_instalacion?: SortOrder
    id_especie?: SortOrder
    cantidad_inicial?: SortOrderInput | SortOrder
    fecha_introduccion?: SortOrder
    estado?: SortOrder
    catalogoEspecie?: CatalogoEspecieOrderByWithRelationInput
    trackings?: EspecieTrackingOrderByRelationAggregateInput
  }

  export type EspecieInstaladaWhereUniqueInput = Prisma.AtLeast<{
    id_especie_instalada?: number
    AND?: EspecieInstaladaWhereInput | EspecieInstaladaWhereInput[]
    OR?: EspecieInstaladaWhereInput[]
    NOT?: EspecieInstaladaWhereInput | EspecieInstaladaWhereInput[]
    id_instalacion?: IntFilter<"EspecieInstalada"> | number
    id_especie?: IntFilter<"EspecieInstalada"> | number
    cantidad_inicial?: IntNullableFilter<"EspecieInstalada"> | number | null
    fecha_introduccion?: DateTimeFilter<"EspecieInstalada"> | Date | string
    estado?: StringFilter<"EspecieInstalada"> | string
    catalogoEspecie?: XOR<CatalogoEspecieRelationFilter, CatalogoEspecieWhereInput>
    trackings?: EspecieTrackingListRelationFilter
  }, "id_especie_instalada">

  export type EspecieInstaladaOrderByWithAggregationInput = {
    id_especie_instalada?: SortOrder
    id_instalacion?: SortOrder
    id_especie?: SortOrder
    cantidad_inicial?: SortOrderInput | SortOrder
    fecha_introduccion?: SortOrder
    estado?: SortOrder
    _count?: EspecieInstaladaCountOrderByAggregateInput
    _avg?: EspecieInstaladaAvgOrderByAggregateInput
    _max?: EspecieInstaladaMaxOrderByAggregateInput
    _min?: EspecieInstaladaMinOrderByAggregateInput
    _sum?: EspecieInstaladaSumOrderByAggregateInput
  }

  export type EspecieInstaladaScalarWhereWithAggregatesInput = {
    AND?: EspecieInstaladaScalarWhereWithAggregatesInput | EspecieInstaladaScalarWhereWithAggregatesInput[]
    OR?: EspecieInstaladaScalarWhereWithAggregatesInput[]
    NOT?: EspecieInstaladaScalarWhereWithAggregatesInput | EspecieInstaladaScalarWhereWithAggregatesInput[]
    id_especie_instalada?: IntWithAggregatesFilter<"EspecieInstalada"> | number
    id_instalacion?: IntWithAggregatesFilter<"EspecieInstalada"> | number
    id_especie?: IntWithAggregatesFilter<"EspecieInstalada"> | number
    cantidad_inicial?: IntNullableWithAggregatesFilter<"EspecieInstalada"> | number | null
    fecha_introduccion?: DateTimeWithAggregatesFilter<"EspecieInstalada"> | Date | string
    estado?: StringWithAggregatesFilter<"EspecieInstalada"> | string
  }

  export type EspecieTrackingWhereInput = {
    AND?: EspecieTrackingWhereInput | EspecieTrackingWhereInput[]
    OR?: EspecieTrackingWhereInput[]
    NOT?: EspecieTrackingWhereInput | EspecieTrackingWhereInput[]
    id_tracking?: IntFilter<"EspecieTracking"> | number
    id_especie_instalada?: IntFilter<"EspecieTracking"> | number
    fecha_registro?: DateTimeFilter<"EspecieTracking"> | Date | string
    cantidad_actual?: IntFilter<"EspecieTracking"> | number
    observaciones?: StringNullableFilter<"EspecieTracking"> | string | null
    especieInstalada?: XOR<EspecieInstaladaRelationFilter, EspecieInstaladaWhereInput>
  }

  export type EspecieTrackingOrderByWithRelationInput = {
    id_tracking?: SortOrder
    id_especie_instalada?: SortOrder
    fecha_registro?: SortOrder
    cantidad_actual?: SortOrder
    observaciones?: SortOrderInput | SortOrder
    especieInstalada?: EspecieInstaladaOrderByWithRelationInput
  }

  export type EspecieTrackingWhereUniqueInput = Prisma.AtLeast<{
    id_tracking?: number
    AND?: EspecieTrackingWhereInput | EspecieTrackingWhereInput[]
    OR?: EspecieTrackingWhereInput[]
    NOT?: EspecieTrackingWhereInput | EspecieTrackingWhereInput[]
    id_especie_instalada?: IntFilter<"EspecieTracking"> | number
    fecha_registro?: DateTimeFilter<"EspecieTracking"> | Date | string
    cantidad_actual?: IntFilter<"EspecieTracking"> | number
    observaciones?: StringNullableFilter<"EspecieTracking"> | string | null
    especieInstalada?: XOR<EspecieInstaladaRelationFilter, EspecieInstaladaWhereInput>
  }, "id_tracking">

  export type EspecieTrackingOrderByWithAggregationInput = {
    id_tracking?: SortOrder
    id_especie_instalada?: SortOrder
    fecha_registro?: SortOrder
    cantidad_actual?: SortOrder
    observaciones?: SortOrderInput | SortOrder
    _count?: EspecieTrackingCountOrderByAggregateInput
    _avg?: EspecieTrackingAvgOrderByAggregateInput
    _max?: EspecieTrackingMaxOrderByAggregateInput
    _min?: EspecieTrackingMinOrderByAggregateInput
    _sum?: EspecieTrackingSumOrderByAggregateInput
  }

  export type EspecieTrackingScalarWhereWithAggregatesInput = {
    AND?: EspecieTrackingScalarWhereWithAggregatesInput | EspecieTrackingScalarWhereWithAggregatesInput[]
    OR?: EspecieTrackingScalarWhereWithAggregatesInput[]
    NOT?: EspecieTrackingScalarWhereWithAggregatesInput | EspecieTrackingScalarWhereWithAggregatesInput[]
    id_tracking?: IntWithAggregatesFilter<"EspecieTracking"> | number
    id_especie_instalada?: IntWithAggregatesFilter<"EspecieTracking"> | number
    fecha_registro?: DateTimeWithAggregatesFilter<"EspecieTracking"> | Date | string
    cantidad_actual?: IntWithAggregatesFilter<"EspecieTracking"> | number
    observaciones?: StringNullableWithAggregatesFilter<"EspecieTracking"> | string | null
  }

  export type EspecieParametroWhereInput = {
    AND?: EspecieParametroWhereInput | EspecieParametroWhereInput[]
    OR?: EspecieParametroWhereInput[]
    NOT?: EspecieParametroWhereInput | EspecieParametroWhereInput[]
    id_especie_parametro?: IntFilter<"EspecieParametro"> | number
    id_especie?: IntFilter<"EspecieParametro"> | number
    id_parametro?: IntFilter<"EspecieParametro"> | number
    valor_optimo_min?: DecimalNullableFilter<"EspecieParametro"> | Decimal | DecimalJsLike | number | string | null
    valor_optimo_max?: DecimalNullableFilter<"EspecieParametro"> | Decimal | DecimalJsLike | number | string | null
    parametro?: XOR<ParametroRelationFilter, ParametroWhereInput>
  }

  export type EspecieParametroOrderByWithRelationInput = {
    id_especie_parametro?: SortOrder
    id_especie?: SortOrder
    id_parametro?: SortOrder
    valor_optimo_min?: SortOrderInput | SortOrder
    valor_optimo_max?: SortOrderInput | SortOrder
    parametro?: ParametroOrderByWithRelationInput
  }

  export type EspecieParametroWhereUniqueInput = Prisma.AtLeast<{
    id_especie_parametro?: number
    id_especie_id_parametro?: EspecieParametroId_especieId_parametroCompoundUniqueInput
    AND?: EspecieParametroWhereInput | EspecieParametroWhereInput[]
    OR?: EspecieParametroWhereInput[]
    NOT?: EspecieParametroWhereInput | EspecieParametroWhereInput[]
    id_especie?: IntFilter<"EspecieParametro"> | number
    id_parametro?: IntFilter<"EspecieParametro"> | number
    valor_optimo_min?: DecimalNullableFilter<"EspecieParametro"> | Decimal | DecimalJsLike | number | string | null
    valor_optimo_max?: DecimalNullableFilter<"EspecieParametro"> | Decimal | DecimalJsLike | number | string | null
    parametro?: XOR<ParametroRelationFilter, ParametroWhereInput>
  }, "id_especie_parametro" | "id_especie_id_parametro">

  export type EspecieParametroOrderByWithAggregationInput = {
    id_especie_parametro?: SortOrder
    id_especie?: SortOrder
    id_parametro?: SortOrder
    valor_optimo_min?: SortOrderInput | SortOrder
    valor_optimo_max?: SortOrderInput | SortOrder
    _count?: EspecieParametroCountOrderByAggregateInput
    _avg?: EspecieParametroAvgOrderByAggregateInput
    _max?: EspecieParametroMaxOrderByAggregateInput
    _min?: EspecieParametroMinOrderByAggregateInput
    _sum?: EspecieParametroSumOrderByAggregateInput
  }

  export type EspecieParametroScalarWhereWithAggregatesInput = {
    AND?: EspecieParametroScalarWhereWithAggregatesInput | EspecieParametroScalarWhereWithAggregatesInput[]
    OR?: EspecieParametroScalarWhereWithAggregatesInput[]
    NOT?: EspecieParametroScalarWhereWithAggregatesInput | EspecieParametroScalarWhereWithAggregatesInput[]
    id_especie_parametro?: IntWithAggregatesFilter<"EspecieParametro"> | number
    id_especie?: IntWithAggregatesFilter<"EspecieParametro"> | number
    id_parametro?: IntWithAggregatesFilter<"EspecieParametro"> | number
    valor_optimo_min?: DecimalNullableWithAggregatesFilter<"EspecieParametro"> | Decimal | DecimalJsLike | number | string | null
    valor_optimo_max?: DecimalNullableWithAggregatesFilter<"EspecieParametro"> | Decimal | DecimalJsLike | number | string | null
  }

  export type ProcesoWhereInput = {
    AND?: ProcesoWhereInput | ProcesoWhereInput[]
    OR?: ProcesoWhereInput[]
    NOT?: ProcesoWhereInput | ProcesoWhereInput[]
    id_proceso?: IntFilter<"Proceso"> | number
    id_instalacion?: IntFilter<"Proceso"> | number
    nombre_proceso?: StringFilter<"Proceso"> | string
    descripcion?: StringNullableFilter<"Proceso"> | string | null
    fecha_inicio?: DateTimeFilter<"Proceso"> | Date | string
    fecha_fin?: DateTimeNullableFilter<"Proceso"> | Date | string | null
    estado?: StringFilter<"Proceso"> | string
  }

  export type ProcesoOrderByWithRelationInput = {
    id_proceso?: SortOrder
    id_instalacion?: SortOrder
    nombre_proceso?: SortOrder
    descripcion?: SortOrderInput | SortOrder
    fecha_inicio?: SortOrder
    fecha_fin?: SortOrderInput | SortOrder
    estado?: SortOrder
  }

  export type ProcesoWhereUniqueInput = Prisma.AtLeast<{
    id_proceso?: number
    AND?: ProcesoWhereInput | ProcesoWhereInput[]
    OR?: ProcesoWhereInput[]
    NOT?: ProcesoWhereInput | ProcesoWhereInput[]
    id_instalacion?: IntFilter<"Proceso"> | number
    nombre_proceso?: StringFilter<"Proceso"> | string
    descripcion?: StringNullableFilter<"Proceso"> | string | null
    fecha_inicio?: DateTimeFilter<"Proceso"> | Date | string
    fecha_fin?: DateTimeNullableFilter<"Proceso"> | Date | string | null
    estado?: StringFilter<"Proceso"> | string
  }, "id_proceso">

  export type ProcesoOrderByWithAggregationInput = {
    id_proceso?: SortOrder
    id_instalacion?: SortOrder
    nombre_proceso?: SortOrder
    descripcion?: SortOrderInput | SortOrder
    fecha_inicio?: SortOrder
    fecha_fin?: SortOrderInput | SortOrder
    estado?: SortOrder
    _count?: ProcesoCountOrderByAggregateInput
    _avg?: ProcesoAvgOrderByAggregateInput
    _max?: ProcesoMaxOrderByAggregateInput
    _min?: ProcesoMinOrderByAggregateInput
    _sum?: ProcesoSumOrderByAggregateInput
  }

  export type ProcesoScalarWhereWithAggregatesInput = {
    AND?: ProcesoScalarWhereWithAggregatesInput | ProcesoScalarWhereWithAggregatesInput[]
    OR?: ProcesoScalarWhereWithAggregatesInput[]
    NOT?: ProcesoScalarWhereWithAggregatesInput | ProcesoScalarWhereWithAggregatesInput[]
    id_proceso?: IntWithAggregatesFilter<"Proceso"> | number
    id_instalacion?: IntWithAggregatesFilter<"Proceso"> | number
    nombre_proceso?: StringWithAggregatesFilter<"Proceso"> | string
    descripcion?: StringNullableWithAggregatesFilter<"Proceso"> | string | null
    fecha_inicio?: DateTimeWithAggregatesFilter<"Proceso"> | Date | string
    fecha_fin?: DateTimeNullableWithAggregatesFilter<"Proceso"> | Date | string | null
    estado?: StringWithAggregatesFilter<"Proceso"> | string
  }

  export type OrganizacionCreateInput = {
    nombre: string
    estado: string
    fecha_creacion?: Date | string
    sucursales?: OrganizacionSucursalCreateNestedManyWithoutOrganizacionInput
  }

  export type OrganizacionUncheckedCreateInput = {
    id_organizacion?: number
    nombre: string
    estado: string
    fecha_creacion?: Date | string
    sucursales?: OrganizacionSucursalUncheckedCreateNestedManyWithoutOrganizacionInput
  }

  export type OrganizacionUpdateInput = {
    nombre?: StringFieldUpdateOperationsInput | string
    estado?: StringFieldUpdateOperationsInput | string
    fecha_creacion?: DateTimeFieldUpdateOperationsInput | Date | string
    sucursales?: OrganizacionSucursalUpdateManyWithoutOrganizacionNestedInput
  }

  export type OrganizacionUncheckedUpdateInput = {
    id_organizacion?: IntFieldUpdateOperationsInput | number
    nombre?: StringFieldUpdateOperationsInput | string
    estado?: StringFieldUpdateOperationsInput | string
    fecha_creacion?: DateTimeFieldUpdateOperationsInput | Date | string
    sucursales?: OrganizacionSucursalUncheckedUpdateManyWithoutOrganizacionNestedInput
  }

  export type OrganizacionCreateManyInput = {
    id_organizacion?: number
    nombre: string
    estado: string
    fecha_creacion?: Date | string
  }

  export type OrganizacionUpdateManyMutationInput = {
    nombre?: StringFieldUpdateOperationsInput | string
    estado?: StringFieldUpdateOperationsInput | string
    fecha_creacion?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type OrganizacionUncheckedUpdateManyInput = {
    id_organizacion?: IntFieldUpdateOperationsInput | number
    nombre?: StringFieldUpdateOperationsInput | string
    estado?: StringFieldUpdateOperationsInput | string
    fecha_creacion?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type OrganizacionSucursalCreateInput = {
    nombre_sucursal: string
    estado: string
    fecha_creacion?: Date | string
    organizacion: OrganizacionCreateNestedOneWithoutSucursalesInput
    instalaciones?: InstalacionCreateNestedManyWithoutSucursalInput
  }

  export type OrganizacionSucursalUncheckedCreateInput = {
    id_organizacion_sucursal?: number
    id_organizacion: number
    nombre_sucursal: string
    estado: string
    fecha_creacion?: Date | string
    instalaciones?: InstalacionUncheckedCreateNestedManyWithoutSucursalInput
  }

  export type OrganizacionSucursalUpdateInput = {
    nombre_sucursal?: StringFieldUpdateOperationsInput | string
    estado?: StringFieldUpdateOperationsInput | string
    fecha_creacion?: DateTimeFieldUpdateOperationsInput | Date | string
    organizacion?: OrganizacionUpdateOneRequiredWithoutSucursalesNestedInput
    instalaciones?: InstalacionUpdateManyWithoutSucursalNestedInput
  }

  export type OrganizacionSucursalUncheckedUpdateInput = {
    id_organizacion_sucursal?: IntFieldUpdateOperationsInput | number
    id_organizacion?: IntFieldUpdateOperationsInput | number
    nombre_sucursal?: StringFieldUpdateOperationsInput | string
    estado?: StringFieldUpdateOperationsInput | string
    fecha_creacion?: DateTimeFieldUpdateOperationsInput | Date | string
    instalaciones?: InstalacionUncheckedUpdateManyWithoutSucursalNestedInput
  }

  export type OrganizacionSucursalCreateManyInput = {
    id_organizacion_sucursal?: number
    id_organizacion: number
    nombre_sucursal: string
    estado: string
    fecha_creacion?: Date | string
  }

  export type OrganizacionSucursalUpdateManyMutationInput = {
    nombre_sucursal?: StringFieldUpdateOperationsInput | string
    estado?: StringFieldUpdateOperationsInput | string
    fecha_creacion?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type OrganizacionSucursalUncheckedUpdateManyInput = {
    id_organizacion_sucursal?: IntFieldUpdateOperationsInput | number
    id_organizacion?: IntFieldUpdateOperationsInput | number
    nombre_sucursal?: StringFieldUpdateOperationsInput | string
    estado?: StringFieldUpdateOperationsInput | string
    fecha_creacion?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type InstalacionCreateInput = {
    nombre_instalacion: string
    fecha_creacion?: Date | string
    sucursal: OrganizacionSucursalCreateNestedOneWithoutInstalacionesInput
    sensores?: SensorInstaladoCreateNestedManyWithoutInstalacionInput
  }

  export type InstalacionUncheckedCreateInput = {
    id_instalacion?: number
    id_organizacion_sucursal: number
    nombre_instalacion: string
    fecha_creacion?: Date | string
    sensores?: SensorInstaladoUncheckedCreateNestedManyWithoutInstalacionInput
  }

  export type InstalacionUpdateInput = {
    nombre_instalacion?: StringFieldUpdateOperationsInput | string
    fecha_creacion?: DateTimeFieldUpdateOperationsInput | Date | string
    sucursal?: OrganizacionSucursalUpdateOneRequiredWithoutInstalacionesNestedInput
    sensores?: SensorInstaladoUpdateManyWithoutInstalacionNestedInput
  }

  export type InstalacionUncheckedUpdateInput = {
    id_instalacion?: IntFieldUpdateOperationsInput | number
    id_organizacion_sucursal?: IntFieldUpdateOperationsInput | number
    nombre_instalacion?: StringFieldUpdateOperationsInput | string
    fecha_creacion?: DateTimeFieldUpdateOperationsInput | Date | string
    sensores?: SensorInstaladoUncheckedUpdateManyWithoutInstalacionNestedInput
  }

  export type InstalacionCreateManyInput = {
    id_instalacion?: number
    id_organizacion_sucursal: number
    nombre_instalacion: string
    fecha_creacion?: Date | string
  }

  export type InstalacionUpdateManyMutationInput = {
    nombre_instalacion?: StringFieldUpdateOperationsInput | string
    fecha_creacion?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type InstalacionUncheckedUpdateManyInput = {
    id_instalacion?: IntFieldUpdateOperationsInput | number
    id_organizacion_sucursal?: IntFieldUpdateOperationsInput | number
    nombre_instalacion?: StringFieldUpdateOperationsInput | string
    fecha_creacion?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type CatalogoSensorCreateInput = {
    nombre: string
    unidad?: string | null
    tipo_medida?: $Enums.TipoMedida | null
    rango_min?: Decimal | DecimalJsLike | number | string | null
    rango_max?: Decimal | DecimalJsLike | number | string | null
    sensoresInstalados?: SensorInstaladoCreateNestedManyWithoutCatalogoInput
  }

  export type CatalogoSensorUncheckedCreateInput = {
    id_sensor?: number
    nombre: string
    unidad?: string | null
    tipo_medida?: $Enums.TipoMedida | null
    rango_min?: Decimal | DecimalJsLike | number | string | null
    rango_max?: Decimal | DecimalJsLike | number | string | null
    sensoresInstalados?: SensorInstaladoUncheckedCreateNestedManyWithoutCatalogoInput
  }

  export type CatalogoSensorUpdateInput = {
    nombre?: StringFieldUpdateOperationsInput | string
    unidad?: NullableStringFieldUpdateOperationsInput | string | null
    tipo_medida?: NullableEnumTipoMedidaFieldUpdateOperationsInput | $Enums.TipoMedida | null
    rango_min?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    rango_max?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    sensoresInstalados?: SensorInstaladoUpdateManyWithoutCatalogoNestedInput
  }

  export type CatalogoSensorUncheckedUpdateInput = {
    id_sensor?: IntFieldUpdateOperationsInput | number
    nombre?: StringFieldUpdateOperationsInput | string
    unidad?: NullableStringFieldUpdateOperationsInput | string | null
    tipo_medida?: NullableEnumTipoMedidaFieldUpdateOperationsInput | $Enums.TipoMedida | null
    rango_min?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    rango_max?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    sensoresInstalados?: SensorInstaladoUncheckedUpdateManyWithoutCatalogoNestedInput
  }

  export type CatalogoSensorCreateManyInput = {
    id_sensor?: number
    nombre: string
    unidad?: string | null
    tipo_medida?: $Enums.TipoMedida | null
    rango_min?: Decimal | DecimalJsLike | number | string | null
    rango_max?: Decimal | DecimalJsLike | number | string | null
  }

  export type CatalogoSensorUpdateManyMutationInput = {
    nombre?: StringFieldUpdateOperationsInput | string
    unidad?: NullableStringFieldUpdateOperationsInput | string | null
    tipo_medida?: NullableEnumTipoMedidaFieldUpdateOperationsInput | $Enums.TipoMedida | null
    rango_min?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    rango_max?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
  }

  export type CatalogoSensorUncheckedUpdateManyInput = {
    id_sensor?: IntFieldUpdateOperationsInput | number
    nombre?: StringFieldUpdateOperationsInput | string
    unidad?: NullableStringFieldUpdateOperationsInput | string | null
    tipo_medida?: NullableEnumTipoMedidaFieldUpdateOperationsInput | $Enums.TipoMedida | null
    rango_min?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    rango_max?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
  }

  export type SensorInstaladoCreateInput = {
    descripcion?: string | null
    fecha_instalada?: Date | string | null
    instalacion: InstalacionCreateNestedOneWithoutSensoresInput
    catalogo: CatalogoSensorCreateNestedOneWithoutSensoresInstaladosInput
    lecturas?: LecturaCreateNestedManyWithoutSensorInput
  }

  export type SensorInstaladoUncheckedCreateInput = {
    id_sensor_instalado?: number
    id_instalacion: number
    id_sensor: number
    descripcion?: string | null
    fecha_instalada?: Date | string | null
    lecturas?: LecturaUncheckedCreateNestedManyWithoutSensorInput
  }

  export type SensorInstaladoUpdateInput = {
    descripcion?: NullableStringFieldUpdateOperationsInput | string | null
    fecha_instalada?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    instalacion?: InstalacionUpdateOneRequiredWithoutSensoresNestedInput
    catalogo?: CatalogoSensorUpdateOneRequiredWithoutSensoresInstaladosNestedInput
    lecturas?: LecturaUpdateManyWithoutSensorNestedInput
  }

  export type SensorInstaladoUncheckedUpdateInput = {
    id_sensor_instalado?: IntFieldUpdateOperationsInput | number
    id_instalacion?: IntFieldUpdateOperationsInput | number
    id_sensor?: IntFieldUpdateOperationsInput | number
    descripcion?: NullableStringFieldUpdateOperationsInput | string | null
    fecha_instalada?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    lecturas?: LecturaUncheckedUpdateManyWithoutSensorNestedInput
  }

  export type SensorInstaladoCreateManyInput = {
    id_sensor_instalado?: number
    id_instalacion: number
    id_sensor: number
    descripcion?: string | null
    fecha_instalada?: Date | string | null
  }

  export type SensorInstaladoUpdateManyMutationInput = {
    descripcion?: NullableStringFieldUpdateOperationsInput | string | null
    fecha_instalada?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
  }

  export type SensorInstaladoUncheckedUpdateManyInput = {
    id_sensor_instalado?: IntFieldUpdateOperationsInput | number
    id_instalacion?: IntFieldUpdateOperationsInput | number
    id_sensor?: IntFieldUpdateOperationsInput | number
    descripcion?: NullableStringFieldUpdateOperationsInput | string | null
    fecha_instalada?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
  }

  export type LecturaCreateInput = {
    id_lectura?: bigint | number
    valor: Decimal | DecimalJsLike | number | string
    tomada_en: Date | string
    sensor: SensorInstaladoCreateNestedOneWithoutLecturasInput
  }

  export type LecturaUncheckedCreateInput = {
    id_lectura?: bigint | number
    id_sensor_instalado: number
    valor: Decimal | DecimalJsLike | number | string
    tomada_en: Date | string
  }

  export type LecturaUpdateInput = {
    id_lectura?: BigIntFieldUpdateOperationsInput | bigint | number
    valor?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    tomada_en?: DateTimeFieldUpdateOperationsInput | Date | string
    sensor?: SensorInstaladoUpdateOneRequiredWithoutLecturasNestedInput
  }

  export type LecturaUncheckedUpdateInput = {
    id_lectura?: BigIntFieldUpdateOperationsInput | bigint | number
    id_sensor_instalado?: IntFieldUpdateOperationsInput | number
    valor?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    tomada_en?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type LecturaCreateManyInput = {
    id_lectura?: bigint | number
    id_sensor_instalado: number
    valor: Decimal | DecimalJsLike | number | string
    tomada_en: Date | string
  }

  export type LecturaUpdateManyMutationInput = {
    id_lectura?: BigIntFieldUpdateOperationsInput | bigint | number
    valor?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    tomada_en?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type LecturaUncheckedUpdateManyInput = {
    id_lectura?: BigIntFieldUpdateOperationsInput | bigint | number
    id_sensor_instalado?: IntFieldUpdateOperationsInput | number
    valor?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    tomada_en?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type ResumenLecturaHorariaCreateInput = {
    id_sensor_instalado: number
    fecha_hora: Date | string
    min_val: Decimal | DecimalJsLike | number | string
    max_val: Decimal | DecimalJsLike | number | string
    avg_val: Decimal | DecimalJsLike | number | string
    cnt: number
  }

  export type ResumenLecturaHorariaUncheckedCreateInput = {
    id_sensor_instalado: number
    fecha_hora: Date | string
    min_val: Decimal | DecimalJsLike | number | string
    max_val: Decimal | DecimalJsLike | number | string
    avg_val: Decimal | DecimalJsLike | number | string
    cnt: number
  }

  export type ResumenLecturaHorariaUpdateInput = {
    id_sensor_instalado?: IntFieldUpdateOperationsInput | number
    fecha_hora?: DateTimeFieldUpdateOperationsInput | Date | string
    min_val?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    max_val?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    avg_val?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    cnt?: IntFieldUpdateOperationsInput | number
  }

  export type ResumenLecturaHorariaUncheckedUpdateInput = {
    id_sensor_instalado?: IntFieldUpdateOperationsInput | number
    fecha_hora?: DateTimeFieldUpdateOperationsInput | Date | string
    min_val?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    max_val?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    avg_val?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    cnt?: IntFieldUpdateOperationsInput | number
  }

  export type ResumenLecturaHorariaCreateManyInput = {
    id_sensor_instalado: number
    fecha_hora: Date | string
    min_val: Decimal | DecimalJsLike | number | string
    max_val: Decimal | DecimalJsLike | number | string
    avg_val: Decimal | DecimalJsLike | number | string
    cnt: number
  }

  export type ResumenLecturaHorariaUpdateManyMutationInput = {
    id_sensor_instalado?: IntFieldUpdateOperationsInput | number
    fecha_hora?: DateTimeFieldUpdateOperationsInput | Date | string
    min_val?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    max_val?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    avg_val?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    cnt?: IntFieldUpdateOperationsInput | number
  }

  export type ResumenLecturaHorariaUncheckedUpdateManyInput = {
    id_sensor_instalado?: IntFieldUpdateOperationsInput | number
    fecha_hora?: DateTimeFieldUpdateOperationsInput | Date | string
    min_val?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    max_val?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    avg_val?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    cnt?: IntFieldUpdateOperationsInput | number
  }

  export type Promedio15minCreateInput = {
    id_sensor_instalado: number
    fecha: Date | string
    hora: Date | string
    promedio: Decimal | DecimalJsLike | number | string
    fecha_actualizacion: Date | string
  }

  export type Promedio15minUncheckedCreateInput = {
    id_sensor_instalado: number
    fecha: Date | string
    hora: Date | string
    promedio: Decimal | DecimalJsLike | number | string
    fecha_actualizacion: Date | string
  }

  export type Promedio15minUpdateInput = {
    id_sensor_instalado?: IntFieldUpdateOperationsInput | number
    fecha?: DateTimeFieldUpdateOperationsInput | Date | string
    hora?: DateTimeFieldUpdateOperationsInput | Date | string
    promedio?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    fecha_actualizacion?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type Promedio15minUncheckedUpdateInput = {
    id_sensor_instalado?: IntFieldUpdateOperationsInput | number
    fecha?: DateTimeFieldUpdateOperationsInput | Date | string
    hora?: DateTimeFieldUpdateOperationsInput | Date | string
    promedio?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    fecha_actualizacion?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type Promedio15minCreateManyInput = {
    id_sensor_instalado: number
    fecha: Date | string
    hora: Date | string
    promedio: Decimal | DecimalJsLike | number | string
    fecha_actualizacion: Date | string
  }

  export type Promedio15minUpdateManyMutationInput = {
    id_sensor_instalado?: IntFieldUpdateOperationsInput | number
    fecha?: DateTimeFieldUpdateOperationsInput | Date | string
    hora?: DateTimeFieldUpdateOperationsInput | Date | string
    promedio?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    fecha_actualizacion?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type Promedio15minUncheckedUpdateManyInput = {
    id_sensor_instalado?: IntFieldUpdateOperationsInput | number
    fecha?: DateTimeFieldUpdateOperationsInput | Date | string
    hora?: DateTimeFieldUpdateOperationsInput | Date | string
    promedio?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    fecha_actualizacion?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type EstadoCreateInput = {
    nombre: string
    codigo: string
    municipios?: MunicipioCreateNestedManyWithoutEstadoInput
  }

  export type EstadoUncheckedCreateInput = {
    id_estado?: number
    nombre: string
    codigo: string
    municipios?: MunicipioUncheckedCreateNestedManyWithoutEstadoInput
  }

  export type EstadoUpdateInput = {
    nombre?: StringFieldUpdateOperationsInput | string
    codigo?: StringFieldUpdateOperationsInput | string
    municipios?: MunicipioUpdateManyWithoutEstadoNestedInput
  }

  export type EstadoUncheckedUpdateInput = {
    id_estado?: IntFieldUpdateOperationsInput | number
    nombre?: StringFieldUpdateOperationsInput | string
    codigo?: StringFieldUpdateOperationsInput | string
    municipios?: MunicipioUncheckedUpdateManyWithoutEstadoNestedInput
  }

  export type EstadoCreateManyInput = {
    id_estado?: number
    nombre: string
    codigo: string
  }

  export type EstadoUpdateManyMutationInput = {
    nombre?: StringFieldUpdateOperationsInput | string
    codigo?: StringFieldUpdateOperationsInput | string
  }

  export type EstadoUncheckedUpdateManyInput = {
    id_estado?: IntFieldUpdateOperationsInput | number
    nombre?: StringFieldUpdateOperationsInput | string
    codigo?: StringFieldUpdateOperationsInput | string
  }

  export type MunicipioCreateInput = {
    nombre: string
    estado: EstadoCreateNestedOneWithoutMunicipiosInput
    codigosPostales?: CodigoPostalCreateNestedManyWithoutMunicipioInput
  }

  export type MunicipioUncheckedCreateInput = {
    id_municipio?: number
    id_estado: number
    nombre: string
    codigosPostales?: CodigoPostalUncheckedCreateNestedManyWithoutMunicipioInput
  }

  export type MunicipioUpdateInput = {
    nombre?: StringFieldUpdateOperationsInput | string
    estado?: EstadoUpdateOneRequiredWithoutMunicipiosNestedInput
    codigosPostales?: CodigoPostalUpdateManyWithoutMunicipioNestedInput
  }

  export type MunicipioUncheckedUpdateInput = {
    id_municipio?: IntFieldUpdateOperationsInput | number
    id_estado?: IntFieldUpdateOperationsInput | number
    nombre?: StringFieldUpdateOperationsInput | string
    codigosPostales?: CodigoPostalUncheckedUpdateManyWithoutMunicipioNestedInput
  }

  export type MunicipioCreateManyInput = {
    id_municipio?: number
    id_estado: number
    nombre: string
  }

  export type MunicipioUpdateManyMutationInput = {
    nombre?: StringFieldUpdateOperationsInput | string
  }

  export type MunicipioUncheckedUpdateManyInput = {
    id_municipio?: IntFieldUpdateOperationsInput | number
    id_estado?: IntFieldUpdateOperationsInput | number
    nombre?: StringFieldUpdateOperationsInput | string
  }

  export type CodigoPostalCreateInput = {
    codigo_postal: string
    municipio: MunicipioCreateNestedOneWithoutCodigosPostalesInput
    colonias?: ColoniaCreateNestedManyWithoutCodigoPostalInput
  }

  export type CodigoPostalUncheckedCreateInput = {
    id_codigo_postal?: number
    id_municipio: number
    codigo_postal: string
    colonias?: ColoniaUncheckedCreateNestedManyWithoutCodigoPostalInput
  }

  export type CodigoPostalUpdateInput = {
    codigo_postal?: StringFieldUpdateOperationsInput | string
    municipio?: MunicipioUpdateOneRequiredWithoutCodigosPostalesNestedInput
    colonias?: ColoniaUpdateManyWithoutCodigoPostalNestedInput
  }

  export type CodigoPostalUncheckedUpdateInput = {
    id_codigo_postal?: IntFieldUpdateOperationsInput | number
    id_municipio?: IntFieldUpdateOperationsInput | number
    codigo_postal?: StringFieldUpdateOperationsInput | string
    colonias?: ColoniaUncheckedUpdateManyWithoutCodigoPostalNestedInput
  }

  export type CodigoPostalCreateManyInput = {
    id_codigo_postal?: number
    id_municipio: number
    codigo_postal: string
  }

  export type CodigoPostalUpdateManyMutationInput = {
    codigo_postal?: StringFieldUpdateOperationsInput | string
  }

  export type CodigoPostalUncheckedUpdateManyInput = {
    id_codigo_postal?: IntFieldUpdateOperationsInput | number
    id_municipio?: IntFieldUpdateOperationsInput | number
    codigo_postal?: StringFieldUpdateOperationsInput | string
  }

  export type ColoniaCreateInput = {
    nombre: string
    codigoPostal: CodigoPostalCreateNestedOneWithoutColoniasInput
  }

  export type ColoniaUncheckedCreateInput = {
    id_colonia?: number
    id_codigo_postal: number
    nombre: string
  }

  export type ColoniaUpdateInput = {
    nombre?: StringFieldUpdateOperationsInput | string
    codigoPostal?: CodigoPostalUpdateOneRequiredWithoutColoniasNestedInput
  }

  export type ColoniaUncheckedUpdateInput = {
    id_colonia?: IntFieldUpdateOperationsInput | number
    id_codigo_postal?: IntFieldUpdateOperationsInput | number
    nombre?: StringFieldUpdateOperationsInput | string
  }

  export type ColoniaCreateManyInput = {
    id_colonia?: number
    id_codigo_postal: number
    nombre: string
  }

  export type ColoniaUpdateManyMutationInput = {
    nombre?: StringFieldUpdateOperationsInput | string
  }

  export type ColoniaUncheckedUpdateManyInput = {
    id_colonia?: IntFieldUpdateOperationsInput | number
    id_codigo_postal?: IntFieldUpdateOperationsInput | number
    nombre?: StringFieldUpdateOperationsInput | string
  }

  export type UsuarioCreateInput = {
    nombre: string
    email: string
    password_hash: string
    activo?: boolean
    fecha_creacion?: Date | string
    tipoRol: TipoRolCreateNestedOneWithoutUsuariosInput
  }

  export type UsuarioUncheckedCreateInput = {
    id_usuario?: number
    nombre: string
    email: string
    password_hash: string
    id_tipo_rol: number
    activo?: boolean
    fecha_creacion?: Date | string
  }

  export type UsuarioUpdateInput = {
    nombre?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    password_hash?: StringFieldUpdateOperationsInput | string
    activo?: BoolFieldUpdateOperationsInput | boolean
    fecha_creacion?: DateTimeFieldUpdateOperationsInput | Date | string
    tipoRol?: TipoRolUpdateOneRequiredWithoutUsuariosNestedInput
  }

  export type UsuarioUncheckedUpdateInput = {
    id_usuario?: IntFieldUpdateOperationsInput | number
    nombre?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    password_hash?: StringFieldUpdateOperationsInput | string
    id_tipo_rol?: IntFieldUpdateOperationsInput | number
    activo?: BoolFieldUpdateOperationsInput | boolean
    fecha_creacion?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type UsuarioCreateManyInput = {
    id_usuario?: number
    nombre: string
    email: string
    password_hash: string
    id_tipo_rol: number
    activo?: boolean
    fecha_creacion?: Date | string
  }

  export type UsuarioUpdateManyMutationInput = {
    nombre?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    password_hash?: StringFieldUpdateOperationsInput | string
    activo?: BoolFieldUpdateOperationsInput | boolean
    fecha_creacion?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type UsuarioUncheckedUpdateManyInput = {
    id_usuario?: IntFieldUpdateOperationsInput | number
    nombre?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    password_hash?: StringFieldUpdateOperationsInput | string
    id_tipo_rol?: IntFieldUpdateOperationsInput | number
    activo?: BoolFieldUpdateOperationsInput | boolean
    fecha_creacion?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type TipoRolCreateInput = {
    nombre_rol: string
    descripcion?: string | null
    usuarios?: UsuarioCreateNestedManyWithoutTipoRolInput
  }

  export type TipoRolUncheckedCreateInput = {
    id_tipo_rol?: number
    nombre_rol: string
    descripcion?: string | null
    usuarios?: UsuarioUncheckedCreateNestedManyWithoutTipoRolInput
  }

  export type TipoRolUpdateInput = {
    nombre_rol?: StringFieldUpdateOperationsInput | string
    descripcion?: NullableStringFieldUpdateOperationsInput | string | null
    usuarios?: UsuarioUpdateManyWithoutTipoRolNestedInput
  }

  export type TipoRolUncheckedUpdateInput = {
    id_tipo_rol?: IntFieldUpdateOperationsInput | number
    nombre_rol?: StringFieldUpdateOperationsInput | string
    descripcion?: NullableStringFieldUpdateOperationsInput | string | null
    usuarios?: UsuarioUncheckedUpdateManyWithoutTipoRolNestedInput
  }

  export type TipoRolCreateManyInput = {
    id_tipo_rol?: number
    nombre_rol: string
    descripcion?: string | null
  }

  export type TipoRolUpdateManyMutationInput = {
    nombre_rol?: StringFieldUpdateOperationsInput | string
    descripcion?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type TipoRolUncheckedUpdateManyInput = {
    id_tipo_rol?: IntFieldUpdateOperationsInput | number
    nombre_rol?: StringFieldUpdateOperationsInput | string
    descripcion?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type AlertaCreateInput = {
    id_sensor_instalado: number
    tipo_alerta: string
    mensaje: string
    nivel: $Enums.NivelAlerta
    fecha_generada?: Date | string
    fecha_resuelta?: Date | string | null
    estado?: string
  }

  export type AlertaUncheckedCreateInput = {
    id_alerta?: number
    id_sensor_instalado: number
    tipo_alerta: string
    mensaje: string
    nivel: $Enums.NivelAlerta
    fecha_generada?: Date | string
    fecha_resuelta?: Date | string | null
    estado?: string
  }

  export type AlertaUpdateInput = {
    id_sensor_instalado?: IntFieldUpdateOperationsInput | number
    tipo_alerta?: StringFieldUpdateOperationsInput | string
    mensaje?: StringFieldUpdateOperationsInput | string
    nivel?: EnumNivelAlertaFieldUpdateOperationsInput | $Enums.NivelAlerta
    fecha_generada?: DateTimeFieldUpdateOperationsInput | Date | string
    fecha_resuelta?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    estado?: StringFieldUpdateOperationsInput | string
  }

  export type AlertaUncheckedUpdateInput = {
    id_alerta?: IntFieldUpdateOperationsInput | number
    id_sensor_instalado?: IntFieldUpdateOperationsInput | number
    tipo_alerta?: StringFieldUpdateOperationsInput | string
    mensaje?: StringFieldUpdateOperationsInput | string
    nivel?: EnumNivelAlertaFieldUpdateOperationsInput | $Enums.NivelAlerta
    fecha_generada?: DateTimeFieldUpdateOperationsInput | Date | string
    fecha_resuelta?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    estado?: StringFieldUpdateOperationsInput | string
  }

  export type AlertaCreateManyInput = {
    id_alerta?: number
    id_sensor_instalado: number
    tipo_alerta: string
    mensaje: string
    nivel: $Enums.NivelAlerta
    fecha_generada?: Date | string
    fecha_resuelta?: Date | string | null
    estado?: string
  }

  export type AlertaUpdateManyMutationInput = {
    id_sensor_instalado?: IntFieldUpdateOperationsInput | number
    tipo_alerta?: StringFieldUpdateOperationsInput | string
    mensaje?: StringFieldUpdateOperationsInput | string
    nivel?: EnumNivelAlertaFieldUpdateOperationsInput | $Enums.NivelAlerta
    fecha_generada?: DateTimeFieldUpdateOperationsInput | Date | string
    fecha_resuelta?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    estado?: StringFieldUpdateOperationsInput | string
  }

  export type AlertaUncheckedUpdateManyInput = {
    id_alerta?: IntFieldUpdateOperationsInput | number
    id_sensor_instalado?: IntFieldUpdateOperationsInput | number
    tipo_alerta?: StringFieldUpdateOperationsInput | string
    mensaje?: StringFieldUpdateOperationsInput | string
    nivel?: EnumNivelAlertaFieldUpdateOperationsInput | $Enums.NivelAlerta
    fecha_generada?: DateTimeFieldUpdateOperationsInput | Date | string
    fecha_resuelta?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    estado?: StringFieldUpdateOperationsInput | string
  }

  export type ParametroCreateInput = {
    nombre: string
    unidad?: string | null
    descripcion?: string | null
    rango_min?: Decimal | DecimalJsLike | number | string | null
    rango_max?: Decimal | DecimalJsLike | number | string | null
    especieParametros?: EspecieParametroCreateNestedManyWithoutParametroInput
  }

  export type ParametroUncheckedCreateInput = {
    id_parametro?: number
    nombre: string
    unidad?: string | null
    descripcion?: string | null
    rango_min?: Decimal | DecimalJsLike | number | string | null
    rango_max?: Decimal | DecimalJsLike | number | string | null
    especieParametros?: EspecieParametroUncheckedCreateNestedManyWithoutParametroInput
  }

  export type ParametroUpdateInput = {
    nombre?: StringFieldUpdateOperationsInput | string
    unidad?: NullableStringFieldUpdateOperationsInput | string | null
    descripcion?: NullableStringFieldUpdateOperationsInput | string | null
    rango_min?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    rango_max?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    especieParametros?: EspecieParametroUpdateManyWithoutParametroNestedInput
  }

  export type ParametroUncheckedUpdateInput = {
    id_parametro?: IntFieldUpdateOperationsInput | number
    nombre?: StringFieldUpdateOperationsInput | string
    unidad?: NullableStringFieldUpdateOperationsInput | string | null
    descripcion?: NullableStringFieldUpdateOperationsInput | string | null
    rango_min?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    rango_max?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    especieParametros?: EspecieParametroUncheckedUpdateManyWithoutParametroNestedInput
  }

  export type ParametroCreateManyInput = {
    id_parametro?: number
    nombre: string
    unidad?: string | null
    descripcion?: string | null
    rango_min?: Decimal | DecimalJsLike | number | string | null
    rango_max?: Decimal | DecimalJsLike | number | string | null
  }

  export type ParametroUpdateManyMutationInput = {
    nombre?: StringFieldUpdateOperationsInput | string
    unidad?: NullableStringFieldUpdateOperationsInput | string | null
    descripcion?: NullableStringFieldUpdateOperationsInput | string | null
    rango_min?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    rango_max?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
  }

  export type ParametroUncheckedUpdateManyInput = {
    id_parametro?: IntFieldUpdateOperationsInput | number
    nombre?: StringFieldUpdateOperationsInput | string
    unidad?: NullableStringFieldUpdateOperationsInput | string | null
    descripcion?: NullableStringFieldUpdateOperationsInput | string | null
    rango_min?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    rango_max?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
  }

  export type CatalogoEspecieCreateInput = {
    nombre_cientifico: string
    nombre_comun?: string | null
    tipo?: string | null
    descripcion?: string | null
    especiesInstaladas?: EspecieInstaladaCreateNestedManyWithoutCatalogoEspecieInput
  }

  export type CatalogoEspecieUncheckedCreateInput = {
    id_especie?: number
    nombre_cientifico: string
    nombre_comun?: string | null
    tipo?: string | null
    descripcion?: string | null
    especiesInstaladas?: EspecieInstaladaUncheckedCreateNestedManyWithoutCatalogoEspecieInput
  }

  export type CatalogoEspecieUpdateInput = {
    nombre_cientifico?: StringFieldUpdateOperationsInput | string
    nombre_comun?: NullableStringFieldUpdateOperationsInput | string | null
    tipo?: NullableStringFieldUpdateOperationsInput | string | null
    descripcion?: NullableStringFieldUpdateOperationsInput | string | null
    especiesInstaladas?: EspecieInstaladaUpdateManyWithoutCatalogoEspecieNestedInput
  }

  export type CatalogoEspecieUncheckedUpdateInput = {
    id_especie?: IntFieldUpdateOperationsInput | number
    nombre_cientifico?: StringFieldUpdateOperationsInput | string
    nombre_comun?: NullableStringFieldUpdateOperationsInput | string | null
    tipo?: NullableStringFieldUpdateOperationsInput | string | null
    descripcion?: NullableStringFieldUpdateOperationsInput | string | null
    especiesInstaladas?: EspecieInstaladaUncheckedUpdateManyWithoutCatalogoEspecieNestedInput
  }

  export type CatalogoEspecieCreateManyInput = {
    id_especie?: number
    nombre_cientifico: string
    nombre_comun?: string | null
    tipo?: string | null
    descripcion?: string | null
  }

  export type CatalogoEspecieUpdateManyMutationInput = {
    nombre_cientifico?: StringFieldUpdateOperationsInput | string
    nombre_comun?: NullableStringFieldUpdateOperationsInput | string | null
    tipo?: NullableStringFieldUpdateOperationsInput | string | null
    descripcion?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type CatalogoEspecieUncheckedUpdateManyInput = {
    id_especie?: IntFieldUpdateOperationsInput | number
    nombre_cientifico?: StringFieldUpdateOperationsInput | string
    nombre_comun?: NullableStringFieldUpdateOperationsInput | string | null
    tipo?: NullableStringFieldUpdateOperationsInput | string | null
    descripcion?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type EspecieInstaladaCreateInput = {
    id_instalacion: number
    cantidad_inicial?: number | null
    fecha_introduccion: Date | string
    estado?: string
    catalogoEspecie: CatalogoEspecieCreateNestedOneWithoutEspeciesInstaladasInput
    trackings?: EspecieTrackingCreateNestedManyWithoutEspecieInstaladaInput
  }

  export type EspecieInstaladaUncheckedCreateInput = {
    id_especie_instalada?: number
    id_instalacion: number
    id_especie: number
    cantidad_inicial?: number | null
    fecha_introduccion: Date | string
    estado?: string
    trackings?: EspecieTrackingUncheckedCreateNestedManyWithoutEspecieInstaladaInput
  }

  export type EspecieInstaladaUpdateInput = {
    id_instalacion?: IntFieldUpdateOperationsInput | number
    cantidad_inicial?: NullableIntFieldUpdateOperationsInput | number | null
    fecha_introduccion?: DateTimeFieldUpdateOperationsInput | Date | string
    estado?: StringFieldUpdateOperationsInput | string
    catalogoEspecie?: CatalogoEspecieUpdateOneRequiredWithoutEspeciesInstaladasNestedInput
    trackings?: EspecieTrackingUpdateManyWithoutEspecieInstaladaNestedInput
  }

  export type EspecieInstaladaUncheckedUpdateInput = {
    id_especie_instalada?: IntFieldUpdateOperationsInput | number
    id_instalacion?: IntFieldUpdateOperationsInput | number
    id_especie?: IntFieldUpdateOperationsInput | number
    cantidad_inicial?: NullableIntFieldUpdateOperationsInput | number | null
    fecha_introduccion?: DateTimeFieldUpdateOperationsInput | Date | string
    estado?: StringFieldUpdateOperationsInput | string
    trackings?: EspecieTrackingUncheckedUpdateManyWithoutEspecieInstaladaNestedInput
  }

  export type EspecieInstaladaCreateManyInput = {
    id_especie_instalada?: number
    id_instalacion: number
    id_especie: number
    cantidad_inicial?: number | null
    fecha_introduccion: Date | string
    estado?: string
  }

  export type EspecieInstaladaUpdateManyMutationInput = {
    id_instalacion?: IntFieldUpdateOperationsInput | number
    cantidad_inicial?: NullableIntFieldUpdateOperationsInput | number | null
    fecha_introduccion?: DateTimeFieldUpdateOperationsInput | Date | string
    estado?: StringFieldUpdateOperationsInput | string
  }

  export type EspecieInstaladaUncheckedUpdateManyInput = {
    id_especie_instalada?: IntFieldUpdateOperationsInput | number
    id_instalacion?: IntFieldUpdateOperationsInput | number
    id_especie?: IntFieldUpdateOperationsInput | number
    cantidad_inicial?: NullableIntFieldUpdateOperationsInput | number | null
    fecha_introduccion?: DateTimeFieldUpdateOperationsInput | Date | string
    estado?: StringFieldUpdateOperationsInput | string
  }

  export type EspecieTrackingCreateInput = {
    fecha_registro?: Date | string
    cantidad_actual: number
    observaciones?: string | null
    especieInstalada: EspecieInstaladaCreateNestedOneWithoutTrackingsInput
  }

  export type EspecieTrackingUncheckedCreateInput = {
    id_tracking?: number
    id_especie_instalada: number
    fecha_registro?: Date | string
    cantidad_actual: number
    observaciones?: string | null
  }

  export type EspecieTrackingUpdateInput = {
    fecha_registro?: DateTimeFieldUpdateOperationsInput | Date | string
    cantidad_actual?: IntFieldUpdateOperationsInput | number
    observaciones?: NullableStringFieldUpdateOperationsInput | string | null
    especieInstalada?: EspecieInstaladaUpdateOneRequiredWithoutTrackingsNestedInput
  }

  export type EspecieTrackingUncheckedUpdateInput = {
    id_tracking?: IntFieldUpdateOperationsInput | number
    id_especie_instalada?: IntFieldUpdateOperationsInput | number
    fecha_registro?: DateTimeFieldUpdateOperationsInput | Date | string
    cantidad_actual?: IntFieldUpdateOperationsInput | number
    observaciones?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type EspecieTrackingCreateManyInput = {
    id_tracking?: number
    id_especie_instalada: number
    fecha_registro?: Date | string
    cantidad_actual: number
    observaciones?: string | null
  }

  export type EspecieTrackingUpdateManyMutationInput = {
    fecha_registro?: DateTimeFieldUpdateOperationsInput | Date | string
    cantidad_actual?: IntFieldUpdateOperationsInput | number
    observaciones?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type EspecieTrackingUncheckedUpdateManyInput = {
    id_tracking?: IntFieldUpdateOperationsInput | number
    id_especie_instalada?: IntFieldUpdateOperationsInput | number
    fecha_registro?: DateTimeFieldUpdateOperationsInput | Date | string
    cantidad_actual?: IntFieldUpdateOperationsInput | number
    observaciones?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type EspecieParametroCreateInput = {
    id_especie: number
    valor_optimo_min?: Decimal | DecimalJsLike | number | string | null
    valor_optimo_max?: Decimal | DecimalJsLike | number | string | null
    parametro: ParametroCreateNestedOneWithoutEspecieParametrosInput
  }

  export type EspecieParametroUncheckedCreateInput = {
    id_especie_parametro?: number
    id_especie: number
    id_parametro: number
    valor_optimo_min?: Decimal | DecimalJsLike | number | string | null
    valor_optimo_max?: Decimal | DecimalJsLike | number | string | null
  }

  export type EspecieParametroUpdateInput = {
    id_especie?: IntFieldUpdateOperationsInput | number
    valor_optimo_min?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    valor_optimo_max?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    parametro?: ParametroUpdateOneRequiredWithoutEspecieParametrosNestedInput
  }

  export type EspecieParametroUncheckedUpdateInput = {
    id_especie_parametro?: IntFieldUpdateOperationsInput | number
    id_especie?: IntFieldUpdateOperationsInput | number
    id_parametro?: IntFieldUpdateOperationsInput | number
    valor_optimo_min?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    valor_optimo_max?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
  }

  export type EspecieParametroCreateManyInput = {
    id_especie_parametro?: number
    id_especie: number
    id_parametro: number
    valor_optimo_min?: Decimal | DecimalJsLike | number | string | null
    valor_optimo_max?: Decimal | DecimalJsLike | number | string | null
  }

  export type EspecieParametroUpdateManyMutationInput = {
    id_especie?: IntFieldUpdateOperationsInput | number
    valor_optimo_min?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    valor_optimo_max?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
  }

  export type EspecieParametroUncheckedUpdateManyInput = {
    id_especie_parametro?: IntFieldUpdateOperationsInput | number
    id_especie?: IntFieldUpdateOperationsInput | number
    id_parametro?: IntFieldUpdateOperationsInput | number
    valor_optimo_min?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    valor_optimo_max?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
  }

  export type ProcesoCreateInput = {
    id_instalacion: number
    nombre_proceso: string
    descripcion?: string | null
    fecha_inicio: Date | string
    fecha_fin?: Date | string | null
    estado?: string
  }

  export type ProcesoUncheckedCreateInput = {
    id_proceso?: number
    id_instalacion: number
    nombre_proceso: string
    descripcion?: string | null
    fecha_inicio: Date | string
    fecha_fin?: Date | string | null
    estado?: string
  }

  export type ProcesoUpdateInput = {
    id_instalacion?: IntFieldUpdateOperationsInput | number
    nombre_proceso?: StringFieldUpdateOperationsInput | string
    descripcion?: NullableStringFieldUpdateOperationsInput | string | null
    fecha_inicio?: DateTimeFieldUpdateOperationsInput | Date | string
    fecha_fin?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    estado?: StringFieldUpdateOperationsInput | string
  }

  export type ProcesoUncheckedUpdateInput = {
    id_proceso?: IntFieldUpdateOperationsInput | number
    id_instalacion?: IntFieldUpdateOperationsInput | number
    nombre_proceso?: StringFieldUpdateOperationsInput | string
    descripcion?: NullableStringFieldUpdateOperationsInput | string | null
    fecha_inicio?: DateTimeFieldUpdateOperationsInput | Date | string
    fecha_fin?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    estado?: StringFieldUpdateOperationsInput | string
  }

  export type ProcesoCreateManyInput = {
    id_proceso?: number
    id_instalacion: number
    nombre_proceso: string
    descripcion?: string | null
    fecha_inicio: Date | string
    fecha_fin?: Date | string | null
    estado?: string
  }

  export type ProcesoUpdateManyMutationInput = {
    id_instalacion?: IntFieldUpdateOperationsInput | number
    nombre_proceso?: StringFieldUpdateOperationsInput | string
    descripcion?: NullableStringFieldUpdateOperationsInput | string | null
    fecha_inicio?: DateTimeFieldUpdateOperationsInput | Date | string
    fecha_fin?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    estado?: StringFieldUpdateOperationsInput | string
  }

  export type ProcesoUncheckedUpdateManyInput = {
    id_proceso?: IntFieldUpdateOperationsInput | number
    id_instalacion?: IntFieldUpdateOperationsInput | number
    nombre_proceso?: StringFieldUpdateOperationsInput | string
    descripcion?: NullableStringFieldUpdateOperationsInput | string | null
    fecha_inicio?: DateTimeFieldUpdateOperationsInput | Date | string
    fecha_fin?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    estado?: StringFieldUpdateOperationsInput | string
  }

  export type IntFilter<$PrismaModel = never> = {
    equals?: number | IntFieldRefInput<$PrismaModel>
    in?: number[]
    notIn?: number[]
    lt?: number | IntFieldRefInput<$PrismaModel>
    lte?: number | IntFieldRefInput<$PrismaModel>
    gt?: number | IntFieldRefInput<$PrismaModel>
    gte?: number | IntFieldRefInput<$PrismaModel>
    not?: NestedIntFilter<$PrismaModel> | number
  }

  export type StringFilter<$PrismaModel = never> = {
    equals?: string | StringFieldRefInput<$PrismaModel>
    in?: string[]
    notIn?: string[]
    lt?: string | StringFieldRefInput<$PrismaModel>
    lte?: string | StringFieldRefInput<$PrismaModel>
    gt?: string | StringFieldRefInput<$PrismaModel>
    gte?: string | StringFieldRefInput<$PrismaModel>
    contains?: string | StringFieldRefInput<$PrismaModel>
    startsWith?: string | StringFieldRefInput<$PrismaModel>
    endsWith?: string | StringFieldRefInput<$PrismaModel>
    not?: NestedStringFilter<$PrismaModel> | string
  }

  export type DateTimeFilter<$PrismaModel = never> = {
    equals?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    in?: Date[] | string[]
    notIn?: Date[] | string[]
    lt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    lte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    not?: NestedDateTimeFilter<$PrismaModel> | Date | string
  }

  export type OrganizacionSucursalListRelationFilter = {
    every?: OrganizacionSucursalWhereInput
    some?: OrganizacionSucursalWhereInput
    none?: OrganizacionSucursalWhereInput
  }

  export type OrganizacionSucursalOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type OrganizacionCountOrderByAggregateInput = {
    id_organizacion?: SortOrder
    nombre?: SortOrder
    estado?: SortOrder
    fecha_creacion?: SortOrder
  }

  export type OrganizacionAvgOrderByAggregateInput = {
    id_organizacion?: SortOrder
  }

  export type OrganizacionMaxOrderByAggregateInput = {
    id_organizacion?: SortOrder
    nombre?: SortOrder
    estado?: SortOrder
    fecha_creacion?: SortOrder
  }

  export type OrganizacionMinOrderByAggregateInput = {
    id_organizacion?: SortOrder
    nombre?: SortOrder
    estado?: SortOrder
    fecha_creacion?: SortOrder
  }

  export type OrganizacionSumOrderByAggregateInput = {
    id_organizacion?: SortOrder
  }

  export type IntWithAggregatesFilter<$PrismaModel = never> = {
    equals?: number | IntFieldRefInput<$PrismaModel>
    in?: number[]
    notIn?: number[]
    lt?: number | IntFieldRefInput<$PrismaModel>
    lte?: number | IntFieldRefInput<$PrismaModel>
    gt?: number | IntFieldRefInput<$PrismaModel>
    gte?: number | IntFieldRefInput<$PrismaModel>
    not?: NestedIntWithAggregatesFilter<$PrismaModel> | number
    _count?: NestedIntFilter<$PrismaModel>
    _avg?: NestedFloatFilter<$PrismaModel>
    _sum?: NestedIntFilter<$PrismaModel>
    _min?: NestedIntFilter<$PrismaModel>
    _max?: NestedIntFilter<$PrismaModel>
  }

  export type StringWithAggregatesFilter<$PrismaModel = never> = {
    equals?: string | StringFieldRefInput<$PrismaModel>
    in?: string[]
    notIn?: string[]
    lt?: string | StringFieldRefInput<$PrismaModel>
    lte?: string | StringFieldRefInput<$PrismaModel>
    gt?: string | StringFieldRefInput<$PrismaModel>
    gte?: string | StringFieldRefInput<$PrismaModel>
    contains?: string | StringFieldRefInput<$PrismaModel>
    startsWith?: string | StringFieldRefInput<$PrismaModel>
    endsWith?: string | StringFieldRefInput<$PrismaModel>
    not?: NestedStringWithAggregatesFilter<$PrismaModel> | string
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedStringFilter<$PrismaModel>
    _max?: NestedStringFilter<$PrismaModel>
  }

  export type DateTimeWithAggregatesFilter<$PrismaModel = never> = {
    equals?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    in?: Date[] | string[]
    notIn?: Date[] | string[]
    lt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    lte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    not?: NestedDateTimeWithAggregatesFilter<$PrismaModel> | Date | string
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedDateTimeFilter<$PrismaModel>
    _max?: NestedDateTimeFilter<$PrismaModel>
  }

  export type OrganizacionRelationFilter = {
    is?: OrganizacionWhereInput
    isNot?: OrganizacionWhereInput
  }

  export type InstalacionListRelationFilter = {
    every?: InstalacionWhereInput
    some?: InstalacionWhereInput
    none?: InstalacionWhereInput
  }

  export type InstalacionOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type OrganizacionSucursalCountOrderByAggregateInput = {
    id_organizacion_sucursal?: SortOrder
    id_organizacion?: SortOrder
    nombre_sucursal?: SortOrder
    estado?: SortOrder
    fecha_creacion?: SortOrder
  }

  export type OrganizacionSucursalAvgOrderByAggregateInput = {
    id_organizacion_sucursal?: SortOrder
    id_organizacion?: SortOrder
  }

  export type OrganizacionSucursalMaxOrderByAggregateInput = {
    id_organizacion_sucursal?: SortOrder
    id_organizacion?: SortOrder
    nombre_sucursal?: SortOrder
    estado?: SortOrder
    fecha_creacion?: SortOrder
  }

  export type OrganizacionSucursalMinOrderByAggregateInput = {
    id_organizacion_sucursal?: SortOrder
    id_organizacion?: SortOrder
    nombre_sucursal?: SortOrder
    estado?: SortOrder
    fecha_creacion?: SortOrder
  }

  export type OrganizacionSucursalSumOrderByAggregateInput = {
    id_organizacion_sucursal?: SortOrder
    id_organizacion?: SortOrder
  }

  export type OrganizacionSucursalRelationFilter = {
    is?: OrganizacionSucursalWhereInput
    isNot?: OrganizacionSucursalWhereInput
  }

  export type SensorInstaladoListRelationFilter = {
    every?: SensorInstaladoWhereInput
    some?: SensorInstaladoWhereInput
    none?: SensorInstaladoWhereInput
  }

  export type SensorInstaladoOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type InstalacionCountOrderByAggregateInput = {
    id_instalacion?: SortOrder
    id_organizacion_sucursal?: SortOrder
    nombre_instalacion?: SortOrder
    fecha_creacion?: SortOrder
  }

  export type InstalacionAvgOrderByAggregateInput = {
    id_instalacion?: SortOrder
    id_organizacion_sucursal?: SortOrder
  }

  export type InstalacionMaxOrderByAggregateInput = {
    id_instalacion?: SortOrder
    id_organizacion_sucursal?: SortOrder
    nombre_instalacion?: SortOrder
    fecha_creacion?: SortOrder
  }

  export type InstalacionMinOrderByAggregateInput = {
    id_instalacion?: SortOrder
    id_organizacion_sucursal?: SortOrder
    nombre_instalacion?: SortOrder
    fecha_creacion?: SortOrder
  }

  export type InstalacionSumOrderByAggregateInput = {
    id_instalacion?: SortOrder
    id_organizacion_sucursal?: SortOrder
  }

  export type StringNullableFilter<$PrismaModel = never> = {
    equals?: string | StringFieldRefInput<$PrismaModel> | null
    in?: string[] | null
    notIn?: string[] | null
    lt?: string | StringFieldRefInput<$PrismaModel>
    lte?: string | StringFieldRefInput<$PrismaModel>
    gt?: string | StringFieldRefInput<$PrismaModel>
    gte?: string | StringFieldRefInput<$PrismaModel>
    contains?: string | StringFieldRefInput<$PrismaModel>
    startsWith?: string | StringFieldRefInput<$PrismaModel>
    endsWith?: string | StringFieldRefInput<$PrismaModel>
    not?: NestedStringNullableFilter<$PrismaModel> | string | null
  }

  export type EnumTipoMedidaNullableFilter<$PrismaModel = never> = {
    equals?: $Enums.TipoMedida | EnumTipoMedidaFieldRefInput<$PrismaModel> | null
    in?: $Enums.TipoMedida[] | null
    notIn?: $Enums.TipoMedida[] | null
    not?: NestedEnumTipoMedidaNullableFilter<$PrismaModel> | $Enums.TipoMedida | null
  }

  export type DecimalNullableFilter<$PrismaModel = never> = {
    equals?: Decimal | DecimalJsLike | number | string | DecimalFieldRefInput<$PrismaModel> | null
    in?: Decimal[] | DecimalJsLike[] | number[] | string[] | null
    notIn?: Decimal[] | DecimalJsLike[] | number[] | string[] | null
    lt?: Decimal | DecimalJsLike | number | string | DecimalFieldRefInput<$PrismaModel>
    lte?: Decimal | DecimalJsLike | number | string | DecimalFieldRefInput<$PrismaModel>
    gt?: Decimal | DecimalJsLike | number | string | DecimalFieldRefInput<$PrismaModel>
    gte?: Decimal | DecimalJsLike | number | string | DecimalFieldRefInput<$PrismaModel>
    not?: NestedDecimalNullableFilter<$PrismaModel> | Decimal | DecimalJsLike | number | string | null
  }

  export type SortOrderInput = {
    sort: SortOrder
    nulls?: NullsOrder
  }

  export type CatalogoSensorCountOrderByAggregateInput = {
    id_sensor?: SortOrder
    nombre?: SortOrder
    unidad?: SortOrder
    tipo_medida?: SortOrder
    rango_min?: SortOrder
    rango_max?: SortOrder
  }

  export type CatalogoSensorAvgOrderByAggregateInput = {
    id_sensor?: SortOrder
    rango_min?: SortOrder
    rango_max?: SortOrder
  }

  export type CatalogoSensorMaxOrderByAggregateInput = {
    id_sensor?: SortOrder
    nombre?: SortOrder
    unidad?: SortOrder
    tipo_medida?: SortOrder
    rango_min?: SortOrder
    rango_max?: SortOrder
  }

  export type CatalogoSensorMinOrderByAggregateInput = {
    id_sensor?: SortOrder
    nombre?: SortOrder
    unidad?: SortOrder
    tipo_medida?: SortOrder
    rango_min?: SortOrder
    rango_max?: SortOrder
  }

  export type CatalogoSensorSumOrderByAggregateInput = {
    id_sensor?: SortOrder
    rango_min?: SortOrder
    rango_max?: SortOrder
  }

  export type StringNullableWithAggregatesFilter<$PrismaModel = never> = {
    equals?: string | StringFieldRefInput<$PrismaModel> | null
    in?: string[] | null
    notIn?: string[] | null
    lt?: string | StringFieldRefInput<$PrismaModel>
    lte?: string | StringFieldRefInput<$PrismaModel>
    gt?: string | StringFieldRefInput<$PrismaModel>
    gte?: string | StringFieldRefInput<$PrismaModel>
    contains?: string | StringFieldRefInput<$PrismaModel>
    startsWith?: string | StringFieldRefInput<$PrismaModel>
    endsWith?: string | StringFieldRefInput<$PrismaModel>
    not?: NestedStringNullableWithAggregatesFilter<$PrismaModel> | string | null
    _count?: NestedIntNullableFilter<$PrismaModel>
    _min?: NestedStringNullableFilter<$PrismaModel>
    _max?: NestedStringNullableFilter<$PrismaModel>
  }

  export type EnumTipoMedidaNullableWithAggregatesFilter<$PrismaModel = never> = {
    equals?: $Enums.TipoMedida | EnumTipoMedidaFieldRefInput<$PrismaModel> | null
    in?: $Enums.TipoMedida[] | null
    notIn?: $Enums.TipoMedida[] | null
    not?: NestedEnumTipoMedidaNullableWithAggregatesFilter<$PrismaModel> | $Enums.TipoMedida | null
    _count?: NestedIntNullableFilter<$PrismaModel>
    _min?: NestedEnumTipoMedidaNullableFilter<$PrismaModel>
    _max?: NestedEnumTipoMedidaNullableFilter<$PrismaModel>
  }

  export type DecimalNullableWithAggregatesFilter<$PrismaModel = never> = {
    equals?: Decimal | DecimalJsLike | number | string | DecimalFieldRefInput<$PrismaModel> | null
    in?: Decimal[] | DecimalJsLike[] | number[] | string[] | null
    notIn?: Decimal[] | DecimalJsLike[] | number[] | string[] | null
    lt?: Decimal | DecimalJsLike | number | string | DecimalFieldRefInput<$PrismaModel>
    lte?: Decimal | DecimalJsLike | number | string | DecimalFieldRefInput<$PrismaModel>
    gt?: Decimal | DecimalJsLike | number | string | DecimalFieldRefInput<$PrismaModel>
    gte?: Decimal | DecimalJsLike | number | string | DecimalFieldRefInput<$PrismaModel>
    not?: NestedDecimalNullableWithAggregatesFilter<$PrismaModel> | Decimal | DecimalJsLike | number | string | null
    _count?: NestedIntNullableFilter<$PrismaModel>
    _avg?: NestedDecimalNullableFilter<$PrismaModel>
    _sum?: NestedDecimalNullableFilter<$PrismaModel>
    _min?: NestedDecimalNullableFilter<$PrismaModel>
    _max?: NestedDecimalNullableFilter<$PrismaModel>
  }

  export type DateTimeNullableFilter<$PrismaModel = never> = {
    equals?: Date | string | DateTimeFieldRefInput<$PrismaModel> | null
    in?: Date[] | string[] | null
    notIn?: Date[] | string[] | null
    lt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    lte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    not?: NestedDateTimeNullableFilter<$PrismaModel> | Date | string | null
  }

  export type InstalacionRelationFilter = {
    is?: InstalacionWhereInput
    isNot?: InstalacionWhereInput
  }

  export type CatalogoSensorRelationFilter = {
    is?: CatalogoSensorWhereInput
    isNot?: CatalogoSensorWhereInput
  }

  export type LecturaListRelationFilter = {
    every?: LecturaWhereInput
    some?: LecturaWhereInput
    none?: LecturaWhereInput
  }

  export type LecturaOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type SensorInstaladoCountOrderByAggregateInput = {
    id_sensor_instalado?: SortOrder
    id_instalacion?: SortOrder
    id_sensor?: SortOrder
    descripcion?: SortOrder
    fecha_instalada?: SortOrder
  }

  export type SensorInstaladoAvgOrderByAggregateInput = {
    id_sensor_instalado?: SortOrder
    id_instalacion?: SortOrder
    id_sensor?: SortOrder
  }

  export type SensorInstaladoMaxOrderByAggregateInput = {
    id_sensor_instalado?: SortOrder
    id_instalacion?: SortOrder
    id_sensor?: SortOrder
    descripcion?: SortOrder
    fecha_instalada?: SortOrder
  }

  export type SensorInstaladoMinOrderByAggregateInput = {
    id_sensor_instalado?: SortOrder
    id_instalacion?: SortOrder
    id_sensor?: SortOrder
    descripcion?: SortOrder
    fecha_instalada?: SortOrder
  }

  export type SensorInstaladoSumOrderByAggregateInput = {
    id_sensor_instalado?: SortOrder
    id_instalacion?: SortOrder
    id_sensor?: SortOrder
  }

  export type DateTimeNullableWithAggregatesFilter<$PrismaModel = never> = {
    equals?: Date | string | DateTimeFieldRefInput<$PrismaModel> | null
    in?: Date[] | string[] | null
    notIn?: Date[] | string[] | null
    lt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    lte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    not?: NestedDateTimeNullableWithAggregatesFilter<$PrismaModel> | Date | string | null
    _count?: NestedIntNullableFilter<$PrismaModel>
    _min?: NestedDateTimeNullableFilter<$PrismaModel>
    _max?: NestedDateTimeNullableFilter<$PrismaModel>
  }

  export type BigIntFilter<$PrismaModel = never> = {
    equals?: bigint | number | BigIntFieldRefInput<$PrismaModel>
    in?: bigint[] | number[]
    notIn?: bigint[] | number[]
    lt?: bigint | number | BigIntFieldRefInput<$PrismaModel>
    lte?: bigint | number | BigIntFieldRefInput<$PrismaModel>
    gt?: bigint | number | BigIntFieldRefInput<$PrismaModel>
    gte?: bigint | number | BigIntFieldRefInput<$PrismaModel>
    not?: NestedBigIntFilter<$PrismaModel> | bigint | number
  }

  export type DecimalFilter<$PrismaModel = never> = {
    equals?: Decimal | DecimalJsLike | number | string | DecimalFieldRefInput<$PrismaModel>
    in?: Decimal[] | DecimalJsLike[] | number[] | string[]
    notIn?: Decimal[] | DecimalJsLike[] | number[] | string[]
    lt?: Decimal | DecimalJsLike | number | string | DecimalFieldRefInput<$PrismaModel>
    lte?: Decimal | DecimalJsLike | number | string | DecimalFieldRefInput<$PrismaModel>
    gt?: Decimal | DecimalJsLike | number | string | DecimalFieldRefInput<$PrismaModel>
    gte?: Decimal | DecimalJsLike | number | string | DecimalFieldRefInput<$PrismaModel>
    not?: NestedDecimalFilter<$PrismaModel> | Decimal | DecimalJsLike | number | string
  }

  export type SensorInstaladoRelationFilter = {
    is?: SensorInstaladoWhereInput
    isNot?: SensorInstaladoWhereInput
  }

  export type LecturaCountOrderByAggregateInput = {
    id_lectura?: SortOrder
    id_sensor_instalado?: SortOrder
    valor?: SortOrder
    tomada_en?: SortOrder
  }

  export type LecturaAvgOrderByAggregateInput = {
    id_lectura?: SortOrder
    id_sensor_instalado?: SortOrder
    valor?: SortOrder
  }

  export type LecturaMaxOrderByAggregateInput = {
    id_lectura?: SortOrder
    id_sensor_instalado?: SortOrder
    valor?: SortOrder
    tomada_en?: SortOrder
  }

  export type LecturaMinOrderByAggregateInput = {
    id_lectura?: SortOrder
    id_sensor_instalado?: SortOrder
    valor?: SortOrder
    tomada_en?: SortOrder
  }

  export type LecturaSumOrderByAggregateInput = {
    id_lectura?: SortOrder
    id_sensor_instalado?: SortOrder
    valor?: SortOrder
  }

  export type BigIntWithAggregatesFilter<$PrismaModel = never> = {
    equals?: bigint | number | BigIntFieldRefInput<$PrismaModel>
    in?: bigint[] | number[]
    notIn?: bigint[] | number[]
    lt?: bigint | number | BigIntFieldRefInput<$PrismaModel>
    lte?: bigint | number | BigIntFieldRefInput<$PrismaModel>
    gt?: bigint | number | BigIntFieldRefInput<$PrismaModel>
    gte?: bigint | number | BigIntFieldRefInput<$PrismaModel>
    not?: NestedBigIntWithAggregatesFilter<$PrismaModel> | bigint | number
    _count?: NestedIntFilter<$PrismaModel>
    _avg?: NestedFloatFilter<$PrismaModel>
    _sum?: NestedBigIntFilter<$PrismaModel>
    _min?: NestedBigIntFilter<$PrismaModel>
    _max?: NestedBigIntFilter<$PrismaModel>
  }

  export type DecimalWithAggregatesFilter<$PrismaModel = never> = {
    equals?: Decimal | DecimalJsLike | number | string | DecimalFieldRefInput<$PrismaModel>
    in?: Decimal[] | DecimalJsLike[] | number[] | string[]
    notIn?: Decimal[] | DecimalJsLike[] | number[] | string[]
    lt?: Decimal | DecimalJsLike | number | string | DecimalFieldRefInput<$PrismaModel>
    lte?: Decimal | DecimalJsLike | number | string | DecimalFieldRefInput<$PrismaModel>
    gt?: Decimal | DecimalJsLike | number | string | DecimalFieldRefInput<$PrismaModel>
    gte?: Decimal | DecimalJsLike | number | string | DecimalFieldRefInput<$PrismaModel>
    not?: NestedDecimalWithAggregatesFilter<$PrismaModel> | Decimal | DecimalJsLike | number | string
    _count?: NestedIntFilter<$PrismaModel>
    _avg?: NestedDecimalFilter<$PrismaModel>
    _sum?: NestedDecimalFilter<$PrismaModel>
    _min?: NestedDecimalFilter<$PrismaModel>
    _max?: NestedDecimalFilter<$PrismaModel>
  }

  export type ResumenLecturaHorariaId_sensor_instaladoFecha_horaCompoundUniqueInput = {
    id_sensor_instalado: number
    fecha_hora: Date | string
  }

  export type ResumenLecturaHorariaCountOrderByAggregateInput = {
    id_sensor_instalado?: SortOrder
    fecha_hora?: SortOrder
    min_val?: SortOrder
    max_val?: SortOrder
    avg_val?: SortOrder
    cnt?: SortOrder
  }

  export type ResumenLecturaHorariaAvgOrderByAggregateInput = {
    id_sensor_instalado?: SortOrder
    min_val?: SortOrder
    max_val?: SortOrder
    avg_val?: SortOrder
    cnt?: SortOrder
  }

  export type ResumenLecturaHorariaMaxOrderByAggregateInput = {
    id_sensor_instalado?: SortOrder
    fecha_hora?: SortOrder
    min_val?: SortOrder
    max_val?: SortOrder
    avg_val?: SortOrder
    cnt?: SortOrder
  }

  export type ResumenLecturaHorariaMinOrderByAggregateInput = {
    id_sensor_instalado?: SortOrder
    fecha_hora?: SortOrder
    min_val?: SortOrder
    max_val?: SortOrder
    avg_val?: SortOrder
    cnt?: SortOrder
  }

  export type ResumenLecturaHorariaSumOrderByAggregateInput = {
    id_sensor_instalado?: SortOrder
    min_val?: SortOrder
    max_val?: SortOrder
    avg_val?: SortOrder
    cnt?: SortOrder
  }

  export type Promedio15minId_sensor_instaladoFechaHoraCompoundUniqueInput = {
    id_sensor_instalado: number
    fecha: Date | string
    hora: Date | string
  }

  export type Promedio15minCountOrderByAggregateInput = {
    id_sensor_instalado?: SortOrder
    fecha?: SortOrder
    hora?: SortOrder
    promedio?: SortOrder
    fecha_actualizacion?: SortOrder
  }

  export type Promedio15minAvgOrderByAggregateInput = {
    id_sensor_instalado?: SortOrder
    promedio?: SortOrder
  }

  export type Promedio15minMaxOrderByAggregateInput = {
    id_sensor_instalado?: SortOrder
    fecha?: SortOrder
    hora?: SortOrder
    promedio?: SortOrder
    fecha_actualizacion?: SortOrder
  }

  export type Promedio15minMinOrderByAggregateInput = {
    id_sensor_instalado?: SortOrder
    fecha?: SortOrder
    hora?: SortOrder
    promedio?: SortOrder
    fecha_actualizacion?: SortOrder
  }

  export type Promedio15minSumOrderByAggregateInput = {
    id_sensor_instalado?: SortOrder
    promedio?: SortOrder
  }

  export type MunicipioListRelationFilter = {
    every?: MunicipioWhereInput
    some?: MunicipioWhereInput
    none?: MunicipioWhereInput
  }

  export type MunicipioOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type EstadoCountOrderByAggregateInput = {
    id_estado?: SortOrder
    nombre?: SortOrder
    codigo?: SortOrder
  }

  export type EstadoAvgOrderByAggregateInput = {
    id_estado?: SortOrder
  }

  export type EstadoMaxOrderByAggregateInput = {
    id_estado?: SortOrder
    nombre?: SortOrder
    codigo?: SortOrder
  }

  export type EstadoMinOrderByAggregateInput = {
    id_estado?: SortOrder
    nombre?: SortOrder
    codigo?: SortOrder
  }

  export type EstadoSumOrderByAggregateInput = {
    id_estado?: SortOrder
  }

  export type EstadoRelationFilter = {
    is?: EstadoWhereInput
    isNot?: EstadoWhereInput
  }

  export type CodigoPostalListRelationFilter = {
    every?: CodigoPostalWhereInput
    some?: CodigoPostalWhereInput
    none?: CodigoPostalWhereInput
  }

  export type CodigoPostalOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type MunicipioCountOrderByAggregateInput = {
    id_municipio?: SortOrder
    id_estado?: SortOrder
    nombre?: SortOrder
  }

  export type MunicipioAvgOrderByAggregateInput = {
    id_municipio?: SortOrder
    id_estado?: SortOrder
  }

  export type MunicipioMaxOrderByAggregateInput = {
    id_municipio?: SortOrder
    id_estado?: SortOrder
    nombre?: SortOrder
  }

  export type MunicipioMinOrderByAggregateInput = {
    id_municipio?: SortOrder
    id_estado?: SortOrder
    nombre?: SortOrder
  }

  export type MunicipioSumOrderByAggregateInput = {
    id_municipio?: SortOrder
    id_estado?: SortOrder
  }

  export type MunicipioRelationFilter = {
    is?: MunicipioWhereInput
    isNot?: MunicipioWhereInput
  }

  export type ColoniaListRelationFilter = {
    every?: ColoniaWhereInput
    some?: ColoniaWhereInput
    none?: ColoniaWhereInput
  }

  export type ColoniaOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type CodigoPostalCountOrderByAggregateInput = {
    id_codigo_postal?: SortOrder
    id_municipio?: SortOrder
    codigo_postal?: SortOrder
  }

  export type CodigoPostalAvgOrderByAggregateInput = {
    id_codigo_postal?: SortOrder
    id_municipio?: SortOrder
  }

  export type CodigoPostalMaxOrderByAggregateInput = {
    id_codigo_postal?: SortOrder
    id_municipio?: SortOrder
    codigo_postal?: SortOrder
  }

  export type CodigoPostalMinOrderByAggregateInput = {
    id_codigo_postal?: SortOrder
    id_municipio?: SortOrder
    codigo_postal?: SortOrder
  }

  export type CodigoPostalSumOrderByAggregateInput = {
    id_codigo_postal?: SortOrder
    id_municipio?: SortOrder
  }

  export type CodigoPostalRelationFilter = {
    is?: CodigoPostalWhereInput
    isNot?: CodigoPostalWhereInput
  }

  export type ColoniaCountOrderByAggregateInput = {
    id_colonia?: SortOrder
    id_codigo_postal?: SortOrder
    nombre?: SortOrder
  }

  export type ColoniaAvgOrderByAggregateInput = {
    id_colonia?: SortOrder
    id_codigo_postal?: SortOrder
  }

  export type ColoniaMaxOrderByAggregateInput = {
    id_colonia?: SortOrder
    id_codigo_postal?: SortOrder
    nombre?: SortOrder
  }

  export type ColoniaMinOrderByAggregateInput = {
    id_colonia?: SortOrder
    id_codigo_postal?: SortOrder
    nombre?: SortOrder
  }

  export type ColoniaSumOrderByAggregateInput = {
    id_colonia?: SortOrder
    id_codigo_postal?: SortOrder
  }

  export type BoolFilter<$PrismaModel = never> = {
    equals?: boolean | BooleanFieldRefInput<$PrismaModel>
    not?: NestedBoolFilter<$PrismaModel> | boolean
  }

  export type TipoRolRelationFilter = {
    is?: TipoRolWhereInput
    isNot?: TipoRolWhereInput
  }

  export type UsuarioCountOrderByAggregateInput = {
    id_usuario?: SortOrder
    nombre?: SortOrder
    email?: SortOrder
    password_hash?: SortOrder
    id_tipo_rol?: SortOrder
    activo?: SortOrder
    fecha_creacion?: SortOrder
  }

  export type UsuarioAvgOrderByAggregateInput = {
    id_usuario?: SortOrder
    id_tipo_rol?: SortOrder
  }

  export type UsuarioMaxOrderByAggregateInput = {
    id_usuario?: SortOrder
    nombre?: SortOrder
    email?: SortOrder
    password_hash?: SortOrder
    id_tipo_rol?: SortOrder
    activo?: SortOrder
    fecha_creacion?: SortOrder
  }

  export type UsuarioMinOrderByAggregateInput = {
    id_usuario?: SortOrder
    nombre?: SortOrder
    email?: SortOrder
    password_hash?: SortOrder
    id_tipo_rol?: SortOrder
    activo?: SortOrder
    fecha_creacion?: SortOrder
  }

  export type UsuarioSumOrderByAggregateInput = {
    id_usuario?: SortOrder
    id_tipo_rol?: SortOrder
  }

  export type BoolWithAggregatesFilter<$PrismaModel = never> = {
    equals?: boolean | BooleanFieldRefInput<$PrismaModel>
    not?: NestedBoolWithAggregatesFilter<$PrismaModel> | boolean
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedBoolFilter<$PrismaModel>
    _max?: NestedBoolFilter<$PrismaModel>
  }

  export type UsuarioListRelationFilter = {
    every?: UsuarioWhereInput
    some?: UsuarioWhereInput
    none?: UsuarioWhereInput
  }

  export type UsuarioOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type TipoRolCountOrderByAggregateInput = {
    id_tipo_rol?: SortOrder
    nombre_rol?: SortOrder
    descripcion?: SortOrder
  }

  export type TipoRolAvgOrderByAggregateInput = {
    id_tipo_rol?: SortOrder
  }

  export type TipoRolMaxOrderByAggregateInput = {
    id_tipo_rol?: SortOrder
    nombre_rol?: SortOrder
    descripcion?: SortOrder
  }

  export type TipoRolMinOrderByAggregateInput = {
    id_tipo_rol?: SortOrder
    nombre_rol?: SortOrder
    descripcion?: SortOrder
  }

  export type TipoRolSumOrderByAggregateInput = {
    id_tipo_rol?: SortOrder
  }

  export type EnumNivelAlertaFilter<$PrismaModel = never> = {
    equals?: $Enums.NivelAlerta | EnumNivelAlertaFieldRefInput<$PrismaModel>
    in?: $Enums.NivelAlerta[]
    notIn?: $Enums.NivelAlerta[]
    not?: NestedEnumNivelAlertaFilter<$PrismaModel> | $Enums.NivelAlerta
  }

  export type AlertaCountOrderByAggregateInput = {
    id_alerta?: SortOrder
    id_sensor_instalado?: SortOrder
    tipo_alerta?: SortOrder
    mensaje?: SortOrder
    nivel?: SortOrder
    fecha_generada?: SortOrder
    fecha_resuelta?: SortOrder
    estado?: SortOrder
  }

  export type AlertaAvgOrderByAggregateInput = {
    id_alerta?: SortOrder
    id_sensor_instalado?: SortOrder
  }

  export type AlertaMaxOrderByAggregateInput = {
    id_alerta?: SortOrder
    id_sensor_instalado?: SortOrder
    tipo_alerta?: SortOrder
    mensaje?: SortOrder
    nivel?: SortOrder
    fecha_generada?: SortOrder
    fecha_resuelta?: SortOrder
    estado?: SortOrder
  }

  export type AlertaMinOrderByAggregateInput = {
    id_alerta?: SortOrder
    id_sensor_instalado?: SortOrder
    tipo_alerta?: SortOrder
    mensaje?: SortOrder
    nivel?: SortOrder
    fecha_generada?: SortOrder
    fecha_resuelta?: SortOrder
    estado?: SortOrder
  }

  export type AlertaSumOrderByAggregateInput = {
    id_alerta?: SortOrder
    id_sensor_instalado?: SortOrder
  }

  export type EnumNivelAlertaWithAggregatesFilter<$PrismaModel = never> = {
    equals?: $Enums.NivelAlerta | EnumNivelAlertaFieldRefInput<$PrismaModel>
    in?: $Enums.NivelAlerta[]
    notIn?: $Enums.NivelAlerta[]
    not?: NestedEnumNivelAlertaWithAggregatesFilter<$PrismaModel> | $Enums.NivelAlerta
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedEnumNivelAlertaFilter<$PrismaModel>
    _max?: NestedEnumNivelAlertaFilter<$PrismaModel>
  }

  export type EspecieParametroListRelationFilter = {
    every?: EspecieParametroWhereInput
    some?: EspecieParametroWhereInput
    none?: EspecieParametroWhereInput
  }

  export type EspecieParametroOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type ParametroCountOrderByAggregateInput = {
    id_parametro?: SortOrder
    nombre?: SortOrder
    unidad?: SortOrder
    descripcion?: SortOrder
    rango_min?: SortOrder
    rango_max?: SortOrder
  }

  export type ParametroAvgOrderByAggregateInput = {
    id_parametro?: SortOrder
    rango_min?: SortOrder
    rango_max?: SortOrder
  }

  export type ParametroMaxOrderByAggregateInput = {
    id_parametro?: SortOrder
    nombre?: SortOrder
    unidad?: SortOrder
    descripcion?: SortOrder
    rango_min?: SortOrder
    rango_max?: SortOrder
  }

  export type ParametroMinOrderByAggregateInput = {
    id_parametro?: SortOrder
    nombre?: SortOrder
    unidad?: SortOrder
    descripcion?: SortOrder
    rango_min?: SortOrder
    rango_max?: SortOrder
  }

  export type ParametroSumOrderByAggregateInput = {
    id_parametro?: SortOrder
    rango_min?: SortOrder
    rango_max?: SortOrder
  }

  export type EspecieInstaladaListRelationFilter = {
    every?: EspecieInstaladaWhereInput
    some?: EspecieInstaladaWhereInput
    none?: EspecieInstaladaWhereInput
  }

  export type EspecieInstaladaOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type CatalogoEspecieCountOrderByAggregateInput = {
    id_especie?: SortOrder
    nombre_cientifico?: SortOrder
    nombre_comun?: SortOrder
    tipo?: SortOrder
    descripcion?: SortOrder
  }

  export type CatalogoEspecieAvgOrderByAggregateInput = {
    id_especie?: SortOrder
  }

  export type CatalogoEspecieMaxOrderByAggregateInput = {
    id_especie?: SortOrder
    nombre_cientifico?: SortOrder
    nombre_comun?: SortOrder
    tipo?: SortOrder
    descripcion?: SortOrder
  }

  export type CatalogoEspecieMinOrderByAggregateInput = {
    id_especie?: SortOrder
    nombre_cientifico?: SortOrder
    nombre_comun?: SortOrder
    tipo?: SortOrder
    descripcion?: SortOrder
  }

  export type CatalogoEspecieSumOrderByAggregateInput = {
    id_especie?: SortOrder
  }

  export type IntNullableFilter<$PrismaModel = never> = {
    equals?: number | IntFieldRefInput<$PrismaModel> | null
    in?: number[] | null
    notIn?: number[] | null
    lt?: number | IntFieldRefInput<$PrismaModel>
    lte?: number | IntFieldRefInput<$PrismaModel>
    gt?: number | IntFieldRefInput<$PrismaModel>
    gte?: number | IntFieldRefInput<$PrismaModel>
    not?: NestedIntNullableFilter<$PrismaModel> | number | null
  }

  export type CatalogoEspecieRelationFilter = {
    is?: CatalogoEspecieWhereInput
    isNot?: CatalogoEspecieWhereInput
  }

  export type EspecieTrackingListRelationFilter = {
    every?: EspecieTrackingWhereInput
    some?: EspecieTrackingWhereInput
    none?: EspecieTrackingWhereInput
  }

  export type EspecieTrackingOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type EspecieInstaladaCountOrderByAggregateInput = {
    id_especie_instalada?: SortOrder
    id_instalacion?: SortOrder
    id_especie?: SortOrder
    cantidad_inicial?: SortOrder
    fecha_introduccion?: SortOrder
    estado?: SortOrder
  }

  export type EspecieInstaladaAvgOrderByAggregateInput = {
    id_especie_instalada?: SortOrder
    id_instalacion?: SortOrder
    id_especie?: SortOrder
    cantidad_inicial?: SortOrder
  }

  export type EspecieInstaladaMaxOrderByAggregateInput = {
    id_especie_instalada?: SortOrder
    id_instalacion?: SortOrder
    id_especie?: SortOrder
    cantidad_inicial?: SortOrder
    fecha_introduccion?: SortOrder
    estado?: SortOrder
  }

  export type EspecieInstaladaMinOrderByAggregateInput = {
    id_especie_instalada?: SortOrder
    id_instalacion?: SortOrder
    id_especie?: SortOrder
    cantidad_inicial?: SortOrder
    fecha_introduccion?: SortOrder
    estado?: SortOrder
  }

  export type EspecieInstaladaSumOrderByAggregateInput = {
    id_especie_instalada?: SortOrder
    id_instalacion?: SortOrder
    id_especie?: SortOrder
    cantidad_inicial?: SortOrder
  }

  export type IntNullableWithAggregatesFilter<$PrismaModel = never> = {
    equals?: number | IntFieldRefInput<$PrismaModel> | null
    in?: number[] | null
    notIn?: number[] | null
    lt?: number | IntFieldRefInput<$PrismaModel>
    lte?: number | IntFieldRefInput<$PrismaModel>
    gt?: number | IntFieldRefInput<$PrismaModel>
    gte?: number | IntFieldRefInput<$PrismaModel>
    not?: NestedIntNullableWithAggregatesFilter<$PrismaModel> | number | null
    _count?: NestedIntNullableFilter<$PrismaModel>
    _avg?: NestedFloatNullableFilter<$PrismaModel>
    _sum?: NestedIntNullableFilter<$PrismaModel>
    _min?: NestedIntNullableFilter<$PrismaModel>
    _max?: NestedIntNullableFilter<$PrismaModel>
  }

  export type EspecieInstaladaRelationFilter = {
    is?: EspecieInstaladaWhereInput
    isNot?: EspecieInstaladaWhereInput
  }

  export type EspecieTrackingCountOrderByAggregateInput = {
    id_tracking?: SortOrder
    id_especie_instalada?: SortOrder
    fecha_registro?: SortOrder
    cantidad_actual?: SortOrder
    observaciones?: SortOrder
  }

  export type EspecieTrackingAvgOrderByAggregateInput = {
    id_tracking?: SortOrder
    id_especie_instalada?: SortOrder
    cantidad_actual?: SortOrder
  }

  export type EspecieTrackingMaxOrderByAggregateInput = {
    id_tracking?: SortOrder
    id_especie_instalada?: SortOrder
    fecha_registro?: SortOrder
    cantidad_actual?: SortOrder
    observaciones?: SortOrder
  }

  export type EspecieTrackingMinOrderByAggregateInput = {
    id_tracking?: SortOrder
    id_especie_instalada?: SortOrder
    fecha_registro?: SortOrder
    cantidad_actual?: SortOrder
    observaciones?: SortOrder
  }

  export type EspecieTrackingSumOrderByAggregateInput = {
    id_tracking?: SortOrder
    id_especie_instalada?: SortOrder
    cantidad_actual?: SortOrder
  }

  export type ParametroRelationFilter = {
    is?: ParametroWhereInput
    isNot?: ParametroWhereInput
  }

  export type EspecieParametroId_especieId_parametroCompoundUniqueInput = {
    id_especie: number
    id_parametro: number
  }

  export type EspecieParametroCountOrderByAggregateInput = {
    id_especie_parametro?: SortOrder
    id_especie?: SortOrder
    id_parametro?: SortOrder
    valor_optimo_min?: SortOrder
    valor_optimo_max?: SortOrder
  }

  export type EspecieParametroAvgOrderByAggregateInput = {
    id_especie_parametro?: SortOrder
    id_especie?: SortOrder
    id_parametro?: SortOrder
    valor_optimo_min?: SortOrder
    valor_optimo_max?: SortOrder
  }

  export type EspecieParametroMaxOrderByAggregateInput = {
    id_especie_parametro?: SortOrder
    id_especie?: SortOrder
    id_parametro?: SortOrder
    valor_optimo_min?: SortOrder
    valor_optimo_max?: SortOrder
  }

  export type EspecieParametroMinOrderByAggregateInput = {
    id_especie_parametro?: SortOrder
    id_especie?: SortOrder
    id_parametro?: SortOrder
    valor_optimo_min?: SortOrder
    valor_optimo_max?: SortOrder
  }

  export type EspecieParametroSumOrderByAggregateInput = {
    id_especie_parametro?: SortOrder
    id_especie?: SortOrder
    id_parametro?: SortOrder
    valor_optimo_min?: SortOrder
    valor_optimo_max?: SortOrder
  }

  export type ProcesoCountOrderByAggregateInput = {
    id_proceso?: SortOrder
    id_instalacion?: SortOrder
    nombre_proceso?: SortOrder
    descripcion?: SortOrder
    fecha_inicio?: SortOrder
    fecha_fin?: SortOrder
    estado?: SortOrder
  }

  export type ProcesoAvgOrderByAggregateInput = {
    id_proceso?: SortOrder
    id_instalacion?: SortOrder
  }

  export type ProcesoMaxOrderByAggregateInput = {
    id_proceso?: SortOrder
    id_instalacion?: SortOrder
    nombre_proceso?: SortOrder
    descripcion?: SortOrder
    fecha_inicio?: SortOrder
    fecha_fin?: SortOrder
    estado?: SortOrder
  }

  export type ProcesoMinOrderByAggregateInput = {
    id_proceso?: SortOrder
    id_instalacion?: SortOrder
    nombre_proceso?: SortOrder
    descripcion?: SortOrder
    fecha_inicio?: SortOrder
    fecha_fin?: SortOrder
    estado?: SortOrder
  }

  export type ProcesoSumOrderByAggregateInput = {
    id_proceso?: SortOrder
    id_instalacion?: SortOrder
  }

  export type OrganizacionSucursalCreateNestedManyWithoutOrganizacionInput = {
    create?: XOR<OrganizacionSucursalCreateWithoutOrganizacionInput, OrganizacionSucursalUncheckedCreateWithoutOrganizacionInput> | OrganizacionSucursalCreateWithoutOrganizacionInput[] | OrganizacionSucursalUncheckedCreateWithoutOrganizacionInput[]
    connectOrCreate?: OrganizacionSucursalCreateOrConnectWithoutOrganizacionInput | OrganizacionSucursalCreateOrConnectWithoutOrganizacionInput[]
    createMany?: OrganizacionSucursalCreateManyOrganizacionInputEnvelope
    connect?: OrganizacionSucursalWhereUniqueInput | OrganizacionSucursalWhereUniqueInput[]
  }

  export type OrganizacionSucursalUncheckedCreateNestedManyWithoutOrganizacionInput = {
    create?: XOR<OrganizacionSucursalCreateWithoutOrganizacionInput, OrganizacionSucursalUncheckedCreateWithoutOrganizacionInput> | OrganizacionSucursalCreateWithoutOrganizacionInput[] | OrganizacionSucursalUncheckedCreateWithoutOrganizacionInput[]
    connectOrCreate?: OrganizacionSucursalCreateOrConnectWithoutOrganizacionInput | OrganizacionSucursalCreateOrConnectWithoutOrganizacionInput[]
    createMany?: OrganizacionSucursalCreateManyOrganizacionInputEnvelope
    connect?: OrganizacionSucursalWhereUniqueInput | OrganizacionSucursalWhereUniqueInput[]
  }

  export type StringFieldUpdateOperationsInput = {
    set?: string
  }

  export type DateTimeFieldUpdateOperationsInput = {
    set?: Date | string
  }

  export type OrganizacionSucursalUpdateManyWithoutOrganizacionNestedInput = {
    create?: XOR<OrganizacionSucursalCreateWithoutOrganizacionInput, OrganizacionSucursalUncheckedCreateWithoutOrganizacionInput> | OrganizacionSucursalCreateWithoutOrganizacionInput[] | OrganizacionSucursalUncheckedCreateWithoutOrganizacionInput[]
    connectOrCreate?: OrganizacionSucursalCreateOrConnectWithoutOrganizacionInput | OrganizacionSucursalCreateOrConnectWithoutOrganizacionInput[]
    upsert?: OrganizacionSucursalUpsertWithWhereUniqueWithoutOrganizacionInput | OrganizacionSucursalUpsertWithWhereUniqueWithoutOrganizacionInput[]
    createMany?: OrganizacionSucursalCreateManyOrganizacionInputEnvelope
    set?: OrganizacionSucursalWhereUniqueInput | OrganizacionSucursalWhereUniqueInput[]
    disconnect?: OrganizacionSucursalWhereUniqueInput | OrganizacionSucursalWhereUniqueInput[]
    delete?: OrganizacionSucursalWhereUniqueInput | OrganizacionSucursalWhereUniqueInput[]
    connect?: OrganizacionSucursalWhereUniqueInput | OrganizacionSucursalWhereUniqueInput[]
    update?: OrganizacionSucursalUpdateWithWhereUniqueWithoutOrganizacionInput | OrganizacionSucursalUpdateWithWhereUniqueWithoutOrganizacionInput[]
    updateMany?: OrganizacionSucursalUpdateManyWithWhereWithoutOrganizacionInput | OrganizacionSucursalUpdateManyWithWhereWithoutOrganizacionInput[]
    deleteMany?: OrganizacionSucursalScalarWhereInput | OrganizacionSucursalScalarWhereInput[]
  }

  export type IntFieldUpdateOperationsInput = {
    set?: number
    increment?: number
    decrement?: number
    multiply?: number
    divide?: number
  }

  export type OrganizacionSucursalUncheckedUpdateManyWithoutOrganizacionNestedInput = {
    create?: XOR<OrganizacionSucursalCreateWithoutOrganizacionInput, OrganizacionSucursalUncheckedCreateWithoutOrganizacionInput> | OrganizacionSucursalCreateWithoutOrganizacionInput[] | OrganizacionSucursalUncheckedCreateWithoutOrganizacionInput[]
    connectOrCreate?: OrganizacionSucursalCreateOrConnectWithoutOrganizacionInput | OrganizacionSucursalCreateOrConnectWithoutOrganizacionInput[]
    upsert?: OrganizacionSucursalUpsertWithWhereUniqueWithoutOrganizacionInput | OrganizacionSucursalUpsertWithWhereUniqueWithoutOrganizacionInput[]
    createMany?: OrganizacionSucursalCreateManyOrganizacionInputEnvelope
    set?: OrganizacionSucursalWhereUniqueInput | OrganizacionSucursalWhereUniqueInput[]
    disconnect?: OrganizacionSucursalWhereUniqueInput | OrganizacionSucursalWhereUniqueInput[]
    delete?: OrganizacionSucursalWhereUniqueInput | OrganizacionSucursalWhereUniqueInput[]
    connect?: OrganizacionSucursalWhereUniqueInput | OrganizacionSucursalWhereUniqueInput[]
    update?: OrganizacionSucursalUpdateWithWhereUniqueWithoutOrganizacionInput | OrganizacionSucursalUpdateWithWhereUniqueWithoutOrganizacionInput[]
    updateMany?: OrganizacionSucursalUpdateManyWithWhereWithoutOrganizacionInput | OrganizacionSucursalUpdateManyWithWhereWithoutOrganizacionInput[]
    deleteMany?: OrganizacionSucursalScalarWhereInput | OrganizacionSucursalScalarWhereInput[]
  }

  export type OrganizacionCreateNestedOneWithoutSucursalesInput = {
    create?: XOR<OrganizacionCreateWithoutSucursalesInput, OrganizacionUncheckedCreateWithoutSucursalesInput>
    connectOrCreate?: OrganizacionCreateOrConnectWithoutSucursalesInput
    connect?: OrganizacionWhereUniqueInput
  }

  export type InstalacionCreateNestedManyWithoutSucursalInput = {
    create?: XOR<InstalacionCreateWithoutSucursalInput, InstalacionUncheckedCreateWithoutSucursalInput> | InstalacionCreateWithoutSucursalInput[] | InstalacionUncheckedCreateWithoutSucursalInput[]
    connectOrCreate?: InstalacionCreateOrConnectWithoutSucursalInput | InstalacionCreateOrConnectWithoutSucursalInput[]
    createMany?: InstalacionCreateManySucursalInputEnvelope
    connect?: InstalacionWhereUniqueInput | InstalacionWhereUniqueInput[]
  }

  export type InstalacionUncheckedCreateNestedManyWithoutSucursalInput = {
    create?: XOR<InstalacionCreateWithoutSucursalInput, InstalacionUncheckedCreateWithoutSucursalInput> | InstalacionCreateWithoutSucursalInput[] | InstalacionUncheckedCreateWithoutSucursalInput[]
    connectOrCreate?: InstalacionCreateOrConnectWithoutSucursalInput | InstalacionCreateOrConnectWithoutSucursalInput[]
    createMany?: InstalacionCreateManySucursalInputEnvelope
    connect?: InstalacionWhereUniqueInput | InstalacionWhereUniqueInput[]
  }

  export type OrganizacionUpdateOneRequiredWithoutSucursalesNestedInput = {
    create?: XOR<OrganizacionCreateWithoutSucursalesInput, OrganizacionUncheckedCreateWithoutSucursalesInput>
    connectOrCreate?: OrganizacionCreateOrConnectWithoutSucursalesInput
    upsert?: OrganizacionUpsertWithoutSucursalesInput
    connect?: OrganizacionWhereUniqueInput
    update?: XOR<XOR<OrganizacionUpdateToOneWithWhereWithoutSucursalesInput, OrganizacionUpdateWithoutSucursalesInput>, OrganizacionUncheckedUpdateWithoutSucursalesInput>
  }

  export type InstalacionUpdateManyWithoutSucursalNestedInput = {
    create?: XOR<InstalacionCreateWithoutSucursalInput, InstalacionUncheckedCreateWithoutSucursalInput> | InstalacionCreateWithoutSucursalInput[] | InstalacionUncheckedCreateWithoutSucursalInput[]
    connectOrCreate?: InstalacionCreateOrConnectWithoutSucursalInput | InstalacionCreateOrConnectWithoutSucursalInput[]
    upsert?: InstalacionUpsertWithWhereUniqueWithoutSucursalInput | InstalacionUpsertWithWhereUniqueWithoutSucursalInput[]
    createMany?: InstalacionCreateManySucursalInputEnvelope
    set?: InstalacionWhereUniqueInput | InstalacionWhereUniqueInput[]
    disconnect?: InstalacionWhereUniqueInput | InstalacionWhereUniqueInput[]
    delete?: InstalacionWhereUniqueInput | InstalacionWhereUniqueInput[]
    connect?: InstalacionWhereUniqueInput | InstalacionWhereUniqueInput[]
    update?: InstalacionUpdateWithWhereUniqueWithoutSucursalInput | InstalacionUpdateWithWhereUniqueWithoutSucursalInput[]
    updateMany?: InstalacionUpdateManyWithWhereWithoutSucursalInput | InstalacionUpdateManyWithWhereWithoutSucursalInput[]
    deleteMany?: InstalacionScalarWhereInput | InstalacionScalarWhereInput[]
  }

  export type InstalacionUncheckedUpdateManyWithoutSucursalNestedInput = {
    create?: XOR<InstalacionCreateWithoutSucursalInput, InstalacionUncheckedCreateWithoutSucursalInput> | InstalacionCreateWithoutSucursalInput[] | InstalacionUncheckedCreateWithoutSucursalInput[]
    connectOrCreate?: InstalacionCreateOrConnectWithoutSucursalInput | InstalacionCreateOrConnectWithoutSucursalInput[]
    upsert?: InstalacionUpsertWithWhereUniqueWithoutSucursalInput | InstalacionUpsertWithWhereUniqueWithoutSucursalInput[]
    createMany?: InstalacionCreateManySucursalInputEnvelope
    set?: InstalacionWhereUniqueInput | InstalacionWhereUniqueInput[]
    disconnect?: InstalacionWhereUniqueInput | InstalacionWhereUniqueInput[]
    delete?: InstalacionWhereUniqueInput | InstalacionWhereUniqueInput[]
    connect?: InstalacionWhereUniqueInput | InstalacionWhereUniqueInput[]
    update?: InstalacionUpdateWithWhereUniqueWithoutSucursalInput | InstalacionUpdateWithWhereUniqueWithoutSucursalInput[]
    updateMany?: InstalacionUpdateManyWithWhereWithoutSucursalInput | InstalacionUpdateManyWithWhereWithoutSucursalInput[]
    deleteMany?: InstalacionScalarWhereInput | InstalacionScalarWhereInput[]
  }

  export type OrganizacionSucursalCreateNestedOneWithoutInstalacionesInput = {
    create?: XOR<OrganizacionSucursalCreateWithoutInstalacionesInput, OrganizacionSucursalUncheckedCreateWithoutInstalacionesInput>
    connectOrCreate?: OrganizacionSucursalCreateOrConnectWithoutInstalacionesInput
    connect?: OrganizacionSucursalWhereUniqueInput
  }

  export type SensorInstaladoCreateNestedManyWithoutInstalacionInput = {
    create?: XOR<SensorInstaladoCreateWithoutInstalacionInput, SensorInstaladoUncheckedCreateWithoutInstalacionInput> | SensorInstaladoCreateWithoutInstalacionInput[] | SensorInstaladoUncheckedCreateWithoutInstalacionInput[]
    connectOrCreate?: SensorInstaladoCreateOrConnectWithoutInstalacionInput | SensorInstaladoCreateOrConnectWithoutInstalacionInput[]
    createMany?: SensorInstaladoCreateManyInstalacionInputEnvelope
    connect?: SensorInstaladoWhereUniqueInput | SensorInstaladoWhereUniqueInput[]
  }

  export type SensorInstaladoUncheckedCreateNestedManyWithoutInstalacionInput = {
    create?: XOR<SensorInstaladoCreateWithoutInstalacionInput, SensorInstaladoUncheckedCreateWithoutInstalacionInput> | SensorInstaladoCreateWithoutInstalacionInput[] | SensorInstaladoUncheckedCreateWithoutInstalacionInput[]
    connectOrCreate?: SensorInstaladoCreateOrConnectWithoutInstalacionInput | SensorInstaladoCreateOrConnectWithoutInstalacionInput[]
    createMany?: SensorInstaladoCreateManyInstalacionInputEnvelope
    connect?: SensorInstaladoWhereUniqueInput | SensorInstaladoWhereUniqueInput[]
  }

  export type OrganizacionSucursalUpdateOneRequiredWithoutInstalacionesNestedInput = {
    create?: XOR<OrganizacionSucursalCreateWithoutInstalacionesInput, OrganizacionSucursalUncheckedCreateWithoutInstalacionesInput>
    connectOrCreate?: OrganizacionSucursalCreateOrConnectWithoutInstalacionesInput
    upsert?: OrganizacionSucursalUpsertWithoutInstalacionesInput
    connect?: OrganizacionSucursalWhereUniqueInput
    update?: XOR<XOR<OrganizacionSucursalUpdateToOneWithWhereWithoutInstalacionesInput, OrganizacionSucursalUpdateWithoutInstalacionesInput>, OrganizacionSucursalUncheckedUpdateWithoutInstalacionesInput>
  }

  export type SensorInstaladoUpdateManyWithoutInstalacionNestedInput = {
    create?: XOR<SensorInstaladoCreateWithoutInstalacionInput, SensorInstaladoUncheckedCreateWithoutInstalacionInput> | SensorInstaladoCreateWithoutInstalacionInput[] | SensorInstaladoUncheckedCreateWithoutInstalacionInput[]
    connectOrCreate?: SensorInstaladoCreateOrConnectWithoutInstalacionInput | SensorInstaladoCreateOrConnectWithoutInstalacionInput[]
    upsert?: SensorInstaladoUpsertWithWhereUniqueWithoutInstalacionInput | SensorInstaladoUpsertWithWhereUniqueWithoutInstalacionInput[]
    createMany?: SensorInstaladoCreateManyInstalacionInputEnvelope
    set?: SensorInstaladoWhereUniqueInput | SensorInstaladoWhereUniqueInput[]
    disconnect?: SensorInstaladoWhereUniqueInput | SensorInstaladoWhereUniqueInput[]
    delete?: SensorInstaladoWhereUniqueInput | SensorInstaladoWhereUniqueInput[]
    connect?: SensorInstaladoWhereUniqueInput | SensorInstaladoWhereUniqueInput[]
    update?: SensorInstaladoUpdateWithWhereUniqueWithoutInstalacionInput | SensorInstaladoUpdateWithWhereUniqueWithoutInstalacionInput[]
    updateMany?: SensorInstaladoUpdateManyWithWhereWithoutInstalacionInput | SensorInstaladoUpdateManyWithWhereWithoutInstalacionInput[]
    deleteMany?: SensorInstaladoScalarWhereInput | SensorInstaladoScalarWhereInput[]
  }

  export type SensorInstaladoUncheckedUpdateManyWithoutInstalacionNestedInput = {
    create?: XOR<SensorInstaladoCreateWithoutInstalacionInput, SensorInstaladoUncheckedCreateWithoutInstalacionInput> | SensorInstaladoCreateWithoutInstalacionInput[] | SensorInstaladoUncheckedCreateWithoutInstalacionInput[]
    connectOrCreate?: SensorInstaladoCreateOrConnectWithoutInstalacionInput | SensorInstaladoCreateOrConnectWithoutInstalacionInput[]
    upsert?: SensorInstaladoUpsertWithWhereUniqueWithoutInstalacionInput | SensorInstaladoUpsertWithWhereUniqueWithoutInstalacionInput[]
    createMany?: SensorInstaladoCreateManyInstalacionInputEnvelope
    set?: SensorInstaladoWhereUniqueInput | SensorInstaladoWhereUniqueInput[]
    disconnect?: SensorInstaladoWhereUniqueInput | SensorInstaladoWhereUniqueInput[]
    delete?: SensorInstaladoWhereUniqueInput | SensorInstaladoWhereUniqueInput[]
    connect?: SensorInstaladoWhereUniqueInput | SensorInstaladoWhereUniqueInput[]
    update?: SensorInstaladoUpdateWithWhereUniqueWithoutInstalacionInput | SensorInstaladoUpdateWithWhereUniqueWithoutInstalacionInput[]
    updateMany?: SensorInstaladoUpdateManyWithWhereWithoutInstalacionInput | SensorInstaladoUpdateManyWithWhereWithoutInstalacionInput[]
    deleteMany?: SensorInstaladoScalarWhereInput | SensorInstaladoScalarWhereInput[]
  }

  export type SensorInstaladoCreateNestedManyWithoutCatalogoInput = {
    create?: XOR<SensorInstaladoCreateWithoutCatalogoInput, SensorInstaladoUncheckedCreateWithoutCatalogoInput> | SensorInstaladoCreateWithoutCatalogoInput[] | SensorInstaladoUncheckedCreateWithoutCatalogoInput[]
    connectOrCreate?: SensorInstaladoCreateOrConnectWithoutCatalogoInput | SensorInstaladoCreateOrConnectWithoutCatalogoInput[]
    createMany?: SensorInstaladoCreateManyCatalogoInputEnvelope
    connect?: SensorInstaladoWhereUniqueInput | SensorInstaladoWhereUniqueInput[]
  }

  export type SensorInstaladoUncheckedCreateNestedManyWithoutCatalogoInput = {
    create?: XOR<SensorInstaladoCreateWithoutCatalogoInput, SensorInstaladoUncheckedCreateWithoutCatalogoInput> | SensorInstaladoCreateWithoutCatalogoInput[] | SensorInstaladoUncheckedCreateWithoutCatalogoInput[]
    connectOrCreate?: SensorInstaladoCreateOrConnectWithoutCatalogoInput | SensorInstaladoCreateOrConnectWithoutCatalogoInput[]
    createMany?: SensorInstaladoCreateManyCatalogoInputEnvelope
    connect?: SensorInstaladoWhereUniqueInput | SensorInstaladoWhereUniqueInput[]
  }

  export type NullableStringFieldUpdateOperationsInput = {
    set?: string | null
  }

  export type NullableEnumTipoMedidaFieldUpdateOperationsInput = {
    set?: $Enums.TipoMedida | null
  }

  export type NullableDecimalFieldUpdateOperationsInput = {
    set?: Decimal | DecimalJsLike | number | string | null
    increment?: Decimal | DecimalJsLike | number | string
    decrement?: Decimal | DecimalJsLike | number | string
    multiply?: Decimal | DecimalJsLike | number | string
    divide?: Decimal | DecimalJsLike | number | string
  }

  export type SensorInstaladoUpdateManyWithoutCatalogoNestedInput = {
    create?: XOR<SensorInstaladoCreateWithoutCatalogoInput, SensorInstaladoUncheckedCreateWithoutCatalogoInput> | SensorInstaladoCreateWithoutCatalogoInput[] | SensorInstaladoUncheckedCreateWithoutCatalogoInput[]
    connectOrCreate?: SensorInstaladoCreateOrConnectWithoutCatalogoInput | SensorInstaladoCreateOrConnectWithoutCatalogoInput[]
    upsert?: SensorInstaladoUpsertWithWhereUniqueWithoutCatalogoInput | SensorInstaladoUpsertWithWhereUniqueWithoutCatalogoInput[]
    createMany?: SensorInstaladoCreateManyCatalogoInputEnvelope
    set?: SensorInstaladoWhereUniqueInput | SensorInstaladoWhereUniqueInput[]
    disconnect?: SensorInstaladoWhereUniqueInput | SensorInstaladoWhereUniqueInput[]
    delete?: SensorInstaladoWhereUniqueInput | SensorInstaladoWhereUniqueInput[]
    connect?: SensorInstaladoWhereUniqueInput | SensorInstaladoWhereUniqueInput[]
    update?: SensorInstaladoUpdateWithWhereUniqueWithoutCatalogoInput | SensorInstaladoUpdateWithWhereUniqueWithoutCatalogoInput[]
    updateMany?: SensorInstaladoUpdateManyWithWhereWithoutCatalogoInput | SensorInstaladoUpdateManyWithWhereWithoutCatalogoInput[]
    deleteMany?: SensorInstaladoScalarWhereInput | SensorInstaladoScalarWhereInput[]
  }

  export type SensorInstaladoUncheckedUpdateManyWithoutCatalogoNestedInput = {
    create?: XOR<SensorInstaladoCreateWithoutCatalogoInput, SensorInstaladoUncheckedCreateWithoutCatalogoInput> | SensorInstaladoCreateWithoutCatalogoInput[] | SensorInstaladoUncheckedCreateWithoutCatalogoInput[]
    connectOrCreate?: SensorInstaladoCreateOrConnectWithoutCatalogoInput | SensorInstaladoCreateOrConnectWithoutCatalogoInput[]
    upsert?: SensorInstaladoUpsertWithWhereUniqueWithoutCatalogoInput | SensorInstaladoUpsertWithWhereUniqueWithoutCatalogoInput[]
    createMany?: SensorInstaladoCreateManyCatalogoInputEnvelope
    set?: SensorInstaladoWhereUniqueInput | SensorInstaladoWhereUniqueInput[]
    disconnect?: SensorInstaladoWhereUniqueInput | SensorInstaladoWhereUniqueInput[]
    delete?: SensorInstaladoWhereUniqueInput | SensorInstaladoWhereUniqueInput[]
    connect?: SensorInstaladoWhereUniqueInput | SensorInstaladoWhereUniqueInput[]
    update?: SensorInstaladoUpdateWithWhereUniqueWithoutCatalogoInput | SensorInstaladoUpdateWithWhereUniqueWithoutCatalogoInput[]
    updateMany?: SensorInstaladoUpdateManyWithWhereWithoutCatalogoInput | SensorInstaladoUpdateManyWithWhereWithoutCatalogoInput[]
    deleteMany?: SensorInstaladoScalarWhereInput | SensorInstaladoScalarWhereInput[]
  }

  export type InstalacionCreateNestedOneWithoutSensoresInput = {
    create?: XOR<InstalacionCreateWithoutSensoresInput, InstalacionUncheckedCreateWithoutSensoresInput>
    connectOrCreate?: InstalacionCreateOrConnectWithoutSensoresInput
    connect?: InstalacionWhereUniqueInput
  }

  export type CatalogoSensorCreateNestedOneWithoutSensoresInstaladosInput = {
    create?: XOR<CatalogoSensorCreateWithoutSensoresInstaladosInput, CatalogoSensorUncheckedCreateWithoutSensoresInstaladosInput>
    connectOrCreate?: CatalogoSensorCreateOrConnectWithoutSensoresInstaladosInput
    connect?: CatalogoSensorWhereUniqueInput
  }

  export type LecturaCreateNestedManyWithoutSensorInput = {
    create?: XOR<LecturaCreateWithoutSensorInput, LecturaUncheckedCreateWithoutSensorInput> | LecturaCreateWithoutSensorInput[] | LecturaUncheckedCreateWithoutSensorInput[]
    connectOrCreate?: LecturaCreateOrConnectWithoutSensorInput | LecturaCreateOrConnectWithoutSensorInput[]
    createMany?: LecturaCreateManySensorInputEnvelope
    connect?: LecturaWhereUniqueInput | LecturaWhereUniqueInput[]
  }

  export type LecturaUncheckedCreateNestedManyWithoutSensorInput = {
    create?: XOR<LecturaCreateWithoutSensorInput, LecturaUncheckedCreateWithoutSensorInput> | LecturaCreateWithoutSensorInput[] | LecturaUncheckedCreateWithoutSensorInput[]
    connectOrCreate?: LecturaCreateOrConnectWithoutSensorInput | LecturaCreateOrConnectWithoutSensorInput[]
    createMany?: LecturaCreateManySensorInputEnvelope
    connect?: LecturaWhereUniqueInput | LecturaWhereUniqueInput[]
  }

  export type NullableDateTimeFieldUpdateOperationsInput = {
    set?: Date | string | null
  }

  export type InstalacionUpdateOneRequiredWithoutSensoresNestedInput = {
    create?: XOR<InstalacionCreateWithoutSensoresInput, InstalacionUncheckedCreateWithoutSensoresInput>
    connectOrCreate?: InstalacionCreateOrConnectWithoutSensoresInput
    upsert?: InstalacionUpsertWithoutSensoresInput
    connect?: InstalacionWhereUniqueInput
    update?: XOR<XOR<InstalacionUpdateToOneWithWhereWithoutSensoresInput, InstalacionUpdateWithoutSensoresInput>, InstalacionUncheckedUpdateWithoutSensoresInput>
  }

  export type CatalogoSensorUpdateOneRequiredWithoutSensoresInstaladosNestedInput = {
    create?: XOR<CatalogoSensorCreateWithoutSensoresInstaladosInput, CatalogoSensorUncheckedCreateWithoutSensoresInstaladosInput>
    connectOrCreate?: CatalogoSensorCreateOrConnectWithoutSensoresInstaladosInput
    upsert?: CatalogoSensorUpsertWithoutSensoresInstaladosInput
    connect?: CatalogoSensorWhereUniqueInput
    update?: XOR<XOR<CatalogoSensorUpdateToOneWithWhereWithoutSensoresInstaladosInput, CatalogoSensorUpdateWithoutSensoresInstaladosInput>, CatalogoSensorUncheckedUpdateWithoutSensoresInstaladosInput>
  }

  export type LecturaUpdateManyWithoutSensorNestedInput = {
    create?: XOR<LecturaCreateWithoutSensorInput, LecturaUncheckedCreateWithoutSensorInput> | LecturaCreateWithoutSensorInput[] | LecturaUncheckedCreateWithoutSensorInput[]
    connectOrCreate?: LecturaCreateOrConnectWithoutSensorInput | LecturaCreateOrConnectWithoutSensorInput[]
    upsert?: LecturaUpsertWithWhereUniqueWithoutSensorInput | LecturaUpsertWithWhereUniqueWithoutSensorInput[]
    createMany?: LecturaCreateManySensorInputEnvelope
    set?: LecturaWhereUniqueInput | LecturaWhereUniqueInput[]
    disconnect?: LecturaWhereUniqueInput | LecturaWhereUniqueInput[]
    delete?: LecturaWhereUniqueInput | LecturaWhereUniqueInput[]
    connect?: LecturaWhereUniqueInput | LecturaWhereUniqueInput[]
    update?: LecturaUpdateWithWhereUniqueWithoutSensorInput | LecturaUpdateWithWhereUniqueWithoutSensorInput[]
    updateMany?: LecturaUpdateManyWithWhereWithoutSensorInput | LecturaUpdateManyWithWhereWithoutSensorInput[]
    deleteMany?: LecturaScalarWhereInput | LecturaScalarWhereInput[]
  }

  export type LecturaUncheckedUpdateManyWithoutSensorNestedInput = {
    create?: XOR<LecturaCreateWithoutSensorInput, LecturaUncheckedCreateWithoutSensorInput> | LecturaCreateWithoutSensorInput[] | LecturaUncheckedCreateWithoutSensorInput[]
    connectOrCreate?: LecturaCreateOrConnectWithoutSensorInput | LecturaCreateOrConnectWithoutSensorInput[]
    upsert?: LecturaUpsertWithWhereUniqueWithoutSensorInput | LecturaUpsertWithWhereUniqueWithoutSensorInput[]
    createMany?: LecturaCreateManySensorInputEnvelope
    set?: LecturaWhereUniqueInput | LecturaWhereUniqueInput[]
    disconnect?: LecturaWhereUniqueInput | LecturaWhereUniqueInput[]
    delete?: LecturaWhereUniqueInput | LecturaWhereUniqueInput[]
    connect?: LecturaWhereUniqueInput | LecturaWhereUniqueInput[]
    update?: LecturaUpdateWithWhereUniqueWithoutSensorInput | LecturaUpdateWithWhereUniqueWithoutSensorInput[]
    updateMany?: LecturaUpdateManyWithWhereWithoutSensorInput | LecturaUpdateManyWithWhereWithoutSensorInput[]
    deleteMany?: LecturaScalarWhereInput | LecturaScalarWhereInput[]
  }

  export type SensorInstaladoCreateNestedOneWithoutLecturasInput = {
    create?: XOR<SensorInstaladoCreateWithoutLecturasInput, SensorInstaladoUncheckedCreateWithoutLecturasInput>
    connectOrCreate?: SensorInstaladoCreateOrConnectWithoutLecturasInput
    connect?: SensorInstaladoWhereUniqueInput
  }

  export type BigIntFieldUpdateOperationsInput = {
    set?: bigint | number
    increment?: bigint | number
    decrement?: bigint | number
    multiply?: bigint | number
    divide?: bigint | number
  }

  export type DecimalFieldUpdateOperationsInput = {
    set?: Decimal | DecimalJsLike | number | string
    increment?: Decimal | DecimalJsLike | number | string
    decrement?: Decimal | DecimalJsLike | number | string
    multiply?: Decimal | DecimalJsLike | number | string
    divide?: Decimal | DecimalJsLike | number | string
  }

  export type SensorInstaladoUpdateOneRequiredWithoutLecturasNestedInput = {
    create?: XOR<SensorInstaladoCreateWithoutLecturasInput, SensorInstaladoUncheckedCreateWithoutLecturasInput>
    connectOrCreate?: SensorInstaladoCreateOrConnectWithoutLecturasInput
    upsert?: SensorInstaladoUpsertWithoutLecturasInput
    connect?: SensorInstaladoWhereUniqueInput
    update?: XOR<XOR<SensorInstaladoUpdateToOneWithWhereWithoutLecturasInput, SensorInstaladoUpdateWithoutLecturasInput>, SensorInstaladoUncheckedUpdateWithoutLecturasInput>
  }

  export type MunicipioCreateNestedManyWithoutEstadoInput = {
    create?: XOR<MunicipioCreateWithoutEstadoInput, MunicipioUncheckedCreateWithoutEstadoInput> | MunicipioCreateWithoutEstadoInput[] | MunicipioUncheckedCreateWithoutEstadoInput[]
    connectOrCreate?: MunicipioCreateOrConnectWithoutEstadoInput | MunicipioCreateOrConnectWithoutEstadoInput[]
    createMany?: MunicipioCreateManyEstadoInputEnvelope
    connect?: MunicipioWhereUniqueInput | MunicipioWhereUniqueInput[]
  }

  export type MunicipioUncheckedCreateNestedManyWithoutEstadoInput = {
    create?: XOR<MunicipioCreateWithoutEstadoInput, MunicipioUncheckedCreateWithoutEstadoInput> | MunicipioCreateWithoutEstadoInput[] | MunicipioUncheckedCreateWithoutEstadoInput[]
    connectOrCreate?: MunicipioCreateOrConnectWithoutEstadoInput | MunicipioCreateOrConnectWithoutEstadoInput[]
    createMany?: MunicipioCreateManyEstadoInputEnvelope
    connect?: MunicipioWhereUniqueInput | MunicipioWhereUniqueInput[]
  }

  export type MunicipioUpdateManyWithoutEstadoNestedInput = {
    create?: XOR<MunicipioCreateWithoutEstadoInput, MunicipioUncheckedCreateWithoutEstadoInput> | MunicipioCreateWithoutEstadoInput[] | MunicipioUncheckedCreateWithoutEstadoInput[]
    connectOrCreate?: MunicipioCreateOrConnectWithoutEstadoInput | MunicipioCreateOrConnectWithoutEstadoInput[]
    upsert?: MunicipioUpsertWithWhereUniqueWithoutEstadoInput | MunicipioUpsertWithWhereUniqueWithoutEstadoInput[]
    createMany?: MunicipioCreateManyEstadoInputEnvelope
    set?: MunicipioWhereUniqueInput | MunicipioWhereUniqueInput[]
    disconnect?: MunicipioWhereUniqueInput | MunicipioWhereUniqueInput[]
    delete?: MunicipioWhereUniqueInput | MunicipioWhereUniqueInput[]
    connect?: MunicipioWhereUniqueInput | MunicipioWhereUniqueInput[]
    update?: MunicipioUpdateWithWhereUniqueWithoutEstadoInput | MunicipioUpdateWithWhereUniqueWithoutEstadoInput[]
    updateMany?: MunicipioUpdateManyWithWhereWithoutEstadoInput | MunicipioUpdateManyWithWhereWithoutEstadoInput[]
    deleteMany?: MunicipioScalarWhereInput | MunicipioScalarWhereInput[]
  }

  export type MunicipioUncheckedUpdateManyWithoutEstadoNestedInput = {
    create?: XOR<MunicipioCreateWithoutEstadoInput, MunicipioUncheckedCreateWithoutEstadoInput> | MunicipioCreateWithoutEstadoInput[] | MunicipioUncheckedCreateWithoutEstadoInput[]
    connectOrCreate?: MunicipioCreateOrConnectWithoutEstadoInput | MunicipioCreateOrConnectWithoutEstadoInput[]
    upsert?: MunicipioUpsertWithWhereUniqueWithoutEstadoInput | MunicipioUpsertWithWhereUniqueWithoutEstadoInput[]
    createMany?: MunicipioCreateManyEstadoInputEnvelope
    set?: MunicipioWhereUniqueInput | MunicipioWhereUniqueInput[]
    disconnect?: MunicipioWhereUniqueInput | MunicipioWhereUniqueInput[]
    delete?: MunicipioWhereUniqueInput | MunicipioWhereUniqueInput[]
    connect?: MunicipioWhereUniqueInput | MunicipioWhereUniqueInput[]
    update?: MunicipioUpdateWithWhereUniqueWithoutEstadoInput | MunicipioUpdateWithWhereUniqueWithoutEstadoInput[]
    updateMany?: MunicipioUpdateManyWithWhereWithoutEstadoInput | MunicipioUpdateManyWithWhereWithoutEstadoInput[]
    deleteMany?: MunicipioScalarWhereInput | MunicipioScalarWhereInput[]
  }

  export type EstadoCreateNestedOneWithoutMunicipiosInput = {
    create?: XOR<EstadoCreateWithoutMunicipiosInput, EstadoUncheckedCreateWithoutMunicipiosInput>
    connectOrCreate?: EstadoCreateOrConnectWithoutMunicipiosInput
    connect?: EstadoWhereUniqueInput
  }

  export type CodigoPostalCreateNestedManyWithoutMunicipioInput = {
    create?: XOR<CodigoPostalCreateWithoutMunicipioInput, CodigoPostalUncheckedCreateWithoutMunicipioInput> | CodigoPostalCreateWithoutMunicipioInput[] | CodigoPostalUncheckedCreateWithoutMunicipioInput[]
    connectOrCreate?: CodigoPostalCreateOrConnectWithoutMunicipioInput | CodigoPostalCreateOrConnectWithoutMunicipioInput[]
    createMany?: CodigoPostalCreateManyMunicipioInputEnvelope
    connect?: CodigoPostalWhereUniqueInput | CodigoPostalWhereUniqueInput[]
  }

  export type CodigoPostalUncheckedCreateNestedManyWithoutMunicipioInput = {
    create?: XOR<CodigoPostalCreateWithoutMunicipioInput, CodigoPostalUncheckedCreateWithoutMunicipioInput> | CodigoPostalCreateWithoutMunicipioInput[] | CodigoPostalUncheckedCreateWithoutMunicipioInput[]
    connectOrCreate?: CodigoPostalCreateOrConnectWithoutMunicipioInput | CodigoPostalCreateOrConnectWithoutMunicipioInput[]
    createMany?: CodigoPostalCreateManyMunicipioInputEnvelope
    connect?: CodigoPostalWhereUniqueInput | CodigoPostalWhereUniqueInput[]
  }

  export type EstadoUpdateOneRequiredWithoutMunicipiosNestedInput = {
    create?: XOR<EstadoCreateWithoutMunicipiosInput, EstadoUncheckedCreateWithoutMunicipiosInput>
    connectOrCreate?: EstadoCreateOrConnectWithoutMunicipiosInput
    upsert?: EstadoUpsertWithoutMunicipiosInput
    connect?: EstadoWhereUniqueInput
    update?: XOR<XOR<EstadoUpdateToOneWithWhereWithoutMunicipiosInput, EstadoUpdateWithoutMunicipiosInput>, EstadoUncheckedUpdateWithoutMunicipiosInput>
  }

  export type CodigoPostalUpdateManyWithoutMunicipioNestedInput = {
    create?: XOR<CodigoPostalCreateWithoutMunicipioInput, CodigoPostalUncheckedCreateWithoutMunicipioInput> | CodigoPostalCreateWithoutMunicipioInput[] | CodigoPostalUncheckedCreateWithoutMunicipioInput[]
    connectOrCreate?: CodigoPostalCreateOrConnectWithoutMunicipioInput | CodigoPostalCreateOrConnectWithoutMunicipioInput[]
    upsert?: CodigoPostalUpsertWithWhereUniqueWithoutMunicipioInput | CodigoPostalUpsertWithWhereUniqueWithoutMunicipioInput[]
    createMany?: CodigoPostalCreateManyMunicipioInputEnvelope
    set?: CodigoPostalWhereUniqueInput | CodigoPostalWhereUniqueInput[]
    disconnect?: CodigoPostalWhereUniqueInput | CodigoPostalWhereUniqueInput[]
    delete?: CodigoPostalWhereUniqueInput | CodigoPostalWhereUniqueInput[]
    connect?: CodigoPostalWhereUniqueInput | CodigoPostalWhereUniqueInput[]
    update?: CodigoPostalUpdateWithWhereUniqueWithoutMunicipioInput | CodigoPostalUpdateWithWhereUniqueWithoutMunicipioInput[]
    updateMany?: CodigoPostalUpdateManyWithWhereWithoutMunicipioInput | CodigoPostalUpdateManyWithWhereWithoutMunicipioInput[]
    deleteMany?: CodigoPostalScalarWhereInput | CodigoPostalScalarWhereInput[]
  }

  export type CodigoPostalUncheckedUpdateManyWithoutMunicipioNestedInput = {
    create?: XOR<CodigoPostalCreateWithoutMunicipioInput, CodigoPostalUncheckedCreateWithoutMunicipioInput> | CodigoPostalCreateWithoutMunicipioInput[] | CodigoPostalUncheckedCreateWithoutMunicipioInput[]
    connectOrCreate?: CodigoPostalCreateOrConnectWithoutMunicipioInput | CodigoPostalCreateOrConnectWithoutMunicipioInput[]
    upsert?: CodigoPostalUpsertWithWhereUniqueWithoutMunicipioInput | CodigoPostalUpsertWithWhereUniqueWithoutMunicipioInput[]
    createMany?: CodigoPostalCreateManyMunicipioInputEnvelope
    set?: CodigoPostalWhereUniqueInput | CodigoPostalWhereUniqueInput[]
    disconnect?: CodigoPostalWhereUniqueInput | CodigoPostalWhereUniqueInput[]
    delete?: CodigoPostalWhereUniqueInput | CodigoPostalWhereUniqueInput[]
    connect?: CodigoPostalWhereUniqueInput | CodigoPostalWhereUniqueInput[]
    update?: CodigoPostalUpdateWithWhereUniqueWithoutMunicipioInput | CodigoPostalUpdateWithWhereUniqueWithoutMunicipioInput[]
    updateMany?: CodigoPostalUpdateManyWithWhereWithoutMunicipioInput | CodigoPostalUpdateManyWithWhereWithoutMunicipioInput[]
    deleteMany?: CodigoPostalScalarWhereInput | CodigoPostalScalarWhereInput[]
  }

  export type MunicipioCreateNestedOneWithoutCodigosPostalesInput = {
    create?: XOR<MunicipioCreateWithoutCodigosPostalesInput, MunicipioUncheckedCreateWithoutCodigosPostalesInput>
    connectOrCreate?: MunicipioCreateOrConnectWithoutCodigosPostalesInput
    connect?: MunicipioWhereUniqueInput
  }

  export type ColoniaCreateNestedManyWithoutCodigoPostalInput = {
    create?: XOR<ColoniaCreateWithoutCodigoPostalInput, ColoniaUncheckedCreateWithoutCodigoPostalInput> | ColoniaCreateWithoutCodigoPostalInput[] | ColoniaUncheckedCreateWithoutCodigoPostalInput[]
    connectOrCreate?: ColoniaCreateOrConnectWithoutCodigoPostalInput | ColoniaCreateOrConnectWithoutCodigoPostalInput[]
    createMany?: ColoniaCreateManyCodigoPostalInputEnvelope
    connect?: ColoniaWhereUniqueInput | ColoniaWhereUniqueInput[]
  }

  export type ColoniaUncheckedCreateNestedManyWithoutCodigoPostalInput = {
    create?: XOR<ColoniaCreateWithoutCodigoPostalInput, ColoniaUncheckedCreateWithoutCodigoPostalInput> | ColoniaCreateWithoutCodigoPostalInput[] | ColoniaUncheckedCreateWithoutCodigoPostalInput[]
    connectOrCreate?: ColoniaCreateOrConnectWithoutCodigoPostalInput | ColoniaCreateOrConnectWithoutCodigoPostalInput[]
    createMany?: ColoniaCreateManyCodigoPostalInputEnvelope
    connect?: ColoniaWhereUniqueInput | ColoniaWhereUniqueInput[]
  }

  export type MunicipioUpdateOneRequiredWithoutCodigosPostalesNestedInput = {
    create?: XOR<MunicipioCreateWithoutCodigosPostalesInput, MunicipioUncheckedCreateWithoutCodigosPostalesInput>
    connectOrCreate?: MunicipioCreateOrConnectWithoutCodigosPostalesInput
    upsert?: MunicipioUpsertWithoutCodigosPostalesInput
    connect?: MunicipioWhereUniqueInput
    update?: XOR<XOR<MunicipioUpdateToOneWithWhereWithoutCodigosPostalesInput, MunicipioUpdateWithoutCodigosPostalesInput>, MunicipioUncheckedUpdateWithoutCodigosPostalesInput>
  }

  export type ColoniaUpdateManyWithoutCodigoPostalNestedInput = {
    create?: XOR<ColoniaCreateWithoutCodigoPostalInput, ColoniaUncheckedCreateWithoutCodigoPostalInput> | ColoniaCreateWithoutCodigoPostalInput[] | ColoniaUncheckedCreateWithoutCodigoPostalInput[]
    connectOrCreate?: ColoniaCreateOrConnectWithoutCodigoPostalInput | ColoniaCreateOrConnectWithoutCodigoPostalInput[]
    upsert?: ColoniaUpsertWithWhereUniqueWithoutCodigoPostalInput | ColoniaUpsertWithWhereUniqueWithoutCodigoPostalInput[]
    createMany?: ColoniaCreateManyCodigoPostalInputEnvelope
    set?: ColoniaWhereUniqueInput | ColoniaWhereUniqueInput[]
    disconnect?: ColoniaWhereUniqueInput | ColoniaWhereUniqueInput[]
    delete?: ColoniaWhereUniqueInput | ColoniaWhereUniqueInput[]
    connect?: ColoniaWhereUniqueInput | ColoniaWhereUniqueInput[]
    update?: ColoniaUpdateWithWhereUniqueWithoutCodigoPostalInput | ColoniaUpdateWithWhereUniqueWithoutCodigoPostalInput[]
    updateMany?: ColoniaUpdateManyWithWhereWithoutCodigoPostalInput | ColoniaUpdateManyWithWhereWithoutCodigoPostalInput[]
    deleteMany?: ColoniaScalarWhereInput | ColoniaScalarWhereInput[]
  }

  export type ColoniaUncheckedUpdateManyWithoutCodigoPostalNestedInput = {
    create?: XOR<ColoniaCreateWithoutCodigoPostalInput, ColoniaUncheckedCreateWithoutCodigoPostalInput> | ColoniaCreateWithoutCodigoPostalInput[] | ColoniaUncheckedCreateWithoutCodigoPostalInput[]
    connectOrCreate?: ColoniaCreateOrConnectWithoutCodigoPostalInput | ColoniaCreateOrConnectWithoutCodigoPostalInput[]
    upsert?: ColoniaUpsertWithWhereUniqueWithoutCodigoPostalInput | ColoniaUpsertWithWhereUniqueWithoutCodigoPostalInput[]
    createMany?: ColoniaCreateManyCodigoPostalInputEnvelope
    set?: ColoniaWhereUniqueInput | ColoniaWhereUniqueInput[]
    disconnect?: ColoniaWhereUniqueInput | ColoniaWhereUniqueInput[]
    delete?: ColoniaWhereUniqueInput | ColoniaWhereUniqueInput[]
    connect?: ColoniaWhereUniqueInput | ColoniaWhereUniqueInput[]
    update?: ColoniaUpdateWithWhereUniqueWithoutCodigoPostalInput | ColoniaUpdateWithWhereUniqueWithoutCodigoPostalInput[]
    updateMany?: ColoniaUpdateManyWithWhereWithoutCodigoPostalInput | ColoniaUpdateManyWithWhereWithoutCodigoPostalInput[]
    deleteMany?: ColoniaScalarWhereInput | ColoniaScalarWhereInput[]
  }

  export type CodigoPostalCreateNestedOneWithoutColoniasInput = {
    create?: XOR<CodigoPostalCreateWithoutColoniasInput, CodigoPostalUncheckedCreateWithoutColoniasInput>
    connectOrCreate?: CodigoPostalCreateOrConnectWithoutColoniasInput
    connect?: CodigoPostalWhereUniqueInput
  }

  export type CodigoPostalUpdateOneRequiredWithoutColoniasNestedInput = {
    create?: XOR<CodigoPostalCreateWithoutColoniasInput, CodigoPostalUncheckedCreateWithoutColoniasInput>
    connectOrCreate?: CodigoPostalCreateOrConnectWithoutColoniasInput
    upsert?: CodigoPostalUpsertWithoutColoniasInput
    connect?: CodigoPostalWhereUniqueInput
    update?: XOR<XOR<CodigoPostalUpdateToOneWithWhereWithoutColoniasInput, CodigoPostalUpdateWithoutColoniasInput>, CodigoPostalUncheckedUpdateWithoutColoniasInput>
  }

  export type TipoRolCreateNestedOneWithoutUsuariosInput = {
    create?: XOR<TipoRolCreateWithoutUsuariosInput, TipoRolUncheckedCreateWithoutUsuariosInput>
    connectOrCreate?: TipoRolCreateOrConnectWithoutUsuariosInput
    connect?: TipoRolWhereUniqueInput
  }

  export type BoolFieldUpdateOperationsInput = {
    set?: boolean
  }

  export type TipoRolUpdateOneRequiredWithoutUsuariosNestedInput = {
    create?: XOR<TipoRolCreateWithoutUsuariosInput, TipoRolUncheckedCreateWithoutUsuariosInput>
    connectOrCreate?: TipoRolCreateOrConnectWithoutUsuariosInput
    upsert?: TipoRolUpsertWithoutUsuariosInput
    connect?: TipoRolWhereUniqueInput
    update?: XOR<XOR<TipoRolUpdateToOneWithWhereWithoutUsuariosInput, TipoRolUpdateWithoutUsuariosInput>, TipoRolUncheckedUpdateWithoutUsuariosInput>
  }

  export type UsuarioCreateNestedManyWithoutTipoRolInput = {
    create?: XOR<UsuarioCreateWithoutTipoRolInput, UsuarioUncheckedCreateWithoutTipoRolInput> | UsuarioCreateWithoutTipoRolInput[] | UsuarioUncheckedCreateWithoutTipoRolInput[]
    connectOrCreate?: UsuarioCreateOrConnectWithoutTipoRolInput | UsuarioCreateOrConnectWithoutTipoRolInput[]
    createMany?: UsuarioCreateManyTipoRolInputEnvelope
    connect?: UsuarioWhereUniqueInput | UsuarioWhereUniqueInput[]
  }

  export type UsuarioUncheckedCreateNestedManyWithoutTipoRolInput = {
    create?: XOR<UsuarioCreateWithoutTipoRolInput, UsuarioUncheckedCreateWithoutTipoRolInput> | UsuarioCreateWithoutTipoRolInput[] | UsuarioUncheckedCreateWithoutTipoRolInput[]
    connectOrCreate?: UsuarioCreateOrConnectWithoutTipoRolInput | UsuarioCreateOrConnectWithoutTipoRolInput[]
    createMany?: UsuarioCreateManyTipoRolInputEnvelope
    connect?: UsuarioWhereUniqueInput | UsuarioWhereUniqueInput[]
  }

  export type UsuarioUpdateManyWithoutTipoRolNestedInput = {
    create?: XOR<UsuarioCreateWithoutTipoRolInput, UsuarioUncheckedCreateWithoutTipoRolInput> | UsuarioCreateWithoutTipoRolInput[] | UsuarioUncheckedCreateWithoutTipoRolInput[]
    connectOrCreate?: UsuarioCreateOrConnectWithoutTipoRolInput | UsuarioCreateOrConnectWithoutTipoRolInput[]
    upsert?: UsuarioUpsertWithWhereUniqueWithoutTipoRolInput | UsuarioUpsertWithWhereUniqueWithoutTipoRolInput[]
    createMany?: UsuarioCreateManyTipoRolInputEnvelope
    set?: UsuarioWhereUniqueInput | UsuarioWhereUniqueInput[]
    disconnect?: UsuarioWhereUniqueInput | UsuarioWhereUniqueInput[]
    delete?: UsuarioWhereUniqueInput | UsuarioWhereUniqueInput[]
    connect?: UsuarioWhereUniqueInput | UsuarioWhereUniqueInput[]
    update?: UsuarioUpdateWithWhereUniqueWithoutTipoRolInput | UsuarioUpdateWithWhereUniqueWithoutTipoRolInput[]
    updateMany?: UsuarioUpdateManyWithWhereWithoutTipoRolInput | UsuarioUpdateManyWithWhereWithoutTipoRolInput[]
    deleteMany?: UsuarioScalarWhereInput | UsuarioScalarWhereInput[]
  }

  export type UsuarioUncheckedUpdateManyWithoutTipoRolNestedInput = {
    create?: XOR<UsuarioCreateWithoutTipoRolInput, UsuarioUncheckedCreateWithoutTipoRolInput> | UsuarioCreateWithoutTipoRolInput[] | UsuarioUncheckedCreateWithoutTipoRolInput[]
    connectOrCreate?: UsuarioCreateOrConnectWithoutTipoRolInput | UsuarioCreateOrConnectWithoutTipoRolInput[]
    upsert?: UsuarioUpsertWithWhereUniqueWithoutTipoRolInput | UsuarioUpsertWithWhereUniqueWithoutTipoRolInput[]
    createMany?: UsuarioCreateManyTipoRolInputEnvelope
    set?: UsuarioWhereUniqueInput | UsuarioWhereUniqueInput[]
    disconnect?: UsuarioWhereUniqueInput | UsuarioWhereUniqueInput[]
    delete?: UsuarioWhereUniqueInput | UsuarioWhereUniqueInput[]
    connect?: UsuarioWhereUniqueInput | UsuarioWhereUniqueInput[]
    update?: UsuarioUpdateWithWhereUniqueWithoutTipoRolInput | UsuarioUpdateWithWhereUniqueWithoutTipoRolInput[]
    updateMany?: UsuarioUpdateManyWithWhereWithoutTipoRolInput | UsuarioUpdateManyWithWhereWithoutTipoRolInput[]
    deleteMany?: UsuarioScalarWhereInput | UsuarioScalarWhereInput[]
  }

  export type EnumNivelAlertaFieldUpdateOperationsInput = {
    set?: $Enums.NivelAlerta
  }

  export type EspecieParametroCreateNestedManyWithoutParametroInput = {
    create?: XOR<EspecieParametroCreateWithoutParametroInput, EspecieParametroUncheckedCreateWithoutParametroInput> | EspecieParametroCreateWithoutParametroInput[] | EspecieParametroUncheckedCreateWithoutParametroInput[]
    connectOrCreate?: EspecieParametroCreateOrConnectWithoutParametroInput | EspecieParametroCreateOrConnectWithoutParametroInput[]
    createMany?: EspecieParametroCreateManyParametroInputEnvelope
    connect?: EspecieParametroWhereUniqueInput | EspecieParametroWhereUniqueInput[]
  }

  export type EspecieParametroUncheckedCreateNestedManyWithoutParametroInput = {
    create?: XOR<EspecieParametroCreateWithoutParametroInput, EspecieParametroUncheckedCreateWithoutParametroInput> | EspecieParametroCreateWithoutParametroInput[] | EspecieParametroUncheckedCreateWithoutParametroInput[]
    connectOrCreate?: EspecieParametroCreateOrConnectWithoutParametroInput | EspecieParametroCreateOrConnectWithoutParametroInput[]
    createMany?: EspecieParametroCreateManyParametroInputEnvelope
    connect?: EspecieParametroWhereUniqueInput | EspecieParametroWhereUniqueInput[]
  }

  export type EspecieParametroUpdateManyWithoutParametroNestedInput = {
    create?: XOR<EspecieParametroCreateWithoutParametroInput, EspecieParametroUncheckedCreateWithoutParametroInput> | EspecieParametroCreateWithoutParametroInput[] | EspecieParametroUncheckedCreateWithoutParametroInput[]
    connectOrCreate?: EspecieParametroCreateOrConnectWithoutParametroInput | EspecieParametroCreateOrConnectWithoutParametroInput[]
    upsert?: EspecieParametroUpsertWithWhereUniqueWithoutParametroInput | EspecieParametroUpsertWithWhereUniqueWithoutParametroInput[]
    createMany?: EspecieParametroCreateManyParametroInputEnvelope
    set?: EspecieParametroWhereUniqueInput | EspecieParametroWhereUniqueInput[]
    disconnect?: EspecieParametroWhereUniqueInput | EspecieParametroWhereUniqueInput[]
    delete?: EspecieParametroWhereUniqueInput | EspecieParametroWhereUniqueInput[]
    connect?: EspecieParametroWhereUniqueInput | EspecieParametroWhereUniqueInput[]
    update?: EspecieParametroUpdateWithWhereUniqueWithoutParametroInput | EspecieParametroUpdateWithWhereUniqueWithoutParametroInput[]
    updateMany?: EspecieParametroUpdateManyWithWhereWithoutParametroInput | EspecieParametroUpdateManyWithWhereWithoutParametroInput[]
    deleteMany?: EspecieParametroScalarWhereInput | EspecieParametroScalarWhereInput[]
  }

  export type EspecieParametroUncheckedUpdateManyWithoutParametroNestedInput = {
    create?: XOR<EspecieParametroCreateWithoutParametroInput, EspecieParametroUncheckedCreateWithoutParametroInput> | EspecieParametroCreateWithoutParametroInput[] | EspecieParametroUncheckedCreateWithoutParametroInput[]
    connectOrCreate?: EspecieParametroCreateOrConnectWithoutParametroInput | EspecieParametroCreateOrConnectWithoutParametroInput[]
    upsert?: EspecieParametroUpsertWithWhereUniqueWithoutParametroInput | EspecieParametroUpsertWithWhereUniqueWithoutParametroInput[]
    createMany?: EspecieParametroCreateManyParametroInputEnvelope
    set?: EspecieParametroWhereUniqueInput | EspecieParametroWhereUniqueInput[]
    disconnect?: EspecieParametroWhereUniqueInput | EspecieParametroWhereUniqueInput[]
    delete?: EspecieParametroWhereUniqueInput | EspecieParametroWhereUniqueInput[]
    connect?: EspecieParametroWhereUniqueInput | EspecieParametroWhereUniqueInput[]
    update?: EspecieParametroUpdateWithWhereUniqueWithoutParametroInput | EspecieParametroUpdateWithWhereUniqueWithoutParametroInput[]
    updateMany?: EspecieParametroUpdateManyWithWhereWithoutParametroInput | EspecieParametroUpdateManyWithWhereWithoutParametroInput[]
    deleteMany?: EspecieParametroScalarWhereInput | EspecieParametroScalarWhereInput[]
  }

  export type EspecieInstaladaCreateNestedManyWithoutCatalogoEspecieInput = {
    create?: XOR<EspecieInstaladaCreateWithoutCatalogoEspecieInput, EspecieInstaladaUncheckedCreateWithoutCatalogoEspecieInput> | EspecieInstaladaCreateWithoutCatalogoEspecieInput[] | EspecieInstaladaUncheckedCreateWithoutCatalogoEspecieInput[]
    connectOrCreate?: EspecieInstaladaCreateOrConnectWithoutCatalogoEspecieInput | EspecieInstaladaCreateOrConnectWithoutCatalogoEspecieInput[]
    createMany?: EspecieInstaladaCreateManyCatalogoEspecieInputEnvelope
    connect?: EspecieInstaladaWhereUniqueInput | EspecieInstaladaWhereUniqueInput[]
  }

  export type EspecieInstaladaUncheckedCreateNestedManyWithoutCatalogoEspecieInput = {
    create?: XOR<EspecieInstaladaCreateWithoutCatalogoEspecieInput, EspecieInstaladaUncheckedCreateWithoutCatalogoEspecieInput> | EspecieInstaladaCreateWithoutCatalogoEspecieInput[] | EspecieInstaladaUncheckedCreateWithoutCatalogoEspecieInput[]
    connectOrCreate?: EspecieInstaladaCreateOrConnectWithoutCatalogoEspecieInput | EspecieInstaladaCreateOrConnectWithoutCatalogoEspecieInput[]
    createMany?: EspecieInstaladaCreateManyCatalogoEspecieInputEnvelope
    connect?: EspecieInstaladaWhereUniqueInput | EspecieInstaladaWhereUniqueInput[]
  }

  export type EspecieInstaladaUpdateManyWithoutCatalogoEspecieNestedInput = {
    create?: XOR<EspecieInstaladaCreateWithoutCatalogoEspecieInput, EspecieInstaladaUncheckedCreateWithoutCatalogoEspecieInput> | EspecieInstaladaCreateWithoutCatalogoEspecieInput[] | EspecieInstaladaUncheckedCreateWithoutCatalogoEspecieInput[]
    connectOrCreate?: EspecieInstaladaCreateOrConnectWithoutCatalogoEspecieInput | EspecieInstaladaCreateOrConnectWithoutCatalogoEspecieInput[]
    upsert?: EspecieInstaladaUpsertWithWhereUniqueWithoutCatalogoEspecieInput | EspecieInstaladaUpsertWithWhereUniqueWithoutCatalogoEspecieInput[]
    createMany?: EspecieInstaladaCreateManyCatalogoEspecieInputEnvelope
    set?: EspecieInstaladaWhereUniqueInput | EspecieInstaladaWhereUniqueInput[]
    disconnect?: EspecieInstaladaWhereUniqueInput | EspecieInstaladaWhereUniqueInput[]
    delete?: EspecieInstaladaWhereUniqueInput | EspecieInstaladaWhereUniqueInput[]
    connect?: EspecieInstaladaWhereUniqueInput | EspecieInstaladaWhereUniqueInput[]
    update?: EspecieInstaladaUpdateWithWhereUniqueWithoutCatalogoEspecieInput | EspecieInstaladaUpdateWithWhereUniqueWithoutCatalogoEspecieInput[]
    updateMany?: EspecieInstaladaUpdateManyWithWhereWithoutCatalogoEspecieInput | EspecieInstaladaUpdateManyWithWhereWithoutCatalogoEspecieInput[]
    deleteMany?: EspecieInstaladaScalarWhereInput | EspecieInstaladaScalarWhereInput[]
  }

  export type EspecieInstaladaUncheckedUpdateManyWithoutCatalogoEspecieNestedInput = {
    create?: XOR<EspecieInstaladaCreateWithoutCatalogoEspecieInput, EspecieInstaladaUncheckedCreateWithoutCatalogoEspecieInput> | EspecieInstaladaCreateWithoutCatalogoEspecieInput[] | EspecieInstaladaUncheckedCreateWithoutCatalogoEspecieInput[]
    connectOrCreate?: EspecieInstaladaCreateOrConnectWithoutCatalogoEspecieInput | EspecieInstaladaCreateOrConnectWithoutCatalogoEspecieInput[]
    upsert?: EspecieInstaladaUpsertWithWhereUniqueWithoutCatalogoEspecieInput | EspecieInstaladaUpsertWithWhereUniqueWithoutCatalogoEspecieInput[]
    createMany?: EspecieInstaladaCreateManyCatalogoEspecieInputEnvelope
    set?: EspecieInstaladaWhereUniqueInput | EspecieInstaladaWhereUniqueInput[]
    disconnect?: EspecieInstaladaWhereUniqueInput | EspecieInstaladaWhereUniqueInput[]
    delete?: EspecieInstaladaWhereUniqueInput | EspecieInstaladaWhereUniqueInput[]
    connect?: EspecieInstaladaWhereUniqueInput | EspecieInstaladaWhereUniqueInput[]
    update?: EspecieInstaladaUpdateWithWhereUniqueWithoutCatalogoEspecieInput | EspecieInstaladaUpdateWithWhereUniqueWithoutCatalogoEspecieInput[]
    updateMany?: EspecieInstaladaUpdateManyWithWhereWithoutCatalogoEspecieInput | EspecieInstaladaUpdateManyWithWhereWithoutCatalogoEspecieInput[]
    deleteMany?: EspecieInstaladaScalarWhereInput | EspecieInstaladaScalarWhereInput[]
  }

  export type CatalogoEspecieCreateNestedOneWithoutEspeciesInstaladasInput = {
    create?: XOR<CatalogoEspecieCreateWithoutEspeciesInstaladasInput, CatalogoEspecieUncheckedCreateWithoutEspeciesInstaladasInput>
    connectOrCreate?: CatalogoEspecieCreateOrConnectWithoutEspeciesInstaladasInput
    connect?: CatalogoEspecieWhereUniqueInput
  }

  export type EspecieTrackingCreateNestedManyWithoutEspecieInstaladaInput = {
    create?: XOR<EspecieTrackingCreateWithoutEspecieInstaladaInput, EspecieTrackingUncheckedCreateWithoutEspecieInstaladaInput> | EspecieTrackingCreateWithoutEspecieInstaladaInput[] | EspecieTrackingUncheckedCreateWithoutEspecieInstaladaInput[]
    connectOrCreate?: EspecieTrackingCreateOrConnectWithoutEspecieInstaladaInput | EspecieTrackingCreateOrConnectWithoutEspecieInstaladaInput[]
    createMany?: EspecieTrackingCreateManyEspecieInstaladaInputEnvelope
    connect?: EspecieTrackingWhereUniqueInput | EspecieTrackingWhereUniqueInput[]
  }

  export type EspecieTrackingUncheckedCreateNestedManyWithoutEspecieInstaladaInput = {
    create?: XOR<EspecieTrackingCreateWithoutEspecieInstaladaInput, EspecieTrackingUncheckedCreateWithoutEspecieInstaladaInput> | EspecieTrackingCreateWithoutEspecieInstaladaInput[] | EspecieTrackingUncheckedCreateWithoutEspecieInstaladaInput[]
    connectOrCreate?: EspecieTrackingCreateOrConnectWithoutEspecieInstaladaInput | EspecieTrackingCreateOrConnectWithoutEspecieInstaladaInput[]
    createMany?: EspecieTrackingCreateManyEspecieInstaladaInputEnvelope
    connect?: EspecieTrackingWhereUniqueInput | EspecieTrackingWhereUniqueInput[]
  }

  export type NullableIntFieldUpdateOperationsInput = {
    set?: number | null
    increment?: number
    decrement?: number
    multiply?: number
    divide?: number
  }

  export type CatalogoEspecieUpdateOneRequiredWithoutEspeciesInstaladasNestedInput = {
    create?: XOR<CatalogoEspecieCreateWithoutEspeciesInstaladasInput, CatalogoEspecieUncheckedCreateWithoutEspeciesInstaladasInput>
    connectOrCreate?: CatalogoEspecieCreateOrConnectWithoutEspeciesInstaladasInput
    upsert?: CatalogoEspecieUpsertWithoutEspeciesInstaladasInput
    connect?: CatalogoEspecieWhereUniqueInput
    update?: XOR<XOR<CatalogoEspecieUpdateToOneWithWhereWithoutEspeciesInstaladasInput, CatalogoEspecieUpdateWithoutEspeciesInstaladasInput>, CatalogoEspecieUncheckedUpdateWithoutEspeciesInstaladasInput>
  }

  export type EspecieTrackingUpdateManyWithoutEspecieInstaladaNestedInput = {
    create?: XOR<EspecieTrackingCreateWithoutEspecieInstaladaInput, EspecieTrackingUncheckedCreateWithoutEspecieInstaladaInput> | EspecieTrackingCreateWithoutEspecieInstaladaInput[] | EspecieTrackingUncheckedCreateWithoutEspecieInstaladaInput[]
    connectOrCreate?: EspecieTrackingCreateOrConnectWithoutEspecieInstaladaInput | EspecieTrackingCreateOrConnectWithoutEspecieInstaladaInput[]
    upsert?: EspecieTrackingUpsertWithWhereUniqueWithoutEspecieInstaladaInput | EspecieTrackingUpsertWithWhereUniqueWithoutEspecieInstaladaInput[]
    createMany?: EspecieTrackingCreateManyEspecieInstaladaInputEnvelope
    set?: EspecieTrackingWhereUniqueInput | EspecieTrackingWhereUniqueInput[]
    disconnect?: EspecieTrackingWhereUniqueInput | EspecieTrackingWhereUniqueInput[]
    delete?: EspecieTrackingWhereUniqueInput | EspecieTrackingWhereUniqueInput[]
    connect?: EspecieTrackingWhereUniqueInput | EspecieTrackingWhereUniqueInput[]
    update?: EspecieTrackingUpdateWithWhereUniqueWithoutEspecieInstaladaInput | EspecieTrackingUpdateWithWhereUniqueWithoutEspecieInstaladaInput[]
    updateMany?: EspecieTrackingUpdateManyWithWhereWithoutEspecieInstaladaInput | EspecieTrackingUpdateManyWithWhereWithoutEspecieInstaladaInput[]
    deleteMany?: EspecieTrackingScalarWhereInput | EspecieTrackingScalarWhereInput[]
  }

  export type EspecieTrackingUncheckedUpdateManyWithoutEspecieInstaladaNestedInput = {
    create?: XOR<EspecieTrackingCreateWithoutEspecieInstaladaInput, EspecieTrackingUncheckedCreateWithoutEspecieInstaladaInput> | EspecieTrackingCreateWithoutEspecieInstaladaInput[] | EspecieTrackingUncheckedCreateWithoutEspecieInstaladaInput[]
    connectOrCreate?: EspecieTrackingCreateOrConnectWithoutEspecieInstaladaInput | EspecieTrackingCreateOrConnectWithoutEspecieInstaladaInput[]
    upsert?: EspecieTrackingUpsertWithWhereUniqueWithoutEspecieInstaladaInput | EspecieTrackingUpsertWithWhereUniqueWithoutEspecieInstaladaInput[]
    createMany?: EspecieTrackingCreateManyEspecieInstaladaInputEnvelope
    set?: EspecieTrackingWhereUniqueInput | EspecieTrackingWhereUniqueInput[]
    disconnect?: EspecieTrackingWhereUniqueInput | EspecieTrackingWhereUniqueInput[]
    delete?: EspecieTrackingWhereUniqueInput | EspecieTrackingWhereUniqueInput[]
    connect?: EspecieTrackingWhereUniqueInput | EspecieTrackingWhereUniqueInput[]
    update?: EspecieTrackingUpdateWithWhereUniqueWithoutEspecieInstaladaInput | EspecieTrackingUpdateWithWhereUniqueWithoutEspecieInstaladaInput[]
    updateMany?: EspecieTrackingUpdateManyWithWhereWithoutEspecieInstaladaInput | EspecieTrackingUpdateManyWithWhereWithoutEspecieInstaladaInput[]
    deleteMany?: EspecieTrackingScalarWhereInput | EspecieTrackingScalarWhereInput[]
  }

  export type EspecieInstaladaCreateNestedOneWithoutTrackingsInput = {
    create?: XOR<EspecieInstaladaCreateWithoutTrackingsInput, EspecieInstaladaUncheckedCreateWithoutTrackingsInput>
    connectOrCreate?: EspecieInstaladaCreateOrConnectWithoutTrackingsInput
    connect?: EspecieInstaladaWhereUniqueInput
  }

  export type EspecieInstaladaUpdateOneRequiredWithoutTrackingsNestedInput = {
    create?: XOR<EspecieInstaladaCreateWithoutTrackingsInput, EspecieInstaladaUncheckedCreateWithoutTrackingsInput>
    connectOrCreate?: EspecieInstaladaCreateOrConnectWithoutTrackingsInput
    upsert?: EspecieInstaladaUpsertWithoutTrackingsInput
    connect?: EspecieInstaladaWhereUniqueInput
    update?: XOR<XOR<EspecieInstaladaUpdateToOneWithWhereWithoutTrackingsInput, EspecieInstaladaUpdateWithoutTrackingsInput>, EspecieInstaladaUncheckedUpdateWithoutTrackingsInput>
  }

  export type ParametroCreateNestedOneWithoutEspecieParametrosInput = {
    create?: XOR<ParametroCreateWithoutEspecieParametrosInput, ParametroUncheckedCreateWithoutEspecieParametrosInput>
    connectOrCreate?: ParametroCreateOrConnectWithoutEspecieParametrosInput
    connect?: ParametroWhereUniqueInput
  }

  export type ParametroUpdateOneRequiredWithoutEspecieParametrosNestedInput = {
    create?: XOR<ParametroCreateWithoutEspecieParametrosInput, ParametroUncheckedCreateWithoutEspecieParametrosInput>
    connectOrCreate?: ParametroCreateOrConnectWithoutEspecieParametrosInput
    upsert?: ParametroUpsertWithoutEspecieParametrosInput
    connect?: ParametroWhereUniqueInput
    update?: XOR<XOR<ParametroUpdateToOneWithWhereWithoutEspecieParametrosInput, ParametroUpdateWithoutEspecieParametrosInput>, ParametroUncheckedUpdateWithoutEspecieParametrosInput>
  }

  export type NestedIntFilter<$PrismaModel = never> = {
    equals?: number | IntFieldRefInput<$PrismaModel>
    in?: number[]
    notIn?: number[]
    lt?: number | IntFieldRefInput<$PrismaModel>
    lte?: number | IntFieldRefInput<$PrismaModel>
    gt?: number | IntFieldRefInput<$PrismaModel>
    gte?: number | IntFieldRefInput<$PrismaModel>
    not?: NestedIntFilter<$PrismaModel> | number
  }

  export type NestedStringFilter<$PrismaModel = never> = {
    equals?: string | StringFieldRefInput<$PrismaModel>
    in?: string[]
    notIn?: string[]
    lt?: string | StringFieldRefInput<$PrismaModel>
    lte?: string | StringFieldRefInput<$PrismaModel>
    gt?: string | StringFieldRefInput<$PrismaModel>
    gte?: string | StringFieldRefInput<$PrismaModel>
    contains?: string | StringFieldRefInput<$PrismaModel>
    startsWith?: string | StringFieldRefInput<$PrismaModel>
    endsWith?: string | StringFieldRefInput<$PrismaModel>
    not?: NestedStringFilter<$PrismaModel> | string
  }

  export type NestedDateTimeFilter<$PrismaModel = never> = {
    equals?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    in?: Date[] | string[]
    notIn?: Date[] | string[]
    lt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    lte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    not?: NestedDateTimeFilter<$PrismaModel> | Date | string
  }

  export type NestedIntWithAggregatesFilter<$PrismaModel = never> = {
    equals?: number | IntFieldRefInput<$PrismaModel>
    in?: number[]
    notIn?: number[]
    lt?: number | IntFieldRefInput<$PrismaModel>
    lte?: number | IntFieldRefInput<$PrismaModel>
    gt?: number | IntFieldRefInput<$PrismaModel>
    gte?: number | IntFieldRefInput<$PrismaModel>
    not?: NestedIntWithAggregatesFilter<$PrismaModel> | number
    _count?: NestedIntFilter<$PrismaModel>
    _avg?: NestedFloatFilter<$PrismaModel>
    _sum?: NestedIntFilter<$PrismaModel>
    _min?: NestedIntFilter<$PrismaModel>
    _max?: NestedIntFilter<$PrismaModel>
  }

  export type NestedFloatFilter<$PrismaModel = never> = {
    equals?: number | FloatFieldRefInput<$PrismaModel>
    in?: number[]
    notIn?: number[]
    lt?: number | FloatFieldRefInput<$PrismaModel>
    lte?: number | FloatFieldRefInput<$PrismaModel>
    gt?: number | FloatFieldRefInput<$PrismaModel>
    gte?: number | FloatFieldRefInput<$PrismaModel>
    not?: NestedFloatFilter<$PrismaModel> | number
  }

  export type NestedStringWithAggregatesFilter<$PrismaModel = never> = {
    equals?: string | StringFieldRefInput<$PrismaModel>
    in?: string[]
    notIn?: string[]
    lt?: string | StringFieldRefInput<$PrismaModel>
    lte?: string | StringFieldRefInput<$PrismaModel>
    gt?: string | StringFieldRefInput<$PrismaModel>
    gte?: string | StringFieldRefInput<$PrismaModel>
    contains?: string | StringFieldRefInput<$PrismaModel>
    startsWith?: string | StringFieldRefInput<$PrismaModel>
    endsWith?: string | StringFieldRefInput<$PrismaModel>
    not?: NestedStringWithAggregatesFilter<$PrismaModel> | string
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedStringFilter<$PrismaModel>
    _max?: NestedStringFilter<$PrismaModel>
  }

  export type NestedDateTimeWithAggregatesFilter<$PrismaModel = never> = {
    equals?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    in?: Date[] | string[]
    notIn?: Date[] | string[]
    lt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    lte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    not?: NestedDateTimeWithAggregatesFilter<$PrismaModel> | Date | string
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedDateTimeFilter<$PrismaModel>
    _max?: NestedDateTimeFilter<$PrismaModel>
  }

  export type NestedStringNullableFilter<$PrismaModel = never> = {
    equals?: string | StringFieldRefInput<$PrismaModel> | null
    in?: string[] | null
    notIn?: string[] | null
    lt?: string | StringFieldRefInput<$PrismaModel>
    lte?: string | StringFieldRefInput<$PrismaModel>
    gt?: string | StringFieldRefInput<$PrismaModel>
    gte?: string | StringFieldRefInput<$PrismaModel>
    contains?: string | StringFieldRefInput<$PrismaModel>
    startsWith?: string | StringFieldRefInput<$PrismaModel>
    endsWith?: string | StringFieldRefInput<$PrismaModel>
    not?: NestedStringNullableFilter<$PrismaModel> | string | null
  }

  export type NestedEnumTipoMedidaNullableFilter<$PrismaModel = never> = {
    equals?: $Enums.TipoMedida | EnumTipoMedidaFieldRefInput<$PrismaModel> | null
    in?: $Enums.TipoMedida[] | null
    notIn?: $Enums.TipoMedida[] | null
    not?: NestedEnumTipoMedidaNullableFilter<$PrismaModel> | $Enums.TipoMedida | null
  }

  export type NestedDecimalNullableFilter<$PrismaModel = never> = {
    equals?: Decimal | DecimalJsLike | number | string | DecimalFieldRefInput<$PrismaModel> | null
    in?: Decimal[] | DecimalJsLike[] | number[] | string[] | null
    notIn?: Decimal[] | DecimalJsLike[] | number[] | string[] | null
    lt?: Decimal | DecimalJsLike | number | string | DecimalFieldRefInput<$PrismaModel>
    lte?: Decimal | DecimalJsLike | number | string | DecimalFieldRefInput<$PrismaModel>
    gt?: Decimal | DecimalJsLike | number | string | DecimalFieldRefInput<$PrismaModel>
    gte?: Decimal | DecimalJsLike | number | string | DecimalFieldRefInput<$PrismaModel>
    not?: NestedDecimalNullableFilter<$PrismaModel> | Decimal | DecimalJsLike | number | string | null
  }

  export type NestedStringNullableWithAggregatesFilter<$PrismaModel = never> = {
    equals?: string | StringFieldRefInput<$PrismaModel> | null
    in?: string[] | null
    notIn?: string[] | null
    lt?: string | StringFieldRefInput<$PrismaModel>
    lte?: string | StringFieldRefInput<$PrismaModel>
    gt?: string | StringFieldRefInput<$PrismaModel>
    gte?: string | StringFieldRefInput<$PrismaModel>
    contains?: string | StringFieldRefInput<$PrismaModel>
    startsWith?: string | StringFieldRefInput<$PrismaModel>
    endsWith?: string | StringFieldRefInput<$PrismaModel>
    not?: NestedStringNullableWithAggregatesFilter<$PrismaModel> | string | null
    _count?: NestedIntNullableFilter<$PrismaModel>
    _min?: NestedStringNullableFilter<$PrismaModel>
    _max?: NestedStringNullableFilter<$PrismaModel>
  }

  export type NestedIntNullableFilter<$PrismaModel = never> = {
    equals?: number | IntFieldRefInput<$PrismaModel> | null
    in?: number[] | null
    notIn?: number[] | null
    lt?: number | IntFieldRefInput<$PrismaModel>
    lte?: number | IntFieldRefInput<$PrismaModel>
    gt?: number | IntFieldRefInput<$PrismaModel>
    gte?: number | IntFieldRefInput<$PrismaModel>
    not?: NestedIntNullableFilter<$PrismaModel> | number | null
  }

  export type NestedEnumTipoMedidaNullableWithAggregatesFilter<$PrismaModel = never> = {
    equals?: $Enums.TipoMedida | EnumTipoMedidaFieldRefInput<$PrismaModel> | null
    in?: $Enums.TipoMedida[] | null
    notIn?: $Enums.TipoMedida[] | null
    not?: NestedEnumTipoMedidaNullableWithAggregatesFilter<$PrismaModel> | $Enums.TipoMedida | null
    _count?: NestedIntNullableFilter<$PrismaModel>
    _min?: NestedEnumTipoMedidaNullableFilter<$PrismaModel>
    _max?: NestedEnumTipoMedidaNullableFilter<$PrismaModel>
  }

  export type NestedDecimalNullableWithAggregatesFilter<$PrismaModel = never> = {
    equals?: Decimal | DecimalJsLike | number | string | DecimalFieldRefInput<$PrismaModel> | null
    in?: Decimal[] | DecimalJsLike[] | number[] | string[] | null
    notIn?: Decimal[] | DecimalJsLike[] | number[] | string[] | null
    lt?: Decimal | DecimalJsLike | number | string | DecimalFieldRefInput<$PrismaModel>
    lte?: Decimal | DecimalJsLike | number | string | DecimalFieldRefInput<$PrismaModel>
    gt?: Decimal | DecimalJsLike | number | string | DecimalFieldRefInput<$PrismaModel>
    gte?: Decimal | DecimalJsLike | number | string | DecimalFieldRefInput<$PrismaModel>
    not?: NestedDecimalNullableWithAggregatesFilter<$PrismaModel> | Decimal | DecimalJsLike | number | string | null
    _count?: NestedIntNullableFilter<$PrismaModel>
    _avg?: NestedDecimalNullableFilter<$PrismaModel>
    _sum?: NestedDecimalNullableFilter<$PrismaModel>
    _min?: NestedDecimalNullableFilter<$PrismaModel>
    _max?: NestedDecimalNullableFilter<$PrismaModel>
  }

  export type NestedDateTimeNullableFilter<$PrismaModel = never> = {
    equals?: Date | string | DateTimeFieldRefInput<$PrismaModel> | null
    in?: Date[] | string[] | null
    notIn?: Date[] | string[] | null
    lt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    lte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    not?: NestedDateTimeNullableFilter<$PrismaModel> | Date | string | null
  }

  export type NestedDateTimeNullableWithAggregatesFilter<$PrismaModel = never> = {
    equals?: Date | string | DateTimeFieldRefInput<$PrismaModel> | null
    in?: Date[] | string[] | null
    notIn?: Date[] | string[] | null
    lt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    lte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    not?: NestedDateTimeNullableWithAggregatesFilter<$PrismaModel> | Date | string | null
    _count?: NestedIntNullableFilter<$PrismaModel>
    _min?: NestedDateTimeNullableFilter<$PrismaModel>
    _max?: NestedDateTimeNullableFilter<$PrismaModel>
  }

  export type NestedBigIntFilter<$PrismaModel = never> = {
    equals?: bigint | number | BigIntFieldRefInput<$PrismaModel>
    in?: bigint[] | number[]
    notIn?: bigint[] | number[]
    lt?: bigint | number | BigIntFieldRefInput<$PrismaModel>
    lte?: bigint | number | BigIntFieldRefInput<$PrismaModel>
    gt?: bigint | number | BigIntFieldRefInput<$PrismaModel>
    gte?: bigint | number | BigIntFieldRefInput<$PrismaModel>
    not?: NestedBigIntFilter<$PrismaModel> | bigint | number
  }

  export type NestedDecimalFilter<$PrismaModel = never> = {
    equals?: Decimal | DecimalJsLike | number | string | DecimalFieldRefInput<$PrismaModel>
    in?: Decimal[] | DecimalJsLike[] | number[] | string[]
    notIn?: Decimal[] | DecimalJsLike[] | number[] | string[]
    lt?: Decimal | DecimalJsLike | number | string | DecimalFieldRefInput<$PrismaModel>
    lte?: Decimal | DecimalJsLike | number | string | DecimalFieldRefInput<$PrismaModel>
    gt?: Decimal | DecimalJsLike | number | string | DecimalFieldRefInput<$PrismaModel>
    gte?: Decimal | DecimalJsLike | number | string | DecimalFieldRefInput<$PrismaModel>
    not?: NestedDecimalFilter<$PrismaModel> | Decimal | DecimalJsLike | number | string
  }

  export type NestedBigIntWithAggregatesFilter<$PrismaModel = never> = {
    equals?: bigint | number | BigIntFieldRefInput<$PrismaModel>
    in?: bigint[] | number[]
    notIn?: bigint[] | number[]
    lt?: bigint | number | BigIntFieldRefInput<$PrismaModel>
    lte?: bigint | number | BigIntFieldRefInput<$PrismaModel>
    gt?: bigint | number | BigIntFieldRefInput<$PrismaModel>
    gte?: bigint | number | BigIntFieldRefInput<$PrismaModel>
    not?: NestedBigIntWithAggregatesFilter<$PrismaModel> | bigint | number
    _count?: NestedIntFilter<$PrismaModel>
    _avg?: NestedFloatFilter<$PrismaModel>
    _sum?: NestedBigIntFilter<$PrismaModel>
    _min?: NestedBigIntFilter<$PrismaModel>
    _max?: NestedBigIntFilter<$PrismaModel>
  }

  export type NestedDecimalWithAggregatesFilter<$PrismaModel = never> = {
    equals?: Decimal | DecimalJsLike | number | string | DecimalFieldRefInput<$PrismaModel>
    in?: Decimal[] | DecimalJsLike[] | number[] | string[]
    notIn?: Decimal[] | DecimalJsLike[] | number[] | string[]
    lt?: Decimal | DecimalJsLike | number | string | DecimalFieldRefInput<$PrismaModel>
    lte?: Decimal | DecimalJsLike | number | string | DecimalFieldRefInput<$PrismaModel>
    gt?: Decimal | DecimalJsLike | number | string | DecimalFieldRefInput<$PrismaModel>
    gte?: Decimal | DecimalJsLike | number | string | DecimalFieldRefInput<$PrismaModel>
    not?: NestedDecimalWithAggregatesFilter<$PrismaModel> | Decimal | DecimalJsLike | number | string
    _count?: NestedIntFilter<$PrismaModel>
    _avg?: NestedDecimalFilter<$PrismaModel>
    _sum?: NestedDecimalFilter<$PrismaModel>
    _min?: NestedDecimalFilter<$PrismaModel>
    _max?: NestedDecimalFilter<$PrismaModel>
  }

  export type NestedBoolFilter<$PrismaModel = never> = {
    equals?: boolean | BooleanFieldRefInput<$PrismaModel>
    not?: NestedBoolFilter<$PrismaModel> | boolean
  }

  export type NestedBoolWithAggregatesFilter<$PrismaModel = never> = {
    equals?: boolean | BooleanFieldRefInput<$PrismaModel>
    not?: NestedBoolWithAggregatesFilter<$PrismaModel> | boolean
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedBoolFilter<$PrismaModel>
    _max?: NestedBoolFilter<$PrismaModel>
  }

  export type NestedEnumNivelAlertaFilter<$PrismaModel = never> = {
    equals?: $Enums.NivelAlerta | EnumNivelAlertaFieldRefInput<$PrismaModel>
    in?: $Enums.NivelAlerta[]
    notIn?: $Enums.NivelAlerta[]
    not?: NestedEnumNivelAlertaFilter<$PrismaModel> | $Enums.NivelAlerta
  }

  export type NestedEnumNivelAlertaWithAggregatesFilter<$PrismaModel = never> = {
    equals?: $Enums.NivelAlerta | EnumNivelAlertaFieldRefInput<$PrismaModel>
    in?: $Enums.NivelAlerta[]
    notIn?: $Enums.NivelAlerta[]
    not?: NestedEnumNivelAlertaWithAggregatesFilter<$PrismaModel> | $Enums.NivelAlerta
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedEnumNivelAlertaFilter<$PrismaModel>
    _max?: NestedEnumNivelAlertaFilter<$PrismaModel>
  }

  export type NestedIntNullableWithAggregatesFilter<$PrismaModel = never> = {
    equals?: number | IntFieldRefInput<$PrismaModel> | null
    in?: number[] | null
    notIn?: number[] | null
    lt?: number | IntFieldRefInput<$PrismaModel>
    lte?: number | IntFieldRefInput<$PrismaModel>
    gt?: number | IntFieldRefInput<$PrismaModel>
    gte?: number | IntFieldRefInput<$PrismaModel>
    not?: NestedIntNullableWithAggregatesFilter<$PrismaModel> | number | null
    _count?: NestedIntNullableFilter<$PrismaModel>
    _avg?: NestedFloatNullableFilter<$PrismaModel>
    _sum?: NestedIntNullableFilter<$PrismaModel>
    _min?: NestedIntNullableFilter<$PrismaModel>
    _max?: NestedIntNullableFilter<$PrismaModel>
  }

  export type NestedFloatNullableFilter<$PrismaModel = never> = {
    equals?: number | FloatFieldRefInput<$PrismaModel> | null
    in?: number[] | null
    notIn?: number[] | null
    lt?: number | FloatFieldRefInput<$PrismaModel>
    lte?: number | FloatFieldRefInput<$PrismaModel>
    gt?: number | FloatFieldRefInput<$PrismaModel>
    gte?: number | FloatFieldRefInput<$PrismaModel>
    not?: NestedFloatNullableFilter<$PrismaModel> | number | null
  }

  export type OrganizacionSucursalCreateWithoutOrganizacionInput = {
    nombre_sucursal: string
    estado: string
    fecha_creacion?: Date | string
    instalaciones?: InstalacionCreateNestedManyWithoutSucursalInput
  }

  export type OrganizacionSucursalUncheckedCreateWithoutOrganizacionInput = {
    id_organizacion_sucursal?: number
    nombre_sucursal: string
    estado: string
    fecha_creacion?: Date | string
    instalaciones?: InstalacionUncheckedCreateNestedManyWithoutSucursalInput
  }

  export type OrganizacionSucursalCreateOrConnectWithoutOrganizacionInput = {
    where: OrganizacionSucursalWhereUniqueInput
    create: XOR<OrganizacionSucursalCreateWithoutOrganizacionInput, OrganizacionSucursalUncheckedCreateWithoutOrganizacionInput>
  }

  export type OrganizacionSucursalCreateManyOrganizacionInputEnvelope = {
    data: OrganizacionSucursalCreateManyOrganizacionInput | OrganizacionSucursalCreateManyOrganizacionInput[]
    skipDuplicates?: boolean
  }

  export type OrganizacionSucursalUpsertWithWhereUniqueWithoutOrganizacionInput = {
    where: OrganizacionSucursalWhereUniqueInput
    update: XOR<OrganizacionSucursalUpdateWithoutOrganizacionInput, OrganizacionSucursalUncheckedUpdateWithoutOrganizacionInput>
    create: XOR<OrganizacionSucursalCreateWithoutOrganizacionInput, OrganizacionSucursalUncheckedCreateWithoutOrganizacionInput>
  }

  export type OrganizacionSucursalUpdateWithWhereUniqueWithoutOrganizacionInput = {
    where: OrganizacionSucursalWhereUniqueInput
    data: XOR<OrganizacionSucursalUpdateWithoutOrganizacionInput, OrganizacionSucursalUncheckedUpdateWithoutOrganizacionInput>
  }

  export type OrganizacionSucursalUpdateManyWithWhereWithoutOrganizacionInput = {
    where: OrganizacionSucursalScalarWhereInput
    data: XOR<OrganizacionSucursalUpdateManyMutationInput, OrganizacionSucursalUncheckedUpdateManyWithoutOrganizacionInput>
  }

  export type OrganizacionSucursalScalarWhereInput = {
    AND?: OrganizacionSucursalScalarWhereInput | OrganizacionSucursalScalarWhereInput[]
    OR?: OrganizacionSucursalScalarWhereInput[]
    NOT?: OrganizacionSucursalScalarWhereInput | OrganizacionSucursalScalarWhereInput[]
    id_organizacion_sucursal?: IntFilter<"OrganizacionSucursal"> | number
    id_organizacion?: IntFilter<"OrganizacionSucursal"> | number
    nombre_sucursal?: StringFilter<"OrganizacionSucursal"> | string
    estado?: StringFilter<"OrganizacionSucursal"> | string
    fecha_creacion?: DateTimeFilter<"OrganizacionSucursal"> | Date | string
  }

  export type OrganizacionCreateWithoutSucursalesInput = {
    nombre: string
    estado: string
    fecha_creacion?: Date | string
  }

  export type OrganizacionUncheckedCreateWithoutSucursalesInput = {
    id_organizacion?: number
    nombre: string
    estado: string
    fecha_creacion?: Date | string
  }

  export type OrganizacionCreateOrConnectWithoutSucursalesInput = {
    where: OrganizacionWhereUniqueInput
    create: XOR<OrganizacionCreateWithoutSucursalesInput, OrganizacionUncheckedCreateWithoutSucursalesInput>
  }

  export type InstalacionCreateWithoutSucursalInput = {
    nombre_instalacion: string
    fecha_creacion?: Date | string
    sensores?: SensorInstaladoCreateNestedManyWithoutInstalacionInput
  }

  export type InstalacionUncheckedCreateWithoutSucursalInput = {
    id_instalacion?: number
    nombre_instalacion: string
    fecha_creacion?: Date | string
    sensores?: SensorInstaladoUncheckedCreateNestedManyWithoutInstalacionInput
  }

  export type InstalacionCreateOrConnectWithoutSucursalInput = {
    where: InstalacionWhereUniqueInput
    create: XOR<InstalacionCreateWithoutSucursalInput, InstalacionUncheckedCreateWithoutSucursalInput>
  }

  export type InstalacionCreateManySucursalInputEnvelope = {
    data: InstalacionCreateManySucursalInput | InstalacionCreateManySucursalInput[]
    skipDuplicates?: boolean
  }

  export type OrganizacionUpsertWithoutSucursalesInput = {
    update: XOR<OrganizacionUpdateWithoutSucursalesInput, OrganizacionUncheckedUpdateWithoutSucursalesInput>
    create: XOR<OrganizacionCreateWithoutSucursalesInput, OrganizacionUncheckedCreateWithoutSucursalesInput>
    where?: OrganizacionWhereInput
  }

  export type OrganizacionUpdateToOneWithWhereWithoutSucursalesInput = {
    where?: OrganizacionWhereInput
    data: XOR<OrganizacionUpdateWithoutSucursalesInput, OrganizacionUncheckedUpdateWithoutSucursalesInput>
  }

  export type OrganizacionUpdateWithoutSucursalesInput = {
    nombre?: StringFieldUpdateOperationsInput | string
    estado?: StringFieldUpdateOperationsInput | string
    fecha_creacion?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type OrganizacionUncheckedUpdateWithoutSucursalesInput = {
    id_organizacion?: IntFieldUpdateOperationsInput | number
    nombre?: StringFieldUpdateOperationsInput | string
    estado?: StringFieldUpdateOperationsInput | string
    fecha_creacion?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type InstalacionUpsertWithWhereUniqueWithoutSucursalInput = {
    where: InstalacionWhereUniqueInput
    update: XOR<InstalacionUpdateWithoutSucursalInput, InstalacionUncheckedUpdateWithoutSucursalInput>
    create: XOR<InstalacionCreateWithoutSucursalInput, InstalacionUncheckedCreateWithoutSucursalInput>
  }

  export type InstalacionUpdateWithWhereUniqueWithoutSucursalInput = {
    where: InstalacionWhereUniqueInput
    data: XOR<InstalacionUpdateWithoutSucursalInput, InstalacionUncheckedUpdateWithoutSucursalInput>
  }

  export type InstalacionUpdateManyWithWhereWithoutSucursalInput = {
    where: InstalacionScalarWhereInput
    data: XOR<InstalacionUpdateManyMutationInput, InstalacionUncheckedUpdateManyWithoutSucursalInput>
  }

  export type InstalacionScalarWhereInput = {
    AND?: InstalacionScalarWhereInput | InstalacionScalarWhereInput[]
    OR?: InstalacionScalarWhereInput[]
    NOT?: InstalacionScalarWhereInput | InstalacionScalarWhereInput[]
    id_instalacion?: IntFilter<"Instalacion"> | number
    id_organizacion_sucursal?: IntFilter<"Instalacion"> | number
    nombre_instalacion?: StringFilter<"Instalacion"> | string
    fecha_creacion?: DateTimeFilter<"Instalacion"> | Date | string
  }

  export type OrganizacionSucursalCreateWithoutInstalacionesInput = {
    nombre_sucursal: string
    estado: string
    fecha_creacion?: Date | string
    organizacion: OrganizacionCreateNestedOneWithoutSucursalesInput
  }

  export type OrganizacionSucursalUncheckedCreateWithoutInstalacionesInput = {
    id_organizacion_sucursal?: number
    id_organizacion: number
    nombre_sucursal: string
    estado: string
    fecha_creacion?: Date | string
  }

  export type OrganizacionSucursalCreateOrConnectWithoutInstalacionesInput = {
    where: OrganizacionSucursalWhereUniqueInput
    create: XOR<OrganizacionSucursalCreateWithoutInstalacionesInput, OrganizacionSucursalUncheckedCreateWithoutInstalacionesInput>
  }

  export type SensorInstaladoCreateWithoutInstalacionInput = {
    descripcion?: string | null
    fecha_instalada?: Date | string | null
    catalogo: CatalogoSensorCreateNestedOneWithoutSensoresInstaladosInput
    lecturas?: LecturaCreateNestedManyWithoutSensorInput
  }

  export type SensorInstaladoUncheckedCreateWithoutInstalacionInput = {
    id_sensor_instalado?: number
    id_sensor: number
    descripcion?: string | null
    fecha_instalada?: Date | string | null
    lecturas?: LecturaUncheckedCreateNestedManyWithoutSensorInput
  }

  export type SensorInstaladoCreateOrConnectWithoutInstalacionInput = {
    where: SensorInstaladoWhereUniqueInput
    create: XOR<SensorInstaladoCreateWithoutInstalacionInput, SensorInstaladoUncheckedCreateWithoutInstalacionInput>
  }

  export type SensorInstaladoCreateManyInstalacionInputEnvelope = {
    data: SensorInstaladoCreateManyInstalacionInput | SensorInstaladoCreateManyInstalacionInput[]
    skipDuplicates?: boolean
  }

  export type OrganizacionSucursalUpsertWithoutInstalacionesInput = {
    update: XOR<OrganizacionSucursalUpdateWithoutInstalacionesInput, OrganizacionSucursalUncheckedUpdateWithoutInstalacionesInput>
    create: XOR<OrganizacionSucursalCreateWithoutInstalacionesInput, OrganizacionSucursalUncheckedCreateWithoutInstalacionesInput>
    where?: OrganizacionSucursalWhereInput
  }

  export type OrganizacionSucursalUpdateToOneWithWhereWithoutInstalacionesInput = {
    where?: OrganizacionSucursalWhereInput
    data: XOR<OrganizacionSucursalUpdateWithoutInstalacionesInput, OrganizacionSucursalUncheckedUpdateWithoutInstalacionesInput>
  }

  export type OrganizacionSucursalUpdateWithoutInstalacionesInput = {
    nombre_sucursal?: StringFieldUpdateOperationsInput | string
    estado?: StringFieldUpdateOperationsInput | string
    fecha_creacion?: DateTimeFieldUpdateOperationsInput | Date | string
    organizacion?: OrganizacionUpdateOneRequiredWithoutSucursalesNestedInput
  }

  export type OrganizacionSucursalUncheckedUpdateWithoutInstalacionesInput = {
    id_organizacion_sucursal?: IntFieldUpdateOperationsInput | number
    id_organizacion?: IntFieldUpdateOperationsInput | number
    nombre_sucursal?: StringFieldUpdateOperationsInput | string
    estado?: StringFieldUpdateOperationsInput | string
    fecha_creacion?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type SensorInstaladoUpsertWithWhereUniqueWithoutInstalacionInput = {
    where: SensorInstaladoWhereUniqueInput
    update: XOR<SensorInstaladoUpdateWithoutInstalacionInput, SensorInstaladoUncheckedUpdateWithoutInstalacionInput>
    create: XOR<SensorInstaladoCreateWithoutInstalacionInput, SensorInstaladoUncheckedCreateWithoutInstalacionInput>
  }

  export type SensorInstaladoUpdateWithWhereUniqueWithoutInstalacionInput = {
    where: SensorInstaladoWhereUniqueInput
    data: XOR<SensorInstaladoUpdateWithoutInstalacionInput, SensorInstaladoUncheckedUpdateWithoutInstalacionInput>
  }

  export type SensorInstaladoUpdateManyWithWhereWithoutInstalacionInput = {
    where: SensorInstaladoScalarWhereInput
    data: XOR<SensorInstaladoUpdateManyMutationInput, SensorInstaladoUncheckedUpdateManyWithoutInstalacionInput>
  }

  export type SensorInstaladoScalarWhereInput = {
    AND?: SensorInstaladoScalarWhereInput | SensorInstaladoScalarWhereInput[]
    OR?: SensorInstaladoScalarWhereInput[]
    NOT?: SensorInstaladoScalarWhereInput | SensorInstaladoScalarWhereInput[]
    id_sensor_instalado?: IntFilter<"SensorInstalado"> | number
    id_instalacion?: IntFilter<"SensorInstalado"> | number
    id_sensor?: IntFilter<"SensorInstalado"> | number
    descripcion?: StringNullableFilter<"SensorInstalado"> | string | null
    fecha_instalada?: DateTimeNullableFilter<"SensorInstalado"> | Date | string | null
  }

  export type SensorInstaladoCreateWithoutCatalogoInput = {
    descripcion?: string | null
    fecha_instalada?: Date | string | null
    instalacion: InstalacionCreateNestedOneWithoutSensoresInput
    lecturas?: LecturaCreateNestedManyWithoutSensorInput
  }

  export type SensorInstaladoUncheckedCreateWithoutCatalogoInput = {
    id_sensor_instalado?: number
    id_instalacion: number
    descripcion?: string | null
    fecha_instalada?: Date | string | null
    lecturas?: LecturaUncheckedCreateNestedManyWithoutSensorInput
  }

  export type SensorInstaladoCreateOrConnectWithoutCatalogoInput = {
    where: SensorInstaladoWhereUniqueInput
    create: XOR<SensorInstaladoCreateWithoutCatalogoInput, SensorInstaladoUncheckedCreateWithoutCatalogoInput>
  }

  export type SensorInstaladoCreateManyCatalogoInputEnvelope = {
    data: SensorInstaladoCreateManyCatalogoInput | SensorInstaladoCreateManyCatalogoInput[]
    skipDuplicates?: boolean
  }

  export type SensorInstaladoUpsertWithWhereUniqueWithoutCatalogoInput = {
    where: SensorInstaladoWhereUniqueInput
    update: XOR<SensorInstaladoUpdateWithoutCatalogoInput, SensorInstaladoUncheckedUpdateWithoutCatalogoInput>
    create: XOR<SensorInstaladoCreateWithoutCatalogoInput, SensorInstaladoUncheckedCreateWithoutCatalogoInput>
  }

  export type SensorInstaladoUpdateWithWhereUniqueWithoutCatalogoInput = {
    where: SensorInstaladoWhereUniqueInput
    data: XOR<SensorInstaladoUpdateWithoutCatalogoInput, SensorInstaladoUncheckedUpdateWithoutCatalogoInput>
  }

  export type SensorInstaladoUpdateManyWithWhereWithoutCatalogoInput = {
    where: SensorInstaladoScalarWhereInput
    data: XOR<SensorInstaladoUpdateManyMutationInput, SensorInstaladoUncheckedUpdateManyWithoutCatalogoInput>
  }

  export type InstalacionCreateWithoutSensoresInput = {
    nombre_instalacion: string
    fecha_creacion?: Date | string
    sucursal: OrganizacionSucursalCreateNestedOneWithoutInstalacionesInput
  }

  export type InstalacionUncheckedCreateWithoutSensoresInput = {
    id_instalacion?: number
    id_organizacion_sucursal: number
    nombre_instalacion: string
    fecha_creacion?: Date | string
  }

  export type InstalacionCreateOrConnectWithoutSensoresInput = {
    where: InstalacionWhereUniqueInput
    create: XOR<InstalacionCreateWithoutSensoresInput, InstalacionUncheckedCreateWithoutSensoresInput>
  }

  export type CatalogoSensorCreateWithoutSensoresInstaladosInput = {
    nombre: string
    unidad?: string | null
    tipo_medida?: $Enums.TipoMedida | null
    rango_min?: Decimal | DecimalJsLike | number | string | null
    rango_max?: Decimal | DecimalJsLike | number | string | null
  }

  export type CatalogoSensorUncheckedCreateWithoutSensoresInstaladosInput = {
    id_sensor?: number
    nombre: string
    unidad?: string | null
    tipo_medida?: $Enums.TipoMedida | null
    rango_min?: Decimal | DecimalJsLike | number | string | null
    rango_max?: Decimal | DecimalJsLike | number | string | null
  }

  export type CatalogoSensorCreateOrConnectWithoutSensoresInstaladosInput = {
    where: CatalogoSensorWhereUniqueInput
    create: XOR<CatalogoSensorCreateWithoutSensoresInstaladosInput, CatalogoSensorUncheckedCreateWithoutSensoresInstaladosInput>
  }

  export type LecturaCreateWithoutSensorInput = {
    id_lectura?: bigint | number
    valor: Decimal | DecimalJsLike | number | string
    tomada_en: Date | string
  }

  export type LecturaUncheckedCreateWithoutSensorInput = {
    id_lectura?: bigint | number
    valor: Decimal | DecimalJsLike | number | string
    tomada_en: Date | string
  }

  export type LecturaCreateOrConnectWithoutSensorInput = {
    where: LecturaWhereUniqueInput
    create: XOR<LecturaCreateWithoutSensorInput, LecturaUncheckedCreateWithoutSensorInput>
  }

  export type LecturaCreateManySensorInputEnvelope = {
    data: LecturaCreateManySensorInput | LecturaCreateManySensorInput[]
    skipDuplicates?: boolean
  }

  export type InstalacionUpsertWithoutSensoresInput = {
    update: XOR<InstalacionUpdateWithoutSensoresInput, InstalacionUncheckedUpdateWithoutSensoresInput>
    create: XOR<InstalacionCreateWithoutSensoresInput, InstalacionUncheckedCreateWithoutSensoresInput>
    where?: InstalacionWhereInput
  }

  export type InstalacionUpdateToOneWithWhereWithoutSensoresInput = {
    where?: InstalacionWhereInput
    data: XOR<InstalacionUpdateWithoutSensoresInput, InstalacionUncheckedUpdateWithoutSensoresInput>
  }

  export type InstalacionUpdateWithoutSensoresInput = {
    nombre_instalacion?: StringFieldUpdateOperationsInput | string
    fecha_creacion?: DateTimeFieldUpdateOperationsInput | Date | string
    sucursal?: OrganizacionSucursalUpdateOneRequiredWithoutInstalacionesNestedInput
  }

  export type InstalacionUncheckedUpdateWithoutSensoresInput = {
    id_instalacion?: IntFieldUpdateOperationsInput | number
    id_organizacion_sucursal?: IntFieldUpdateOperationsInput | number
    nombre_instalacion?: StringFieldUpdateOperationsInput | string
    fecha_creacion?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type CatalogoSensorUpsertWithoutSensoresInstaladosInput = {
    update: XOR<CatalogoSensorUpdateWithoutSensoresInstaladosInput, CatalogoSensorUncheckedUpdateWithoutSensoresInstaladosInput>
    create: XOR<CatalogoSensorCreateWithoutSensoresInstaladosInput, CatalogoSensorUncheckedCreateWithoutSensoresInstaladosInput>
    where?: CatalogoSensorWhereInput
  }

  export type CatalogoSensorUpdateToOneWithWhereWithoutSensoresInstaladosInput = {
    where?: CatalogoSensorWhereInput
    data: XOR<CatalogoSensorUpdateWithoutSensoresInstaladosInput, CatalogoSensorUncheckedUpdateWithoutSensoresInstaladosInput>
  }

  export type CatalogoSensorUpdateWithoutSensoresInstaladosInput = {
    nombre?: StringFieldUpdateOperationsInput | string
    unidad?: NullableStringFieldUpdateOperationsInput | string | null
    tipo_medida?: NullableEnumTipoMedidaFieldUpdateOperationsInput | $Enums.TipoMedida | null
    rango_min?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    rango_max?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
  }

  export type CatalogoSensorUncheckedUpdateWithoutSensoresInstaladosInput = {
    id_sensor?: IntFieldUpdateOperationsInput | number
    nombre?: StringFieldUpdateOperationsInput | string
    unidad?: NullableStringFieldUpdateOperationsInput | string | null
    tipo_medida?: NullableEnumTipoMedidaFieldUpdateOperationsInput | $Enums.TipoMedida | null
    rango_min?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    rango_max?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
  }

  export type LecturaUpsertWithWhereUniqueWithoutSensorInput = {
    where: LecturaWhereUniqueInput
    update: XOR<LecturaUpdateWithoutSensorInput, LecturaUncheckedUpdateWithoutSensorInput>
    create: XOR<LecturaCreateWithoutSensorInput, LecturaUncheckedCreateWithoutSensorInput>
  }

  export type LecturaUpdateWithWhereUniqueWithoutSensorInput = {
    where: LecturaWhereUniqueInput
    data: XOR<LecturaUpdateWithoutSensorInput, LecturaUncheckedUpdateWithoutSensorInput>
  }

  export type LecturaUpdateManyWithWhereWithoutSensorInput = {
    where: LecturaScalarWhereInput
    data: XOR<LecturaUpdateManyMutationInput, LecturaUncheckedUpdateManyWithoutSensorInput>
  }

  export type LecturaScalarWhereInput = {
    AND?: LecturaScalarWhereInput | LecturaScalarWhereInput[]
    OR?: LecturaScalarWhereInput[]
    NOT?: LecturaScalarWhereInput | LecturaScalarWhereInput[]
    id_lectura?: BigIntFilter<"Lectura"> | bigint | number
    id_sensor_instalado?: IntFilter<"Lectura"> | number
    valor?: DecimalFilter<"Lectura"> | Decimal | DecimalJsLike | number | string
    tomada_en?: DateTimeFilter<"Lectura"> | Date | string
  }

  export type SensorInstaladoCreateWithoutLecturasInput = {
    descripcion?: string | null
    fecha_instalada?: Date | string | null
    instalacion: InstalacionCreateNestedOneWithoutSensoresInput
    catalogo: CatalogoSensorCreateNestedOneWithoutSensoresInstaladosInput
  }

  export type SensorInstaladoUncheckedCreateWithoutLecturasInput = {
    id_sensor_instalado?: number
    id_instalacion: number
    id_sensor: number
    descripcion?: string | null
    fecha_instalada?: Date | string | null
  }

  export type SensorInstaladoCreateOrConnectWithoutLecturasInput = {
    where: SensorInstaladoWhereUniqueInput
    create: XOR<SensorInstaladoCreateWithoutLecturasInput, SensorInstaladoUncheckedCreateWithoutLecturasInput>
  }

  export type SensorInstaladoUpsertWithoutLecturasInput = {
    update: XOR<SensorInstaladoUpdateWithoutLecturasInput, SensorInstaladoUncheckedUpdateWithoutLecturasInput>
    create: XOR<SensorInstaladoCreateWithoutLecturasInput, SensorInstaladoUncheckedCreateWithoutLecturasInput>
    where?: SensorInstaladoWhereInput
  }

  export type SensorInstaladoUpdateToOneWithWhereWithoutLecturasInput = {
    where?: SensorInstaladoWhereInput
    data: XOR<SensorInstaladoUpdateWithoutLecturasInput, SensorInstaladoUncheckedUpdateWithoutLecturasInput>
  }

  export type SensorInstaladoUpdateWithoutLecturasInput = {
    descripcion?: NullableStringFieldUpdateOperationsInput | string | null
    fecha_instalada?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    instalacion?: InstalacionUpdateOneRequiredWithoutSensoresNestedInput
    catalogo?: CatalogoSensorUpdateOneRequiredWithoutSensoresInstaladosNestedInput
  }

  export type SensorInstaladoUncheckedUpdateWithoutLecturasInput = {
    id_sensor_instalado?: IntFieldUpdateOperationsInput | number
    id_instalacion?: IntFieldUpdateOperationsInput | number
    id_sensor?: IntFieldUpdateOperationsInput | number
    descripcion?: NullableStringFieldUpdateOperationsInput | string | null
    fecha_instalada?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
  }

  export type MunicipioCreateWithoutEstadoInput = {
    nombre: string
    codigosPostales?: CodigoPostalCreateNestedManyWithoutMunicipioInput
  }

  export type MunicipioUncheckedCreateWithoutEstadoInput = {
    id_municipio?: number
    nombre: string
    codigosPostales?: CodigoPostalUncheckedCreateNestedManyWithoutMunicipioInput
  }

  export type MunicipioCreateOrConnectWithoutEstadoInput = {
    where: MunicipioWhereUniqueInput
    create: XOR<MunicipioCreateWithoutEstadoInput, MunicipioUncheckedCreateWithoutEstadoInput>
  }

  export type MunicipioCreateManyEstadoInputEnvelope = {
    data: MunicipioCreateManyEstadoInput | MunicipioCreateManyEstadoInput[]
    skipDuplicates?: boolean
  }

  export type MunicipioUpsertWithWhereUniqueWithoutEstadoInput = {
    where: MunicipioWhereUniqueInput
    update: XOR<MunicipioUpdateWithoutEstadoInput, MunicipioUncheckedUpdateWithoutEstadoInput>
    create: XOR<MunicipioCreateWithoutEstadoInput, MunicipioUncheckedCreateWithoutEstadoInput>
  }

  export type MunicipioUpdateWithWhereUniqueWithoutEstadoInput = {
    where: MunicipioWhereUniqueInput
    data: XOR<MunicipioUpdateWithoutEstadoInput, MunicipioUncheckedUpdateWithoutEstadoInput>
  }

  export type MunicipioUpdateManyWithWhereWithoutEstadoInput = {
    where: MunicipioScalarWhereInput
    data: XOR<MunicipioUpdateManyMutationInput, MunicipioUncheckedUpdateManyWithoutEstadoInput>
  }

  export type MunicipioScalarWhereInput = {
    AND?: MunicipioScalarWhereInput | MunicipioScalarWhereInput[]
    OR?: MunicipioScalarWhereInput[]
    NOT?: MunicipioScalarWhereInput | MunicipioScalarWhereInput[]
    id_municipio?: IntFilter<"Municipio"> | number
    id_estado?: IntFilter<"Municipio"> | number
    nombre?: StringFilter<"Municipio"> | string
  }

  export type EstadoCreateWithoutMunicipiosInput = {
    nombre: string
    codigo: string
  }

  export type EstadoUncheckedCreateWithoutMunicipiosInput = {
    id_estado?: number
    nombre: string
    codigo: string
  }

  export type EstadoCreateOrConnectWithoutMunicipiosInput = {
    where: EstadoWhereUniqueInput
    create: XOR<EstadoCreateWithoutMunicipiosInput, EstadoUncheckedCreateWithoutMunicipiosInput>
  }

  export type CodigoPostalCreateWithoutMunicipioInput = {
    codigo_postal: string
    colonias?: ColoniaCreateNestedManyWithoutCodigoPostalInput
  }

  export type CodigoPostalUncheckedCreateWithoutMunicipioInput = {
    id_codigo_postal?: number
    codigo_postal: string
    colonias?: ColoniaUncheckedCreateNestedManyWithoutCodigoPostalInput
  }

  export type CodigoPostalCreateOrConnectWithoutMunicipioInput = {
    where: CodigoPostalWhereUniqueInput
    create: XOR<CodigoPostalCreateWithoutMunicipioInput, CodigoPostalUncheckedCreateWithoutMunicipioInput>
  }

  export type CodigoPostalCreateManyMunicipioInputEnvelope = {
    data: CodigoPostalCreateManyMunicipioInput | CodigoPostalCreateManyMunicipioInput[]
    skipDuplicates?: boolean
  }

  export type EstadoUpsertWithoutMunicipiosInput = {
    update: XOR<EstadoUpdateWithoutMunicipiosInput, EstadoUncheckedUpdateWithoutMunicipiosInput>
    create: XOR<EstadoCreateWithoutMunicipiosInput, EstadoUncheckedCreateWithoutMunicipiosInput>
    where?: EstadoWhereInput
  }

  export type EstadoUpdateToOneWithWhereWithoutMunicipiosInput = {
    where?: EstadoWhereInput
    data: XOR<EstadoUpdateWithoutMunicipiosInput, EstadoUncheckedUpdateWithoutMunicipiosInput>
  }

  export type EstadoUpdateWithoutMunicipiosInput = {
    nombre?: StringFieldUpdateOperationsInput | string
    codigo?: StringFieldUpdateOperationsInput | string
  }

  export type EstadoUncheckedUpdateWithoutMunicipiosInput = {
    id_estado?: IntFieldUpdateOperationsInput | number
    nombre?: StringFieldUpdateOperationsInput | string
    codigo?: StringFieldUpdateOperationsInput | string
  }

  export type CodigoPostalUpsertWithWhereUniqueWithoutMunicipioInput = {
    where: CodigoPostalWhereUniqueInput
    update: XOR<CodigoPostalUpdateWithoutMunicipioInput, CodigoPostalUncheckedUpdateWithoutMunicipioInput>
    create: XOR<CodigoPostalCreateWithoutMunicipioInput, CodigoPostalUncheckedCreateWithoutMunicipioInput>
  }

  export type CodigoPostalUpdateWithWhereUniqueWithoutMunicipioInput = {
    where: CodigoPostalWhereUniqueInput
    data: XOR<CodigoPostalUpdateWithoutMunicipioInput, CodigoPostalUncheckedUpdateWithoutMunicipioInput>
  }

  export type CodigoPostalUpdateManyWithWhereWithoutMunicipioInput = {
    where: CodigoPostalScalarWhereInput
    data: XOR<CodigoPostalUpdateManyMutationInput, CodigoPostalUncheckedUpdateManyWithoutMunicipioInput>
  }

  export type CodigoPostalScalarWhereInput = {
    AND?: CodigoPostalScalarWhereInput | CodigoPostalScalarWhereInput[]
    OR?: CodigoPostalScalarWhereInput[]
    NOT?: CodigoPostalScalarWhereInput | CodigoPostalScalarWhereInput[]
    id_codigo_postal?: IntFilter<"CodigoPostal"> | number
    id_municipio?: IntFilter<"CodigoPostal"> | number
    codigo_postal?: StringFilter<"CodigoPostal"> | string
  }

  export type MunicipioCreateWithoutCodigosPostalesInput = {
    nombre: string
    estado: EstadoCreateNestedOneWithoutMunicipiosInput
  }

  export type MunicipioUncheckedCreateWithoutCodigosPostalesInput = {
    id_municipio?: number
    id_estado: number
    nombre: string
  }

  export type MunicipioCreateOrConnectWithoutCodigosPostalesInput = {
    where: MunicipioWhereUniqueInput
    create: XOR<MunicipioCreateWithoutCodigosPostalesInput, MunicipioUncheckedCreateWithoutCodigosPostalesInput>
  }

  export type ColoniaCreateWithoutCodigoPostalInput = {
    nombre: string
  }

  export type ColoniaUncheckedCreateWithoutCodigoPostalInput = {
    id_colonia?: number
    nombre: string
  }

  export type ColoniaCreateOrConnectWithoutCodigoPostalInput = {
    where: ColoniaWhereUniqueInput
    create: XOR<ColoniaCreateWithoutCodigoPostalInput, ColoniaUncheckedCreateWithoutCodigoPostalInput>
  }

  export type ColoniaCreateManyCodigoPostalInputEnvelope = {
    data: ColoniaCreateManyCodigoPostalInput | ColoniaCreateManyCodigoPostalInput[]
    skipDuplicates?: boolean
  }

  export type MunicipioUpsertWithoutCodigosPostalesInput = {
    update: XOR<MunicipioUpdateWithoutCodigosPostalesInput, MunicipioUncheckedUpdateWithoutCodigosPostalesInput>
    create: XOR<MunicipioCreateWithoutCodigosPostalesInput, MunicipioUncheckedCreateWithoutCodigosPostalesInput>
    where?: MunicipioWhereInput
  }

  export type MunicipioUpdateToOneWithWhereWithoutCodigosPostalesInput = {
    where?: MunicipioWhereInput
    data: XOR<MunicipioUpdateWithoutCodigosPostalesInput, MunicipioUncheckedUpdateWithoutCodigosPostalesInput>
  }

  export type MunicipioUpdateWithoutCodigosPostalesInput = {
    nombre?: StringFieldUpdateOperationsInput | string
    estado?: EstadoUpdateOneRequiredWithoutMunicipiosNestedInput
  }

  export type MunicipioUncheckedUpdateWithoutCodigosPostalesInput = {
    id_municipio?: IntFieldUpdateOperationsInput | number
    id_estado?: IntFieldUpdateOperationsInput | number
    nombre?: StringFieldUpdateOperationsInput | string
  }

  export type ColoniaUpsertWithWhereUniqueWithoutCodigoPostalInput = {
    where: ColoniaWhereUniqueInput
    update: XOR<ColoniaUpdateWithoutCodigoPostalInput, ColoniaUncheckedUpdateWithoutCodigoPostalInput>
    create: XOR<ColoniaCreateWithoutCodigoPostalInput, ColoniaUncheckedCreateWithoutCodigoPostalInput>
  }

  export type ColoniaUpdateWithWhereUniqueWithoutCodigoPostalInput = {
    where: ColoniaWhereUniqueInput
    data: XOR<ColoniaUpdateWithoutCodigoPostalInput, ColoniaUncheckedUpdateWithoutCodigoPostalInput>
  }

  export type ColoniaUpdateManyWithWhereWithoutCodigoPostalInput = {
    where: ColoniaScalarWhereInput
    data: XOR<ColoniaUpdateManyMutationInput, ColoniaUncheckedUpdateManyWithoutCodigoPostalInput>
  }

  export type ColoniaScalarWhereInput = {
    AND?: ColoniaScalarWhereInput | ColoniaScalarWhereInput[]
    OR?: ColoniaScalarWhereInput[]
    NOT?: ColoniaScalarWhereInput | ColoniaScalarWhereInput[]
    id_colonia?: IntFilter<"Colonia"> | number
    id_codigo_postal?: IntFilter<"Colonia"> | number
    nombre?: StringFilter<"Colonia"> | string
  }

  export type CodigoPostalCreateWithoutColoniasInput = {
    codigo_postal: string
    municipio: MunicipioCreateNestedOneWithoutCodigosPostalesInput
  }

  export type CodigoPostalUncheckedCreateWithoutColoniasInput = {
    id_codigo_postal?: number
    id_municipio: number
    codigo_postal: string
  }

  export type CodigoPostalCreateOrConnectWithoutColoniasInput = {
    where: CodigoPostalWhereUniqueInput
    create: XOR<CodigoPostalCreateWithoutColoniasInput, CodigoPostalUncheckedCreateWithoutColoniasInput>
  }

  export type CodigoPostalUpsertWithoutColoniasInput = {
    update: XOR<CodigoPostalUpdateWithoutColoniasInput, CodigoPostalUncheckedUpdateWithoutColoniasInput>
    create: XOR<CodigoPostalCreateWithoutColoniasInput, CodigoPostalUncheckedCreateWithoutColoniasInput>
    where?: CodigoPostalWhereInput
  }

  export type CodigoPostalUpdateToOneWithWhereWithoutColoniasInput = {
    where?: CodigoPostalWhereInput
    data: XOR<CodigoPostalUpdateWithoutColoniasInput, CodigoPostalUncheckedUpdateWithoutColoniasInput>
  }

  export type CodigoPostalUpdateWithoutColoniasInput = {
    codigo_postal?: StringFieldUpdateOperationsInput | string
    municipio?: MunicipioUpdateOneRequiredWithoutCodigosPostalesNestedInput
  }

  export type CodigoPostalUncheckedUpdateWithoutColoniasInput = {
    id_codigo_postal?: IntFieldUpdateOperationsInput | number
    id_municipio?: IntFieldUpdateOperationsInput | number
    codigo_postal?: StringFieldUpdateOperationsInput | string
  }

  export type TipoRolCreateWithoutUsuariosInput = {
    nombre_rol: string
    descripcion?: string | null
  }

  export type TipoRolUncheckedCreateWithoutUsuariosInput = {
    id_tipo_rol?: number
    nombre_rol: string
    descripcion?: string | null
  }

  export type TipoRolCreateOrConnectWithoutUsuariosInput = {
    where: TipoRolWhereUniqueInput
    create: XOR<TipoRolCreateWithoutUsuariosInput, TipoRolUncheckedCreateWithoutUsuariosInput>
  }

  export type TipoRolUpsertWithoutUsuariosInput = {
    update: XOR<TipoRolUpdateWithoutUsuariosInput, TipoRolUncheckedUpdateWithoutUsuariosInput>
    create: XOR<TipoRolCreateWithoutUsuariosInput, TipoRolUncheckedCreateWithoutUsuariosInput>
    where?: TipoRolWhereInput
  }

  export type TipoRolUpdateToOneWithWhereWithoutUsuariosInput = {
    where?: TipoRolWhereInput
    data: XOR<TipoRolUpdateWithoutUsuariosInput, TipoRolUncheckedUpdateWithoutUsuariosInput>
  }

  export type TipoRolUpdateWithoutUsuariosInput = {
    nombre_rol?: StringFieldUpdateOperationsInput | string
    descripcion?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type TipoRolUncheckedUpdateWithoutUsuariosInput = {
    id_tipo_rol?: IntFieldUpdateOperationsInput | number
    nombre_rol?: StringFieldUpdateOperationsInput | string
    descripcion?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type UsuarioCreateWithoutTipoRolInput = {
    nombre: string
    email: string
    password_hash: string
    activo?: boolean
    fecha_creacion?: Date | string
  }

  export type UsuarioUncheckedCreateWithoutTipoRolInput = {
    id_usuario?: number
    nombre: string
    email: string
    password_hash: string
    activo?: boolean
    fecha_creacion?: Date | string
  }

  export type UsuarioCreateOrConnectWithoutTipoRolInput = {
    where: UsuarioWhereUniqueInput
    create: XOR<UsuarioCreateWithoutTipoRolInput, UsuarioUncheckedCreateWithoutTipoRolInput>
  }

  export type UsuarioCreateManyTipoRolInputEnvelope = {
    data: UsuarioCreateManyTipoRolInput | UsuarioCreateManyTipoRolInput[]
    skipDuplicates?: boolean
  }

  export type UsuarioUpsertWithWhereUniqueWithoutTipoRolInput = {
    where: UsuarioWhereUniqueInput
    update: XOR<UsuarioUpdateWithoutTipoRolInput, UsuarioUncheckedUpdateWithoutTipoRolInput>
    create: XOR<UsuarioCreateWithoutTipoRolInput, UsuarioUncheckedCreateWithoutTipoRolInput>
  }

  export type UsuarioUpdateWithWhereUniqueWithoutTipoRolInput = {
    where: UsuarioWhereUniqueInput
    data: XOR<UsuarioUpdateWithoutTipoRolInput, UsuarioUncheckedUpdateWithoutTipoRolInput>
  }

  export type UsuarioUpdateManyWithWhereWithoutTipoRolInput = {
    where: UsuarioScalarWhereInput
    data: XOR<UsuarioUpdateManyMutationInput, UsuarioUncheckedUpdateManyWithoutTipoRolInput>
  }

  export type UsuarioScalarWhereInput = {
    AND?: UsuarioScalarWhereInput | UsuarioScalarWhereInput[]
    OR?: UsuarioScalarWhereInput[]
    NOT?: UsuarioScalarWhereInput | UsuarioScalarWhereInput[]
    id_usuario?: IntFilter<"Usuario"> | number
    nombre?: StringFilter<"Usuario"> | string
    email?: StringFilter<"Usuario"> | string
    password_hash?: StringFilter<"Usuario"> | string
    id_tipo_rol?: IntFilter<"Usuario"> | number
    activo?: BoolFilter<"Usuario"> | boolean
    fecha_creacion?: DateTimeFilter<"Usuario"> | Date | string
  }

  export type EspecieParametroCreateWithoutParametroInput = {
    id_especie: number
    valor_optimo_min?: Decimal | DecimalJsLike | number | string | null
    valor_optimo_max?: Decimal | DecimalJsLike | number | string | null
  }

  export type EspecieParametroUncheckedCreateWithoutParametroInput = {
    id_especie_parametro?: number
    id_especie: number
    valor_optimo_min?: Decimal | DecimalJsLike | number | string | null
    valor_optimo_max?: Decimal | DecimalJsLike | number | string | null
  }

  export type EspecieParametroCreateOrConnectWithoutParametroInput = {
    where: EspecieParametroWhereUniqueInput
    create: XOR<EspecieParametroCreateWithoutParametroInput, EspecieParametroUncheckedCreateWithoutParametroInput>
  }

  export type EspecieParametroCreateManyParametroInputEnvelope = {
    data: EspecieParametroCreateManyParametroInput | EspecieParametroCreateManyParametroInput[]
    skipDuplicates?: boolean
  }

  export type EspecieParametroUpsertWithWhereUniqueWithoutParametroInput = {
    where: EspecieParametroWhereUniqueInput
    update: XOR<EspecieParametroUpdateWithoutParametroInput, EspecieParametroUncheckedUpdateWithoutParametroInput>
    create: XOR<EspecieParametroCreateWithoutParametroInput, EspecieParametroUncheckedCreateWithoutParametroInput>
  }

  export type EspecieParametroUpdateWithWhereUniqueWithoutParametroInput = {
    where: EspecieParametroWhereUniqueInput
    data: XOR<EspecieParametroUpdateWithoutParametroInput, EspecieParametroUncheckedUpdateWithoutParametroInput>
  }

  export type EspecieParametroUpdateManyWithWhereWithoutParametroInput = {
    where: EspecieParametroScalarWhereInput
    data: XOR<EspecieParametroUpdateManyMutationInput, EspecieParametroUncheckedUpdateManyWithoutParametroInput>
  }

  export type EspecieParametroScalarWhereInput = {
    AND?: EspecieParametroScalarWhereInput | EspecieParametroScalarWhereInput[]
    OR?: EspecieParametroScalarWhereInput[]
    NOT?: EspecieParametroScalarWhereInput | EspecieParametroScalarWhereInput[]
    id_especie_parametro?: IntFilter<"EspecieParametro"> | number
    id_especie?: IntFilter<"EspecieParametro"> | number
    id_parametro?: IntFilter<"EspecieParametro"> | number
    valor_optimo_min?: DecimalNullableFilter<"EspecieParametro"> | Decimal | DecimalJsLike | number | string | null
    valor_optimo_max?: DecimalNullableFilter<"EspecieParametro"> | Decimal | DecimalJsLike | number | string | null
  }

  export type EspecieInstaladaCreateWithoutCatalogoEspecieInput = {
    id_instalacion: number
    cantidad_inicial?: number | null
    fecha_introduccion: Date | string
    estado?: string
    trackings?: EspecieTrackingCreateNestedManyWithoutEspecieInstaladaInput
  }

  export type EspecieInstaladaUncheckedCreateWithoutCatalogoEspecieInput = {
    id_especie_instalada?: number
    id_instalacion: number
    cantidad_inicial?: number | null
    fecha_introduccion: Date | string
    estado?: string
    trackings?: EspecieTrackingUncheckedCreateNestedManyWithoutEspecieInstaladaInput
  }

  export type EspecieInstaladaCreateOrConnectWithoutCatalogoEspecieInput = {
    where: EspecieInstaladaWhereUniqueInput
    create: XOR<EspecieInstaladaCreateWithoutCatalogoEspecieInput, EspecieInstaladaUncheckedCreateWithoutCatalogoEspecieInput>
  }

  export type EspecieInstaladaCreateManyCatalogoEspecieInputEnvelope = {
    data: EspecieInstaladaCreateManyCatalogoEspecieInput | EspecieInstaladaCreateManyCatalogoEspecieInput[]
    skipDuplicates?: boolean
  }

  export type EspecieInstaladaUpsertWithWhereUniqueWithoutCatalogoEspecieInput = {
    where: EspecieInstaladaWhereUniqueInput
    update: XOR<EspecieInstaladaUpdateWithoutCatalogoEspecieInput, EspecieInstaladaUncheckedUpdateWithoutCatalogoEspecieInput>
    create: XOR<EspecieInstaladaCreateWithoutCatalogoEspecieInput, EspecieInstaladaUncheckedCreateWithoutCatalogoEspecieInput>
  }

  export type EspecieInstaladaUpdateWithWhereUniqueWithoutCatalogoEspecieInput = {
    where: EspecieInstaladaWhereUniqueInput
    data: XOR<EspecieInstaladaUpdateWithoutCatalogoEspecieInput, EspecieInstaladaUncheckedUpdateWithoutCatalogoEspecieInput>
  }

  export type EspecieInstaladaUpdateManyWithWhereWithoutCatalogoEspecieInput = {
    where: EspecieInstaladaScalarWhereInput
    data: XOR<EspecieInstaladaUpdateManyMutationInput, EspecieInstaladaUncheckedUpdateManyWithoutCatalogoEspecieInput>
  }

  export type EspecieInstaladaScalarWhereInput = {
    AND?: EspecieInstaladaScalarWhereInput | EspecieInstaladaScalarWhereInput[]
    OR?: EspecieInstaladaScalarWhereInput[]
    NOT?: EspecieInstaladaScalarWhereInput | EspecieInstaladaScalarWhereInput[]
    id_especie_instalada?: IntFilter<"EspecieInstalada"> | number
    id_instalacion?: IntFilter<"EspecieInstalada"> | number
    id_especie?: IntFilter<"EspecieInstalada"> | number
    cantidad_inicial?: IntNullableFilter<"EspecieInstalada"> | number | null
    fecha_introduccion?: DateTimeFilter<"EspecieInstalada"> | Date | string
    estado?: StringFilter<"EspecieInstalada"> | string
  }

  export type CatalogoEspecieCreateWithoutEspeciesInstaladasInput = {
    nombre_cientifico: string
    nombre_comun?: string | null
    tipo?: string | null
    descripcion?: string | null
  }

  export type CatalogoEspecieUncheckedCreateWithoutEspeciesInstaladasInput = {
    id_especie?: number
    nombre_cientifico: string
    nombre_comun?: string | null
    tipo?: string | null
    descripcion?: string | null
  }

  export type CatalogoEspecieCreateOrConnectWithoutEspeciesInstaladasInput = {
    where: CatalogoEspecieWhereUniqueInput
    create: XOR<CatalogoEspecieCreateWithoutEspeciesInstaladasInput, CatalogoEspecieUncheckedCreateWithoutEspeciesInstaladasInput>
  }

  export type EspecieTrackingCreateWithoutEspecieInstaladaInput = {
    fecha_registro?: Date | string
    cantidad_actual: number
    observaciones?: string | null
  }

  export type EspecieTrackingUncheckedCreateWithoutEspecieInstaladaInput = {
    id_tracking?: number
    fecha_registro?: Date | string
    cantidad_actual: number
    observaciones?: string | null
  }

  export type EspecieTrackingCreateOrConnectWithoutEspecieInstaladaInput = {
    where: EspecieTrackingWhereUniqueInput
    create: XOR<EspecieTrackingCreateWithoutEspecieInstaladaInput, EspecieTrackingUncheckedCreateWithoutEspecieInstaladaInput>
  }

  export type EspecieTrackingCreateManyEspecieInstaladaInputEnvelope = {
    data: EspecieTrackingCreateManyEspecieInstaladaInput | EspecieTrackingCreateManyEspecieInstaladaInput[]
    skipDuplicates?: boolean
  }

  export type CatalogoEspecieUpsertWithoutEspeciesInstaladasInput = {
    update: XOR<CatalogoEspecieUpdateWithoutEspeciesInstaladasInput, CatalogoEspecieUncheckedUpdateWithoutEspeciesInstaladasInput>
    create: XOR<CatalogoEspecieCreateWithoutEspeciesInstaladasInput, CatalogoEspecieUncheckedCreateWithoutEspeciesInstaladasInput>
    where?: CatalogoEspecieWhereInput
  }

  export type CatalogoEspecieUpdateToOneWithWhereWithoutEspeciesInstaladasInput = {
    where?: CatalogoEspecieWhereInput
    data: XOR<CatalogoEspecieUpdateWithoutEspeciesInstaladasInput, CatalogoEspecieUncheckedUpdateWithoutEspeciesInstaladasInput>
  }

  export type CatalogoEspecieUpdateWithoutEspeciesInstaladasInput = {
    nombre_cientifico?: StringFieldUpdateOperationsInput | string
    nombre_comun?: NullableStringFieldUpdateOperationsInput | string | null
    tipo?: NullableStringFieldUpdateOperationsInput | string | null
    descripcion?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type CatalogoEspecieUncheckedUpdateWithoutEspeciesInstaladasInput = {
    id_especie?: IntFieldUpdateOperationsInput | number
    nombre_cientifico?: StringFieldUpdateOperationsInput | string
    nombre_comun?: NullableStringFieldUpdateOperationsInput | string | null
    tipo?: NullableStringFieldUpdateOperationsInput | string | null
    descripcion?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type EspecieTrackingUpsertWithWhereUniqueWithoutEspecieInstaladaInput = {
    where: EspecieTrackingWhereUniqueInput
    update: XOR<EspecieTrackingUpdateWithoutEspecieInstaladaInput, EspecieTrackingUncheckedUpdateWithoutEspecieInstaladaInput>
    create: XOR<EspecieTrackingCreateWithoutEspecieInstaladaInput, EspecieTrackingUncheckedCreateWithoutEspecieInstaladaInput>
  }

  export type EspecieTrackingUpdateWithWhereUniqueWithoutEspecieInstaladaInput = {
    where: EspecieTrackingWhereUniqueInput
    data: XOR<EspecieTrackingUpdateWithoutEspecieInstaladaInput, EspecieTrackingUncheckedUpdateWithoutEspecieInstaladaInput>
  }

  export type EspecieTrackingUpdateManyWithWhereWithoutEspecieInstaladaInput = {
    where: EspecieTrackingScalarWhereInput
    data: XOR<EspecieTrackingUpdateManyMutationInput, EspecieTrackingUncheckedUpdateManyWithoutEspecieInstaladaInput>
  }

  export type EspecieTrackingScalarWhereInput = {
    AND?: EspecieTrackingScalarWhereInput | EspecieTrackingScalarWhereInput[]
    OR?: EspecieTrackingScalarWhereInput[]
    NOT?: EspecieTrackingScalarWhereInput | EspecieTrackingScalarWhereInput[]
    id_tracking?: IntFilter<"EspecieTracking"> | number
    id_especie_instalada?: IntFilter<"EspecieTracking"> | number
    fecha_registro?: DateTimeFilter<"EspecieTracking"> | Date | string
    cantidad_actual?: IntFilter<"EspecieTracking"> | number
    observaciones?: StringNullableFilter<"EspecieTracking"> | string | null
  }

  export type EspecieInstaladaCreateWithoutTrackingsInput = {
    id_instalacion: number
    cantidad_inicial?: number | null
    fecha_introduccion: Date | string
    estado?: string
    catalogoEspecie: CatalogoEspecieCreateNestedOneWithoutEspeciesInstaladasInput
  }

  export type EspecieInstaladaUncheckedCreateWithoutTrackingsInput = {
    id_especie_instalada?: number
    id_instalacion: number
    id_especie: number
    cantidad_inicial?: number | null
    fecha_introduccion: Date | string
    estado?: string
  }

  export type EspecieInstaladaCreateOrConnectWithoutTrackingsInput = {
    where: EspecieInstaladaWhereUniqueInput
    create: XOR<EspecieInstaladaCreateWithoutTrackingsInput, EspecieInstaladaUncheckedCreateWithoutTrackingsInput>
  }

  export type EspecieInstaladaUpsertWithoutTrackingsInput = {
    update: XOR<EspecieInstaladaUpdateWithoutTrackingsInput, EspecieInstaladaUncheckedUpdateWithoutTrackingsInput>
    create: XOR<EspecieInstaladaCreateWithoutTrackingsInput, EspecieInstaladaUncheckedCreateWithoutTrackingsInput>
    where?: EspecieInstaladaWhereInput
  }

  export type EspecieInstaladaUpdateToOneWithWhereWithoutTrackingsInput = {
    where?: EspecieInstaladaWhereInput
    data: XOR<EspecieInstaladaUpdateWithoutTrackingsInput, EspecieInstaladaUncheckedUpdateWithoutTrackingsInput>
  }

  export type EspecieInstaladaUpdateWithoutTrackingsInput = {
    id_instalacion?: IntFieldUpdateOperationsInput | number
    cantidad_inicial?: NullableIntFieldUpdateOperationsInput | number | null
    fecha_introduccion?: DateTimeFieldUpdateOperationsInput | Date | string
    estado?: StringFieldUpdateOperationsInput | string
    catalogoEspecie?: CatalogoEspecieUpdateOneRequiredWithoutEspeciesInstaladasNestedInput
  }

  export type EspecieInstaladaUncheckedUpdateWithoutTrackingsInput = {
    id_especie_instalada?: IntFieldUpdateOperationsInput | number
    id_instalacion?: IntFieldUpdateOperationsInput | number
    id_especie?: IntFieldUpdateOperationsInput | number
    cantidad_inicial?: NullableIntFieldUpdateOperationsInput | number | null
    fecha_introduccion?: DateTimeFieldUpdateOperationsInput | Date | string
    estado?: StringFieldUpdateOperationsInput | string
  }

  export type ParametroCreateWithoutEspecieParametrosInput = {
    nombre: string
    unidad?: string | null
    descripcion?: string | null
    rango_min?: Decimal | DecimalJsLike | number | string | null
    rango_max?: Decimal | DecimalJsLike | number | string | null
  }

  export type ParametroUncheckedCreateWithoutEspecieParametrosInput = {
    id_parametro?: number
    nombre: string
    unidad?: string | null
    descripcion?: string | null
    rango_min?: Decimal | DecimalJsLike | number | string | null
    rango_max?: Decimal | DecimalJsLike | number | string | null
  }

  export type ParametroCreateOrConnectWithoutEspecieParametrosInput = {
    where: ParametroWhereUniqueInput
    create: XOR<ParametroCreateWithoutEspecieParametrosInput, ParametroUncheckedCreateWithoutEspecieParametrosInput>
  }

  export type ParametroUpsertWithoutEspecieParametrosInput = {
    update: XOR<ParametroUpdateWithoutEspecieParametrosInput, ParametroUncheckedUpdateWithoutEspecieParametrosInput>
    create: XOR<ParametroCreateWithoutEspecieParametrosInput, ParametroUncheckedCreateWithoutEspecieParametrosInput>
    where?: ParametroWhereInput
  }

  export type ParametroUpdateToOneWithWhereWithoutEspecieParametrosInput = {
    where?: ParametroWhereInput
    data: XOR<ParametroUpdateWithoutEspecieParametrosInput, ParametroUncheckedUpdateWithoutEspecieParametrosInput>
  }

  export type ParametroUpdateWithoutEspecieParametrosInput = {
    nombre?: StringFieldUpdateOperationsInput | string
    unidad?: NullableStringFieldUpdateOperationsInput | string | null
    descripcion?: NullableStringFieldUpdateOperationsInput | string | null
    rango_min?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    rango_max?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
  }

  export type ParametroUncheckedUpdateWithoutEspecieParametrosInput = {
    id_parametro?: IntFieldUpdateOperationsInput | number
    nombre?: StringFieldUpdateOperationsInput | string
    unidad?: NullableStringFieldUpdateOperationsInput | string | null
    descripcion?: NullableStringFieldUpdateOperationsInput | string | null
    rango_min?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    rango_max?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
  }

  export type OrganizacionSucursalCreateManyOrganizacionInput = {
    id_organizacion_sucursal?: number
    nombre_sucursal: string
    estado: string
    fecha_creacion?: Date | string
  }

  export type OrganizacionSucursalUpdateWithoutOrganizacionInput = {
    nombre_sucursal?: StringFieldUpdateOperationsInput | string
    estado?: StringFieldUpdateOperationsInput | string
    fecha_creacion?: DateTimeFieldUpdateOperationsInput | Date | string
    instalaciones?: InstalacionUpdateManyWithoutSucursalNestedInput
  }

  export type OrganizacionSucursalUncheckedUpdateWithoutOrganizacionInput = {
    id_organizacion_sucursal?: IntFieldUpdateOperationsInput | number
    nombre_sucursal?: StringFieldUpdateOperationsInput | string
    estado?: StringFieldUpdateOperationsInput | string
    fecha_creacion?: DateTimeFieldUpdateOperationsInput | Date | string
    instalaciones?: InstalacionUncheckedUpdateManyWithoutSucursalNestedInput
  }

  export type OrganizacionSucursalUncheckedUpdateManyWithoutOrganizacionInput = {
    id_organizacion_sucursal?: IntFieldUpdateOperationsInput | number
    nombre_sucursal?: StringFieldUpdateOperationsInput | string
    estado?: StringFieldUpdateOperationsInput | string
    fecha_creacion?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type InstalacionCreateManySucursalInput = {
    id_instalacion?: number
    nombre_instalacion: string
    fecha_creacion?: Date | string
  }

  export type InstalacionUpdateWithoutSucursalInput = {
    nombre_instalacion?: StringFieldUpdateOperationsInput | string
    fecha_creacion?: DateTimeFieldUpdateOperationsInput | Date | string
    sensores?: SensorInstaladoUpdateManyWithoutInstalacionNestedInput
  }

  export type InstalacionUncheckedUpdateWithoutSucursalInput = {
    id_instalacion?: IntFieldUpdateOperationsInput | number
    nombre_instalacion?: StringFieldUpdateOperationsInput | string
    fecha_creacion?: DateTimeFieldUpdateOperationsInput | Date | string
    sensores?: SensorInstaladoUncheckedUpdateManyWithoutInstalacionNestedInput
  }

  export type InstalacionUncheckedUpdateManyWithoutSucursalInput = {
    id_instalacion?: IntFieldUpdateOperationsInput | number
    nombre_instalacion?: StringFieldUpdateOperationsInput | string
    fecha_creacion?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type SensorInstaladoCreateManyInstalacionInput = {
    id_sensor_instalado?: number
    id_sensor: number
    descripcion?: string | null
    fecha_instalada?: Date | string | null
  }

  export type SensorInstaladoUpdateWithoutInstalacionInput = {
    descripcion?: NullableStringFieldUpdateOperationsInput | string | null
    fecha_instalada?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    catalogo?: CatalogoSensorUpdateOneRequiredWithoutSensoresInstaladosNestedInput
    lecturas?: LecturaUpdateManyWithoutSensorNestedInput
  }

  export type SensorInstaladoUncheckedUpdateWithoutInstalacionInput = {
    id_sensor_instalado?: IntFieldUpdateOperationsInput | number
    id_sensor?: IntFieldUpdateOperationsInput | number
    descripcion?: NullableStringFieldUpdateOperationsInput | string | null
    fecha_instalada?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    lecturas?: LecturaUncheckedUpdateManyWithoutSensorNestedInput
  }

  export type SensorInstaladoUncheckedUpdateManyWithoutInstalacionInput = {
    id_sensor_instalado?: IntFieldUpdateOperationsInput | number
    id_sensor?: IntFieldUpdateOperationsInput | number
    descripcion?: NullableStringFieldUpdateOperationsInput | string | null
    fecha_instalada?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
  }

  export type SensorInstaladoCreateManyCatalogoInput = {
    id_sensor_instalado?: number
    id_instalacion: number
    descripcion?: string | null
    fecha_instalada?: Date | string | null
  }

  export type SensorInstaladoUpdateWithoutCatalogoInput = {
    descripcion?: NullableStringFieldUpdateOperationsInput | string | null
    fecha_instalada?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    instalacion?: InstalacionUpdateOneRequiredWithoutSensoresNestedInput
    lecturas?: LecturaUpdateManyWithoutSensorNestedInput
  }

  export type SensorInstaladoUncheckedUpdateWithoutCatalogoInput = {
    id_sensor_instalado?: IntFieldUpdateOperationsInput | number
    id_instalacion?: IntFieldUpdateOperationsInput | number
    descripcion?: NullableStringFieldUpdateOperationsInput | string | null
    fecha_instalada?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    lecturas?: LecturaUncheckedUpdateManyWithoutSensorNestedInput
  }

  export type SensorInstaladoUncheckedUpdateManyWithoutCatalogoInput = {
    id_sensor_instalado?: IntFieldUpdateOperationsInput | number
    id_instalacion?: IntFieldUpdateOperationsInput | number
    descripcion?: NullableStringFieldUpdateOperationsInput | string | null
    fecha_instalada?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
  }

  export type LecturaCreateManySensorInput = {
    id_lectura?: bigint | number
    valor: Decimal | DecimalJsLike | number | string
    tomada_en: Date | string
  }

  export type LecturaUpdateWithoutSensorInput = {
    id_lectura?: BigIntFieldUpdateOperationsInput | bigint | number
    valor?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    tomada_en?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type LecturaUncheckedUpdateWithoutSensorInput = {
    id_lectura?: BigIntFieldUpdateOperationsInput | bigint | number
    valor?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    tomada_en?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type LecturaUncheckedUpdateManyWithoutSensorInput = {
    id_lectura?: BigIntFieldUpdateOperationsInput | bigint | number
    valor?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    tomada_en?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type MunicipioCreateManyEstadoInput = {
    id_municipio?: number
    nombre: string
  }

  export type MunicipioUpdateWithoutEstadoInput = {
    nombre?: StringFieldUpdateOperationsInput | string
    codigosPostales?: CodigoPostalUpdateManyWithoutMunicipioNestedInput
  }

  export type MunicipioUncheckedUpdateWithoutEstadoInput = {
    id_municipio?: IntFieldUpdateOperationsInput | number
    nombre?: StringFieldUpdateOperationsInput | string
    codigosPostales?: CodigoPostalUncheckedUpdateManyWithoutMunicipioNestedInput
  }

  export type MunicipioUncheckedUpdateManyWithoutEstadoInput = {
    id_municipio?: IntFieldUpdateOperationsInput | number
    nombre?: StringFieldUpdateOperationsInput | string
  }

  export type CodigoPostalCreateManyMunicipioInput = {
    id_codigo_postal?: number
    codigo_postal: string
  }

  export type CodigoPostalUpdateWithoutMunicipioInput = {
    codigo_postal?: StringFieldUpdateOperationsInput | string
    colonias?: ColoniaUpdateManyWithoutCodigoPostalNestedInput
  }

  export type CodigoPostalUncheckedUpdateWithoutMunicipioInput = {
    id_codigo_postal?: IntFieldUpdateOperationsInput | number
    codigo_postal?: StringFieldUpdateOperationsInput | string
    colonias?: ColoniaUncheckedUpdateManyWithoutCodigoPostalNestedInput
  }

  export type CodigoPostalUncheckedUpdateManyWithoutMunicipioInput = {
    id_codigo_postal?: IntFieldUpdateOperationsInput | number
    codigo_postal?: StringFieldUpdateOperationsInput | string
  }

  export type ColoniaCreateManyCodigoPostalInput = {
    id_colonia?: number
    nombre: string
  }

  export type ColoniaUpdateWithoutCodigoPostalInput = {
    nombre?: StringFieldUpdateOperationsInput | string
  }

  export type ColoniaUncheckedUpdateWithoutCodigoPostalInput = {
    id_colonia?: IntFieldUpdateOperationsInput | number
    nombre?: StringFieldUpdateOperationsInput | string
  }

  export type ColoniaUncheckedUpdateManyWithoutCodigoPostalInput = {
    id_colonia?: IntFieldUpdateOperationsInput | number
    nombre?: StringFieldUpdateOperationsInput | string
  }

  export type UsuarioCreateManyTipoRolInput = {
    id_usuario?: number
    nombre: string
    email: string
    password_hash: string
    activo?: boolean
    fecha_creacion?: Date | string
  }

  export type UsuarioUpdateWithoutTipoRolInput = {
    nombre?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    password_hash?: StringFieldUpdateOperationsInput | string
    activo?: BoolFieldUpdateOperationsInput | boolean
    fecha_creacion?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type UsuarioUncheckedUpdateWithoutTipoRolInput = {
    id_usuario?: IntFieldUpdateOperationsInput | number
    nombre?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    password_hash?: StringFieldUpdateOperationsInput | string
    activo?: BoolFieldUpdateOperationsInput | boolean
    fecha_creacion?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type UsuarioUncheckedUpdateManyWithoutTipoRolInput = {
    id_usuario?: IntFieldUpdateOperationsInput | number
    nombre?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    password_hash?: StringFieldUpdateOperationsInput | string
    activo?: BoolFieldUpdateOperationsInput | boolean
    fecha_creacion?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type EspecieParametroCreateManyParametroInput = {
    id_especie_parametro?: number
    id_especie: number
    valor_optimo_min?: Decimal | DecimalJsLike | number | string | null
    valor_optimo_max?: Decimal | DecimalJsLike | number | string | null
  }

  export type EspecieParametroUpdateWithoutParametroInput = {
    id_especie?: IntFieldUpdateOperationsInput | number
    valor_optimo_min?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    valor_optimo_max?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
  }

  export type EspecieParametroUncheckedUpdateWithoutParametroInput = {
    id_especie_parametro?: IntFieldUpdateOperationsInput | number
    id_especie?: IntFieldUpdateOperationsInput | number
    valor_optimo_min?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    valor_optimo_max?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
  }

  export type EspecieParametroUncheckedUpdateManyWithoutParametroInput = {
    id_especie_parametro?: IntFieldUpdateOperationsInput | number
    id_especie?: IntFieldUpdateOperationsInput | number
    valor_optimo_min?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    valor_optimo_max?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
  }

  export type EspecieInstaladaCreateManyCatalogoEspecieInput = {
    id_especie_instalada?: number
    id_instalacion: number
    cantidad_inicial?: number | null
    fecha_introduccion: Date | string
    estado?: string
  }

  export type EspecieInstaladaUpdateWithoutCatalogoEspecieInput = {
    id_instalacion?: IntFieldUpdateOperationsInput | number
    cantidad_inicial?: NullableIntFieldUpdateOperationsInput | number | null
    fecha_introduccion?: DateTimeFieldUpdateOperationsInput | Date | string
    estado?: StringFieldUpdateOperationsInput | string
    trackings?: EspecieTrackingUpdateManyWithoutEspecieInstaladaNestedInput
  }

  export type EspecieInstaladaUncheckedUpdateWithoutCatalogoEspecieInput = {
    id_especie_instalada?: IntFieldUpdateOperationsInput | number
    id_instalacion?: IntFieldUpdateOperationsInput | number
    cantidad_inicial?: NullableIntFieldUpdateOperationsInput | number | null
    fecha_introduccion?: DateTimeFieldUpdateOperationsInput | Date | string
    estado?: StringFieldUpdateOperationsInput | string
    trackings?: EspecieTrackingUncheckedUpdateManyWithoutEspecieInstaladaNestedInput
  }

  export type EspecieInstaladaUncheckedUpdateManyWithoutCatalogoEspecieInput = {
    id_especie_instalada?: IntFieldUpdateOperationsInput | number
    id_instalacion?: IntFieldUpdateOperationsInput | number
    cantidad_inicial?: NullableIntFieldUpdateOperationsInput | number | null
    fecha_introduccion?: DateTimeFieldUpdateOperationsInput | Date | string
    estado?: StringFieldUpdateOperationsInput | string
  }

  export type EspecieTrackingCreateManyEspecieInstaladaInput = {
    id_tracking?: number
    fecha_registro?: Date | string
    cantidad_actual: number
    observaciones?: string | null
  }

  export type EspecieTrackingUpdateWithoutEspecieInstaladaInput = {
    fecha_registro?: DateTimeFieldUpdateOperationsInput | Date | string
    cantidad_actual?: IntFieldUpdateOperationsInput | number
    observaciones?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type EspecieTrackingUncheckedUpdateWithoutEspecieInstaladaInput = {
    id_tracking?: IntFieldUpdateOperationsInput | number
    fecha_registro?: DateTimeFieldUpdateOperationsInput | Date | string
    cantidad_actual?: IntFieldUpdateOperationsInput | number
    observaciones?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type EspecieTrackingUncheckedUpdateManyWithoutEspecieInstaladaInput = {
    id_tracking?: IntFieldUpdateOperationsInput | number
    fecha_registro?: DateTimeFieldUpdateOperationsInput | Date | string
    cantidad_actual?: IntFieldUpdateOperationsInput | number
    observaciones?: NullableStringFieldUpdateOperationsInput | string | null
  }



  /**
   * Aliases for legacy arg types
   */
    /**
     * @deprecated Use OrganizacionCountOutputTypeDefaultArgs instead
     */
    export type OrganizacionCountOutputTypeArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = OrganizacionCountOutputTypeDefaultArgs<ExtArgs>
    /**
     * @deprecated Use OrganizacionSucursalCountOutputTypeDefaultArgs instead
     */
    export type OrganizacionSucursalCountOutputTypeArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = OrganizacionSucursalCountOutputTypeDefaultArgs<ExtArgs>
    /**
     * @deprecated Use InstalacionCountOutputTypeDefaultArgs instead
     */
    export type InstalacionCountOutputTypeArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = InstalacionCountOutputTypeDefaultArgs<ExtArgs>
    /**
     * @deprecated Use CatalogoSensorCountOutputTypeDefaultArgs instead
     */
    export type CatalogoSensorCountOutputTypeArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = CatalogoSensorCountOutputTypeDefaultArgs<ExtArgs>
    /**
     * @deprecated Use SensorInstaladoCountOutputTypeDefaultArgs instead
     */
    export type SensorInstaladoCountOutputTypeArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = SensorInstaladoCountOutputTypeDefaultArgs<ExtArgs>
    /**
     * @deprecated Use EstadoCountOutputTypeDefaultArgs instead
     */
    export type EstadoCountOutputTypeArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = EstadoCountOutputTypeDefaultArgs<ExtArgs>
    /**
     * @deprecated Use MunicipioCountOutputTypeDefaultArgs instead
     */
    export type MunicipioCountOutputTypeArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = MunicipioCountOutputTypeDefaultArgs<ExtArgs>
    /**
     * @deprecated Use CodigoPostalCountOutputTypeDefaultArgs instead
     */
    export type CodigoPostalCountOutputTypeArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = CodigoPostalCountOutputTypeDefaultArgs<ExtArgs>
    /**
     * @deprecated Use TipoRolCountOutputTypeDefaultArgs instead
     */
    export type TipoRolCountOutputTypeArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = TipoRolCountOutputTypeDefaultArgs<ExtArgs>
    /**
     * @deprecated Use ParametroCountOutputTypeDefaultArgs instead
     */
    export type ParametroCountOutputTypeArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = ParametroCountOutputTypeDefaultArgs<ExtArgs>
    /**
     * @deprecated Use CatalogoEspecieCountOutputTypeDefaultArgs instead
     */
    export type CatalogoEspecieCountOutputTypeArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = CatalogoEspecieCountOutputTypeDefaultArgs<ExtArgs>
    /**
     * @deprecated Use EspecieInstaladaCountOutputTypeDefaultArgs instead
     */
    export type EspecieInstaladaCountOutputTypeArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = EspecieInstaladaCountOutputTypeDefaultArgs<ExtArgs>
    /**
     * @deprecated Use OrganizacionDefaultArgs instead
     */
    export type OrganizacionArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = OrganizacionDefaultArgs<ExtArgs>
    /**
     * @deprecated Use OrganizacionSucursalDefaultArgs instead
     */
    export type OrganizacionSucursalArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = OrganizacionSucursalDefaultArgs<ExtArgs>
    /**
     * @deprecated Use InstalacionDefaultArgs instead
     */
    export type InstalacionArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = InstalacionDefaultArgs<ExtArgs>
    /**
     * @deprecated Use CatalogoSensorDefaultArgs instead
     */
    export type CatalogoSensorArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = CatalogoSensorDefaultArgs<ExtArgs>
    /**
     * @deprecated Use SensorInstaladoDefaultArgs instead
     */
    export type SensorInstaladoArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = SensorInstaladoDefaultArgs<ExtArgs>
    /**
     * @deprecated Use LecturaDefaultArgs instead
     */
    export type LecturaArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = LecturaDefaultArgs<ExtArgs>
    /**
     * @deprecated Use ResumenLecturaHorariaDefaultArgs instead
     */
    export type ResumenLecturaHorariaArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = ResumenLecturaHorariaDefaultArgs<ExtArgs>
    /**
     * @deprecated Use Promedio15minDefaultArgs instead
     */
    export type Promedio15minArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = Promedio15minDefaultArgs<ExtArgs>
    /**
     * @deprecated Use EstadoDefaultArgs instead
     */
    export type EstadoArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = EstadoDefaultArgs<ExtArgs>
    /**
     * @deprecated Use MunicipioDefaultArgs instead
     */
    export type MunicipioArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = MunicipioDefaultArgs<ExtArgs>
    /**
     * @deprecated Use CodigoPostalDefaultArgs instead
     */
    export type CodigoPostalArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = CodigoPostalDefaultArgs<ExtArgs>
    /**
     * @deprecated Use ColoniaDefaultArgs instead
     */
    export type ColoniaArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = ColoniaDefaultArgs<ExtArgs>
    /**
     * @deprecated Use UsuarioDefaultArgs instead
     */
    export type UsuarioArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = UsuarioDefaultArgs<ExtArgs>
    /**
     * @deprecated Use TipoRolDefaultArgs instead
     */
    export type TipoRolArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = TipoRolDefaultArgs<ExtArgs>
    /**
     * @deprecated Use AlertaDefaultArgs instead
     */
    export type AlertaArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = AlertaDefaultArgs<ExtArgs>
    /**
     * @deprecated Use ParametroDefaultArgs instead
     */
    export type ParametroArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = ParametroDefaultArgs<ExtArgs>
    /**
     * @deprecated Use CatalogoEspecieDefaultArgs instead
     */
    export type CatalogoEspecieArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = CatalogoEspecieDefaultArgs<ExtArgs>
    /**
     * @deprecated Use EspecieInstaladaDefaultArgs instead
     */
    export type EspecieInstaladaArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = EspecieInstaladaDefaultArgs<ExtArgs>
    /**
     * @deprecated Use EspecieTrackingDefaultArgs instead
     */
    export type EspecieTrackingArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = EspecieTrackingDefaultArgs<ExtArgs>
    /**
     * @deprecated Use EspecieParametroDefaultArgs instead
     */
    export type EspecieParametroArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = EspecieParametroDefaultArgs<ExtArgs>
    /**
     * @deprecated Use ProcesoDefaultArgs instead
     */
    export type ProcesoArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = ProcesoDefaultArgs<ExtArgs>

  /**
   * Batch Payload for updateMany & deleteMany & createMany
   */

  export type BatchPayload = {
    count: number
  }

  /**
   * DMMF
   */
  export const dmmf: runtime.BaseDMMF
}